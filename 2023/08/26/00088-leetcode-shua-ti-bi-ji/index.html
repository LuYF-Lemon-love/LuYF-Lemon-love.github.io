<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="00088-LeetCode 刷题笔记, NLP LLM DeepLearning LuYF-Lemon-love 自然语言处理 深度学习 大语言模型">
    <meta name="description" content="前言
目前，打算不在更新（2024-4-10）。

自己的 LeetCode 刷题记录.
LeetCode 官网: https://leetcode.cn/ 。

我一共刷了150+236+12&amp;#x3D;398道题：简单题（150），中等">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>00088-LeetCode 刷题笔记 | LuYF-Lemon-love の Blog</title>
    <link rel="icon" type="image/jpeg" href="https://cos.luyf-lemon-love.space/images/苏苏1.jpeg">
    
    <style>
        body{
            background-image: url(https://cdn.jsdelivr.net/gh/Tokisaki-Galaxy/res/site/medias/background.jpg);
            background-repeat:no-repeat;
            background-size: 100% 100%;
            background-attachment:fixed;
        }
    </style>



    <!-- bg-cover style     -->



<link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.min.css">
<link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
<link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
<link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
<link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
<link rel="stylesheet" type="text/css" href="/css/matery.css">
<link rel="stylesheet" type="text/css" href="/css/my.css">
<link rel="stylesheet" type="text/css" href="/css/dark.css" media="none" onload="if(media!='all')media='all'">




    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
    <link rel="stylesheet" href="/css/post.css">




    
        <link rel="stylesheet" type="text/css" href="/css/reward.css">
    



    <script src="/libs/jquery/jquery-3.6.0.min.js"></script>

<meta name="generator" content="Hexo 7.3.0"></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <span class="logo-span">LuYF-Lemon-love の Blog</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
  <li>
    <a href="javascript:;" class="waves-effect waves-light" onclick="switchNightMode()" title="深色/浅色模式" >
      <i id="sum-moon-icon" class="fas fa-sun" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <div class="logo-name">LuYF-Lemon-love の Blog</div>
        <div class="logo-desc">
            
            天之道，损有余而补不足，人之道则不然，损不足以奉有余。
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/LuYF-Lemon-love/paper-is-all-you-need" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/LuYF-Lemon-love/paper-is-all-you-need" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    
<script src="/libs/cryptojs/crypto-js.min.js"></script>
<script>
    (function() {
        let pwd = '';
        if (pwd && pwd.length > 0) {
            if (pwd !== CryptoJS.SHA256(prompt('请输入访问本文章的密码')).toString(CryptoJS.enc.Hex)) {
                alert('密码错误，将返回主页！');
                location.href = '/';
            }
        }
    })();
</script>




<div class="bg-cover pd-header post-cover" style="background-image: url('https://cos.luyf-lemon-love.space/images/060-宣纸国画.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">00088-LeetCode 刷题笔记</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/%E5%88%B7%E9%A2%98/">
                                <span class="chip bg-color">刷题</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E5%88%B7%E9%A2%98/" class="post-category">
                                刷题
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2023-08-26
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2024-12-28
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    88.7k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    438 分
                </div>
                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/libs/prism/prism.min.css">
        

        
        <!-- 代码块折行 -->
        <style type="text/css">
            code[class*="language-"], pre[class*="language-"] { white-space: pre-wrap !important; }
        </style>
        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>目前，打算不在更新（2024-4-10）。</p>
</blockquote>
<p>自己的 LeetCode 刷题记录.</p>
<p>LeetCode 官网: <a href="https://leetcode.cn/">https://leetcode.cn/</a> 。</p>
<blockquote>
<p>我一共刷了150+236+12&#x3D;<code>398</code>道题：简单题（150），中等题（236），困难题（12）。</p>
</blockquote>
<p>操作系统：<strong>Windows 10 专业版</strong></p>
<h2 id="简单"><a href="#简单" class="headerlink" title="简单"></a>简单</h2><h3 id="面试题-05-07-配对交换"><a href="#面试题-05-07-配对交换" class="headerlink" title="面试题 05.07. 配对交换"></a>面试题 05.07. 配对交换</h3><p>问题地址：<a href="https://leetcode.cn/problems/exchange-lcci/">https://leetcode.cn/problems/exchange-lcci/</a></p>
<p>配对交换。编写程序，交换某个整数的奇数位和偶数位，尽量使用较少的指令（也就是说，位0与位1交换，位2与位3交换，以此类推）。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int exchangeBits(int num) &#123;
        return ((num &amp; 0xaaaaaaaa) &gt;&gt; 1) | ((num &amp; 0x55555555) &lt;&lt; 1);
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="剑指-Offer-57-和为s的两个数字"><a href="#剑指-Offer-57-和为s的两个数字" class="headerlink" title="剑指 Offer 57. 和为s的两个数字"></a>剑指 Offer 57. 和为s的两个数字</h3><p>问题地址：<a href="https://leetcode.cn/problems/he-wei-sde-liang-ge-shu-zi-lcof/">https://leetcode.cn/problems/he-wei-sde-liang-ge-shu-zi-lcof/</a></p>
<p>输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;
        vector&lt;int&gt; ans;
        int left &#x3D; 0 , right &#x3D; nums.size()-1;
        while(left&lt;right)
        &#123;
            if(nums[left] + nums[right] &lt; target) left++;
            else if(nums[left] + nums[right] &gt; target) right--;
            else
            &#123;
                ans.push_back(nums[left]);
                ans.push_back(nums[right]);
                break;
            &#125;
        &#125;
        return ans;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="1114-按序打印"><a href="#1114-按序打印" class="headerlink" title="1114. 按序打印"></a>1114. 按序打印</h3><p>问题地址：<a href="https://leetcode.cn/problems/print-in-order/">https://leetcode.cn/problems/print-in-order/</a></p>
<p>给你一个类：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">public class Foo &#123;
  public void first() &#123; print(&quot;first&quot;); &#125;
  public void second() &#123; print(&quot;second&quot;); &#125;
  public void third() &#123; print(&quot;third&quot;); &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>三个不同的线程 A、B、C 将会共用一个 <code>Foo</code> 实例。</p>
<ul>
<li>线程 A 将会调用 <code>first()</code> 方法</li>
<li>线程 B 将会调用 <code>second()</code> 方法</li>
<li>线程 C 将会调用 <code>third()</code> 方法</li>
</ul>
<p>请设计修改程序，以确保 <code>second()</code> 方法在 <code>first()</code> 方法之后被执行，<code>third()</code> 方法在 <code>second()</code> 方法之后被执行。</p>
<p>提示：</p>
<ul>
<li>尽管输入中的数字似乎暗示了顺序，但是我们并不保证线程在操作系统中的调度顺序。</li>
<li>你看到的输入格式主要是为了确保测试的全面性。</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Foo &#123;
    condition_variable cv;
    mutex mtx;
    int k &#x3D; 0;
public:
    void first(function&lt;void()&gt; printFirst) &#123;
        printFirst();
        k &#x3D; 1;
        cv.notify_all();    &#x2F;&#x2F; 通知其他所有在等待唤醒队列中的线程
    &#125;

    void second(function&lt;void()&gt; printSecond) &#123;
        unique_lock&lt;mutex&gt; lock(mtx);   &#x2F;&#x2F; lock mtx
        cv.wait(lock, [this]()&#123; return k &#x3D;&#x3D; 1; &#125;);  &#x2F;&#x2F; unlock mtx，并阻塞等待唤醒通知，需要满足 k &#x3D;&#x3D; 1 才能继续运行
        printSecond();
        k &#x3D; 2;
        cv.notify_one();    &#x2F;&#x2F; 随机通知一个（unspecified）在等待唤醒队列中的线程
    &#125;

    void third(function&lt;void()&gt; printThird) &#123;
        unique_lock&lt;mutex&gt; lock(mtx);   &#x2F;&#x2F; lock mtx
        cv.wait(lock, [this]()&#123; return k &#x3D;&#x3D; 2; &#125;);  &#x2F;&#x2F; unlock mtx，并阻塞等待唤醒通知，需要满足 k &#x3D;&#x3D; 2 才能继续运行
        printThird();
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="1629-按键持续时间最长的键"><a href="#1629-按键持续时间最长的键" class="headerlink" title="1629. 按键持续时间最长的键"></a>1629. 按键持续时间最长的键</h3><p>问题地址：<a href="https://leetcode.cn/problems/slowest-key/">https://leetcode.cn/problems/slowest-key/</a></p>
<p>LeetCode 设计了一款新式键盘，正在测试其可用性。测试人员将会点击一系列键（总计 <code>n</code> 个），每次一个。</p>
<p>给你一个长度为 <code>n</code> 的字符串 <code>keysPressed</code> ，其中 <code>keysPressed[i]</code> 表示测试序列中第 <code>i</code> 个被按下的键。<code>releaseTimes</code> 是一个升序排列的列表，其中 <code>releaseTimes[i]</code> 表示松开第 <code>i</code> 个键的时间。字符串和数组的 <code>下标都从 0 开始</code> 。第 <code>0</code> 个键在时间为 <code>0</code> 时被按下，接下来每个键都 <code>恰好</code> 在前一个键松开时被按下。</p>
<p>测试人员想要找出按键 <code>持续时间最长</code> 的键。第 <code>i</code> 次按键的持续时间为 <code>releaseTimes[i] - releaseTimes[i - 1]</code> ，第 <code>0</code> 次按键的持续时间为 <code>releaseTimes[0]</code> 。</p>
<p>注意，测试期间，同一个键可以在不同时刻被多次按下，而每次的持续时间都可能不同。</p>
<p>请返回单次按键 <code>持续时间最长</code> 的键，如果有多个这样的键，则返回 <code>按字母顺序排列最大</code> 的那个键。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    char slowestKey(vector&lt;int&gt;&amp; releaseTimes, string keysPressed) &#123;
        int n &#x3D; releaseTimes.size();
        char ans &#x3D; keysPressed[0];
        int maxTime &#x3D; releaseTimes[0];
        for (int i &#x3D; 1; i &lt; n; i++) &#123;
            char key &#x3D; keysPressed[i];
            int time &#x3D; releaseTimes[i] - releaseTimes[i - 1];
            if (time &gt; maxTime || (time &#x3D;&#x3D; maxTime &amp;&amp; key &gt; ans)) &#123;
                ans &#x3D; key;
                maxTime &#x3D; time;
            &#125;
        &#125;
        return ans;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="704-二分查找"><a href="#704-二分查找" class="headerlink" title="704. 二分查找"></a>704. 二分查找</h3><p>问题地址：<a href="https://leetcode.cn/problems/binary-search/">https://leetcode.cn/problems/binary-search/</a></p>
<p>给定一个 <code>n</code> 个元素有序的（升序）整型数组 <code>nums</code> 和一个目标值 <code>target</code>  ，写一个函数搜索 <code>nums</code> 中的 <code>target</code>，如果目标值存在返回下标，否则返回 <code>-1</code>。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int search(vector&lt;int&gt;&amp; nums, int target) &#123;
        int left &#x3D; 0, right &#x3D; nums.size() - 1;
        while(left &lt;&#x3D; right) &#123;
            int mid &#x3D; (right - left) &#x2F; 2 + left;
            int num &#x3D; nums[mid];
            if (num &#x3D;&#x3D; target) &#123;
                return mid;
            &#125; else if (num &gt; target) &#123;
                right &#x3D; mid - 1;
            &#125; else &#123;
                left &#x3D; mid + 1;
            &#125;
        &#125;
        return -1;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="2496-数组中字符串的最大值"><a href="#2496-数组中字符串的最大值" class="headerlink" title="2496. 数组中字符串的最大值"></a>2496. 数组中字符串的最大值</h3><p>问题地址：<a href="https://leetcode.cn/problems/maximum-value-of-a-string-in-an-array/">https://leetcode.cn/problems/maximum-value-of-a-string-in-an-array/</a></p>
<p>一个由字母和数字组成的字符串的 <code>值</code> 定义如下：</p>
<ul>
<li>如果字符串 <code>只</code> 包含数字，那么值为该字符串在 <code>10</code> 进制下的所表示的数字。</li>
<li>否则，值为字符串的 <code>长度</code> 。</li>
</ul>
<p>给你一个字符串数组 <code>strs</code> ，每个字符串都只由字母和数字组成，请你返回 <code>strs</code> 中字符串的 <code>最大值</code> 。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int maximumValue(vector&lt;string&gt;&amp; strs) &#123;
        int res &#x3D; 0;
        for (auto&amp; s : strs) &#123;
            bool isDigits &#x3D; true;
            for (auto&amp; c : s) &#123;
                isDigits &amp;&#x3D; isdigit(c);
            &#125;
            res &#x3D; max(res, isDigits ? stoi(s) : (int)s.size());
        &#125;
        return res;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="709-转换成小写字母"><a href="#709-转换成小写字母" class="headerlink" title="709. 转换成小写字母"></a>709. 转换成小写字母</h3><p>问题地址：<a href="https://leetcode.cn/problems/to-lower-case/">https://leetcode.cn/problems/to-lower-case/</a></p>
<p>给你一个字符串 <code>s</code> ，将该字符串中的大写字母转换成相同的小写字母，返回新的字符串。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    string toLowerCase(string s) &#123;
        for (char&amp; ch: s) &#123;
            ch &#x3D; tolower(ch);
        &#125;
        return s;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="747-至少是其他数字两倍的最大数"><a href="#747-至少是其他数字两倍的最大数" class="headerlink" title="747. 至少是其他数字两倍的最大数"></a>747. 至少是其他数字两倍的最大数</h3><p>问题地址：<a href="https://leetcode.cn/problems/largest-number-at-least-twice-of-others/">https://leetcode.cn/problems/largest-number-at-least-twice-of-others/</a></p>
<p>给你一个整数数组 <code>nums</code> ，其中总是存在 <code>唯一的</code> 一个最大整数 。</p>
<p>请你找出数组中的最大元素并检查它是否 <code>至少是数组中每个其他数字的两倍</code> 。如果是，则返回 <code>最大元素的下标</code> ，否则返回 <code>-1</code> 。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int dominantIndex(vector&lt;int&gt;&amp; nums) &#123;
        int m1 &#x3D; -1, m2 &#x3D; -1;
        int index &#x3D; -1;
        for (int i &#x3D; 0; i &lt; nums.size(); i++) &#123;
            if (nums[i] &gt; m1) &#123;
                m2 &#x3D; m1;
                m1 &#x3D; nums[i];
                index &#x3D; i;
            &#125; else if (nums[i] &gt; m2) &#123;
                m2 &#x3D; nums[i];
            &#125;
        &#125;
        return m1 &gt;&#x3D; m2 * 2 ? index : -1;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="面试题-16-15-珠玑妙算"><a href="#面试题-16-15-珠玑妙算" class="headerlink" title="面试题 16.15. 珠玑妙算"></a>面试题 16.15. 珠玑妙算</h3><p>问题地址：<a href="https://leetcode.cn/problems/master-mind-lcci/">https://leetcode.cn/problems/master-mind-lcci/</a></p>
<p>珠玑妙算游戏（the game of master mind）的玩法如下。</p>
<p>计算机有4个槽，每个槽放一个球，颜色可能是红色（R）、黄色（Y）、绿色（G）或蓝色（B）。例如，计算机可能有RGGB 4种（槽1为红色，槽2、3为绿色，槽4为蓝色）。作为用户，你试图猜出颜色组合。打个比方，你可能会猜YRGB。要是猜对某个槽的颜色，则算一次“猜中”；要是只猜对颜色但槽位猜错了，则算一次“伪猜中”。注意，“猜中”不能算入“伪猜中”。</p>
<p>给定一种颜色组合<code>solution</code>和一个猜测<code>guess</code>，编写一个方法，返回猜中和伪猜中的次数<code>answer</code>，其中<code>answer[0]</code>为猜中的次数，<code>answer[1]</code>为伪猜中的次数。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    vector&lt;int&gt; masterMind(string solution, string guess) &#123;
        int num1 &#x3D; 0, num2 &#x3D; 0;
        unordered_map&lt;char, int&gt; alpha_map;
        for (char ch : solution) &#123;
            alpha_map[ch]++;
        &#125;
        for (int i &#x3D; 0; i &lt; guess.size(); i++) &#123;
            if (solution[i] &#x3D;&#x3D; guess[i]) &#123;
                num1++;
            &#125;
            if (alpha_map[guess[i]]) &#123;
                alpha_map[guess[i]]--;
                num2++;
            &#125;
        &#125;
        return &#123;num1, num2 - num1&#125;;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="653-两数之和-IV-输入二叉搜索树"><a href="#653-两数之和-IV-输入二叉搜索树" class="headerlink" title="653. 两数之和 IV - 输入二叉搜索树"></a>653. 两数之和 IV - 输入二叉搜索树</h3><p>问题地址：<a href="https://leetcode.cn/problems/two-sum-iv-input-is-a-bst/">https://leetcode.cn/problems/two-sum-iv-input-is-a-bst/</a></p>
<p>给定一个二叉搜索树 root 和一个目标结果 k，如果二叉搜索树中存在两个元素且它们的和等于给定的目标结果，则返回 true。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;**
 * Definition for a binary tree node.
 * struct TreeNode &#123;
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;
 * &#125;;
 *&#x2F;
class Solution &#123;
public:
    unordered_set&lt;int&gt; hashTable;

    bool findTarget(TreeNode *root, int k) &#123;
        if (root &#x3D;&#x3D; nullptr) &#123;
            return false;
        &#125;
        if (hashTable.count(k - root-&gt;val)) &#123;
            return true;
        &#125;
        hashTable.insert(root-&gt;val);
        return findTarget(root-&gt;left, k) || findTarget(root-&gt;right, k);
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="1413-逐步求和得到正数的最小值"><a href="#1413-逐步求和得到正数的最小值" class="headerlink" title="1413. 逐步求和得到正数的最小值"></a>1413. 逐步求和得到正数的最小值</h3><p>问题地址：<a href="https://leetcode.cn/problems/minimum-value-to-get-positive-step-by-step-sum/">https://leetcode.cn/problems/minimum-value-to-get-positive-step-by-step-sum/</a></p>
<p>给你一个整数数组 <code>nums</code> 。你可以选定任意的 正数 <code>startValue</code> 作为初始值。</p>
<p>你需要从左到右遍历 <code>nums</code> 数组，并将 <code>startValue</code> 依次累加上 <code>nums</code> 数组中的值。</p>
<p>请你在确保累加和始终大于等于 1 的前提下，选出一个最小的 <code>正数</code> 作为 <code>startValue</code> 。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int minStartValue(vector&lt;int&gt;&amp; nums) &#123;
        int accSum &#x3D; 0, accSumMin &#x3D; 0;
        for (int num : nums) &#123;
            accSum +&#x3D; num;
            accSumMin &#x3D; min(accSumMin, accSum);
        &#125;
        return -accSumMin + 1;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="1608-特殊数组的特征值"><a href="#1608-特殊数组的特征值" class="headerlink" title="1608. 特殊数组的特征值"></a>1608. 特殊数组的特征值</h3><p>问题地址：<a href="https://leetcode.cn/problems/special-array-with-x-elements-greater-than-or-equal-x/">https://leetcode.cn/problems/special-array-with-x-elements-greater-than-or-equal-x/</a></p>
<p>给你一个非负整数数组 <code>nums</code> 。如果存在一个数 <code>x</code> ，使得 <code>nums</code> 中恰好有 <code>x</code> 个元素 大于或者等于 <code>x</code> ，那么就称 <code>nums</code> 是一个 特殊数组 ，而 <code>x</code> 是该数组的 特征值 。</p>
<p>注意： <code>x</code> 不必 是 <code>nums</code> 的中的元素。</p>
<p>如果数组 <code>nums</code> 是一个 特殊数组 ，请返回它的特征值 <code>x</code> 。否则，返回 <code>-1</code> 。可以证明的是，如果 <code>nums</code> 是特殊数组，那么其特征值 <code>x</code> 是 唯一的 。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int specialArray(vector&lt;int&gt;&amp; nums) &#123;
        sort(nums.begin(), nums.end(), greater&lt;int&gt;());
        int n &#x3D; nums.size();
        for (int i &#x3D; 1; i &lt;&#x3D; n; ++i) &#123;
            if (nums[i - 1] &gt;&#x3D; i &amp;&amp; (i &#x3D;&#x3D; n || nums[i] &lt; i)) &#123;
                return i;
            &#125;
        &#125;
        return -1;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="LCP-17-速算机器人"><a href="#LCP-17-速算机器人" class="headerlink" title="LCP 17. 速算机器人"></a>LCP 17. 速算机器人</h3><p>问题地址：<a href="https://leetcode.cn/problems/nGK0Fy/">https://leetcode.cn/problems/nGK0Fy/</a></p>
<p>小扣在秋日市集发现了一款速算机器人。店家对机器人说出两个数字（记作 x 和 y），请小扣说出计算指令：</p>
<ul>
<li>“A” 运算：使 x &#x3D; 2 * x + y；</li>
<li>“B” 运算：使 y &#x3D; 2 * y + x。</li>
</ul>
<p>在本次游戏中，店家说出的数字为 x &#x3D; 1 和 y &#x3D; 0，小扣说出的计算指令记作仅由大写字母 A、B 组成的字符串 s，字符串中字符的顺序表示计算顺序，请返回最终 x 与 y 的和为多少。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int funa(int x, int y) &#123;
        return 2 * x + y;
    &#125;
    int funb(int x, int y) &#123;
        return 2 * y + x;
    &#125;
    int calculate(string s) &#123;
        int x &#x3D; 1;
        int y &#x3D; 0;
        for (char c : s) &#123;
            if (c &#x3D;&#x3D; &#39;A&#39;) &#123;
                x &#x3D; funa(x, y);
            &#125; else &#123;
                y &#x3D; funb(x, y);
            &#125;
        &#125;
        return x + y;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="1502-判断能否形成等差数列"><a href="#1502-判断能否形成等差数列" class="headerlink" title="1502. 判断能否形成等差数列"></a>1502. 判断能否形成等差数列</h3><p>问题地址：<a href="https://leetcode.cn/problems/can-make-arithmetic-progression-from-sequence/">https://leetcode.cn/problems/can-make-arithmetic-progression-from-sequence/</a></p>
<p>给你一个数字数组 <code>arr</code> 。</p>
<p>如果一个数列中，任意相邻两项的差总等于同一个常数，那么这个数列就称为 <code>等差数列</code> 。</p>
<p>如果可以重新排列数组形成等差数列，请返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    bool canMakeArithmeticProgression(vector&lt;int&gt;&amp; arr) &#123;
        sort(arr.begin(), arr.end());
        for (int i &#x3D; 1; i &lt; arr.size() - 1; ++i) &#123;
            if (arr[i] * 2 !&#x3D; arr[i - 1] + arr[i + 1]) &#123;
                return false;
            &#125;
        &#125;
        return true;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="1013-将数组分成和相等的三个部分"><a href="#1013-将数组分成和相等的三个部分" class="headerlink" title="1013. 将数组分成和相等的三个部分"></a>1013. 将数组分成和相等的三个部分</h3><p>问题地址：<a href="https://leetcode.cn/problems/partition-array-into-three-parts-with-equal-sum/">https://leetcode.cn/problems/partition-array-into-three-parts-with-equal-sum/</a></p>
<p>给你一个整数数组 arr，只有可以将其划分为三个和相等的 非空 部分时才返回 true，否则返回 false。</p>
<p>形式上，如果可以找出索引 <code>i + 1 &lt; j</code> 且满足 <code>(arr[0] + arr[1] + ... + arr[i] == arr[i + 1] + arr[i + 2] + ... + arr[j - 1] == arr[j] + arr[j + 1] + ... + arr[arr.length - 1])</code> 就可以将数组三等分。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    bool canThreePartsEqualSum(vector&lt;int&gt;&amp; arr) &#123;
        int s &#x3D; accumulate(arr.begin(), arr.end(), 0);
        if (s % 3 !&#x3D; 0) &#123;
            return false;
        &#125;
        int target &#x3D; s &#x2F; 3;
        int n &#x3D; arr.size(), i &#x3D; 0, cur &#x3D; 0;
        while (i &lt; n) &#123;
            cur +&#x3D; arr[i];
            if (cur &#x3D;&#x3D; target) &#123;
                break;
            &#125;
            ++i;
        &#125;
        if (cur !&#x3D; target) &#123;
            return false;
        &#125;
        int j &#x3D; i + 1;
        while (j + 1 &lt; n) &#123; &#x2F;&#x2F; 需要满足最后一个数组元素非空
            cur +&#x3D; arr[j];
            if (cur &#x3D;&#x3D; target * 2) &#123;
                return true;
            &#125;
            ++j;
        &#125;
        return false;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="面试题-03-01-三合一"><a href="#面试题-03-01-三合一" class="headerlink" title="面试题 03.01. 三合一"></a>面试题 03.01. 三合一</h3><p>问题地址：<a href="https://leetcode.cn/problems/three-in-one-lcci/">https://leetcode.cn/problems/three-in-one-lcci/</a></p>
<p>三合一。描述如何只用一个数组来实现三个栈。</p>
<p>你应该实现push(stackNum, value)、pop(stackNum)、isEmpty(stackNum)、peek(stackNum)方法。stackNum表示栈下标，value表示压入的值。</p>
<p>构造函数会传入一个stackSize参数，代表每个栈的大小。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class TripleInOne &#123;
public:
    TripleInOne(int stackSize) &#123;
        this-&gt;stackSize &#x3D; stackSize;
        arr.resize(3 * stackSize);
        ptrs.resize(3);
        ptrs[0] &#x3D; 0;
        ptrs[1] &#x3D; stackSize;
        ptrs[2] &#x3D; stackSize * 2;
    &#125;
    
    void push(int stackNum, int value) &#123;
        if (ptrs[stackNum] &lt; (stackNum + 1) * stackSize) &#123;
            arr[ptrs[stackNum]] &#x3D; value;
            ptrs[stackNum]++;
        &#125;
    &#125;
    
    int pop(int stackNum) &#123;
        if (isEmpty(stackNum)) return -1;
        ptrs[stackNum]--;
        return arr[ptrs[stackNum]];
    &#125;
    
    int peek(int stackNum) &#123;
        if (isEmpty(stackNum)) return -1;
        return arr[ptrs[stackNum] - 1];
    &#125;
    
    bool isEmpty(int stackNum) &#123;
        return ptrs[stackNum] &#x3D;&#x3D; stackSize * stackNum;
    &#125;

private:
    vector&lt;int&gt; arr;
    vector&lt;int&gt; ptrs;
    int stackSize;
&#125;;

&#x2F;**
 * Your TripleInOne object will be instantiated and called as such:
 * TripleInOne* obj &#x3D; new TripleInOne(stackSize);
 * obj-&gt;push(stackNum,value);
 * int param_2 &#x3D; obj-&gt;pop(stackNum);
 * int param_3 &#x3D; obj-&gt;peek(stackNum);
 * bool param_4 &#x3D; obj-&gt;isEmpty(stackNum);
 *&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="LCR-023-相交链表"><a href="#LCR-023-相交链表" class="headerlink" title="LCR 023. 相交链表"></a>LCR 023. 相交链表</h3><p>问题地址：<a href="https://leetcode.cn/problems/3u1WK4/">https://leetcode.cn/problems/3u1WK4/</a></p>
<p>给定两个单链表的头节点 headA 和 headB ，请找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。</p>
<p>题目数据 保证 整个链式结构中不存在环。</p>
<p>注意，函数返回结果后，链表必须 保持其原始结构 。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;**
 * Definition for singly-linked list.
 * struct ListNode &#123;
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) &#123;&#125;
 * &#125;;
 *&#x2F;
class Solution &#123;
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123;
        unordered_set&lt;ListNode *&gt; visited;
        ListNode * temp &#x3D; headA;
        while (temp !&#x3D; nullptr) &#123;
            visited.insert(temp);
            temp &#x3D; temp-&gt;next;
        &#125;
        temp &#x3D; headB;
        while (temp !&#x3D; nullptr) &#123;
            if (visited.count(temp)) &#123;
                return temp;
            &#125;
            temp &#x3D; temp-&gt;next;
        &#125;
        return nullptr;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="1544-整理字符串"><a href="#1544-整理字符串" class="headerlink" title="1544. 整理字符串"></a>1544. 整理字符串</h3><p>问题地址：<a href="https://leetcode.cn/problems/make-the-string-great/">https://leetcode.cn/problems/make-the-string-great/</a></p>
<p>给你一个由大小写英文字母组成的字符串 <code>s</code> 。</p>
<p>一个整理好的字符串中，两个相邻字符 <code>s[i]</code> 和 <code>s[i+1]</code>，其中 <code>0&lt;= i &lt;= s.length-2</code> ，要满足如下条件:</p>
<ul>
<li>若 <code>s[i]</code> 是小写字符，则 <code>s[i+1]</code> 不可以是相同的大写字符。</li>
<li>若 <code>s[i]</code> 是大写字符，则 <code>s[i+1]</code> 不可以是相同的小写字符。</li>
</ul>
<p>请你将字符串整理好，每次你都可以从字符串中选出满足上述条件的 <code>两个相邻</code> 字符并删除，直到字符串整理好为止。</p>
<p>请返回整理好的 <code>字符串</code> 。题目保证在给出的约束条件下，测试样例对应的答案是唯一的。</p>
<p>注意：空字符串也属于整理好的字符串，尽管其中没有任何字符。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    string makeGood(string s) &#123;
        string ret;
        for (char ch : s) &#123;
            if (!ret.empty() &amp;&amp; tolower(ret.back()) &#x3D;&#x3D; tolower(ch) &amp;&amp; ret.back() !&#x3D; ch) &#123;
                ret.pop_back();
            &#125; else &#123;
                ret.push_back(ch);
            &#125;
        &#125;
        return ret;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="9-回文数"><a href="#9-回文数" class="headerlink" title="9. 回文数"></a>9. 回文数</h3><p>问题地址：<a href="https://leetcode.cn/problems/palindrome-number/">https://leetcode.cn/problems/palindrome-number/</a></p>
<p>给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。</p>
<p>回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p>
<ul>
<li>例如，121 是回文，而 123 不是。</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    bool isPalindrome(int x) &#123;
        if (x &lt; 0 || (x % 10 &#x3D;&#x3D; 0 &amp;&amp; x !&#x3D; 0)) &#123;
            return false;
        &#125;

        int revertedNumber &#x3D; 0;
        while (x &gt; revertedNumber) &#123;
            revertedNumber &#x3D; revertedNumber * 10 + x % 10;
            x &#x2F;&#x3D; 10;
        &#125;
        return x &#x3D;&#x3D; revertedNumber || x &#x3D;&#x3D; revertedNumber &#x2F; 10;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="14-最长公共前缀"><a href="#14-最长公共前缀" class="headerlink" title="14. 最长公共前缀"></a>14. 最长公共前缀</h3><p>问题地址：<a href="https://leetcode.cn/problems/longest-common-prefix/">https://leetcode.cn/problems/longest-common-prefix/</a></p>
<p>编写一个函数来查找字符串数组中的最长公共前缀。</p>
<p>如果不存在公共前缀，返回空字符串 “”。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    string longestCommonPrefix(vector&lt;string&gt;&amp; strs) &#123;
        if (!strs.size()) &#123;
            return &quot;&quot;;
        &#125;
        int length &#x3D; strs[0].size();
        int count &#x3D; strs.size();
        for (int i &#x3D; 0; i &lt; length; i++) &#123;
            char c &#x3D; strs[0][i];
            for (int j &#x3D; 1; j &lt; count; ++j) &#123;
                if (i &#x3D;&#x3D; strs[j].size() || strs[j][i] !&#x3D; c) &#123;
                    return strs[0].substr(0, i);
                &#125;
            &#125;
        &#125;
        return strs[0];
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="2490-回环句"><a href="#2490-回环句" class="headerlink" title="2490. 回环句"></a>2490. 回环句</h3><p>问题地址：<a href="https://leetcode.cn/problems/circular-sentence/">https://leetcode.cn/problems/circular-sentence/</a></p>
<p>句子 是由单个空格分隔的一组单词，且不含前导或尾随空格。</p>
<ul>
<li>例如，”Hello World”、”HELLO”、”hello world hello world” 都是符合要求的句子。</li>
</ul>
<p>单词 仅 由大写和小写英文字母组成。且大写和小写字母会视作不同字符。</p>
<p>如果句子满足下述全部条件，则认为它是一个 回环句 ：</p>
<ul>
<li>单词的最后一个字符和下一个单词的第一个字符相等。</li>
<li>最后一个单词的最后一个字符和第一个单词的第一个字符相等。</li>
</ul>
<p>例如，”leetcode exercises sound delightful”、”eetcode”、”leetcode eats soul” 都是回环句。然而，”Leetcode is cool”、”happy Leetcode”、”Leetcode” 和 “I like Leetcode” 都 不 是回环句。</p>
<p>给你一个字符串 sentence ，请你判断它是不是一个回环句。如果是，返回 true ；否则，返回 false 。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    bool isCircularSentence(string sentence) &#123;
        if (sentence.back() !&#x3D; sentence.front()) &#123;
            return false;
        &#125;
        for (int i &#x3D; 0; i &lt; sentence.size(); i++) &#123;
            if (sentence[i] &#x3D;&#x3D; &#39; &#39; &amp;&amp; sentence[i + 1] !&#x3D; sentence[i - 1]) &#123;
                return false;
            &#125;
        &#125;
        return true;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a>20. 有效的括号</h3><p>问题地址：<a href="https://leetcode.cn/problems/valid-parentheses/">https://leetcode.cn/problems/valid-parentheses/</a></p>
<p>给定一个只包括 <code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;&#123;&#39;</code>，<code>&#39;&#125;&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code> 的字符串 s ，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<ol>
<li>左括号必须用相同类型的右括号闭合。</li>
<li>左括号必须以正确的顺序闭合。</li>
<li>每个右括号都有一个对应的相同类型的左括号。</li>
</ol>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    bool isValid(string s) &#123;
        int n &#x3D; s.size();
        if (n % 2 &#x3D;&#x3D; 1) &#123;
            return false;
        &#125;

        unordered_map&lt;char, char&gt; pairs &#x3D; &#123;
            &#123;&#39;)&#39;, &#39;(&#39;&#125;,
            &#123;&#39;]&#39;, &#39;[&#39;&#125;,
            &#123;&#39;&#125;&#39;, &#39;&#123;&#39;&#125;
        &#125;;

        stack&lt;char&gt; stk;
        for (char ch : s) &#123;
            if (pairs.count(ch)) &#123;
                if (stk.empty() || stk.top() !&#x3D; pairs[ch]) &#123;
                    return false;
                &#125;
                stk.pop();
            &#125; else &#123;
                stk.push(ch);
            &#125;
        &#125;
        return stk.empty();
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27. 移除元素"></a>27. 移除元素</h3><p>问题地址：<a href="https://leetcode.cn/problems/remove-element/">https://leetcode.cn/problems/remove-element/</a></p>
<p>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。</p>
<p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123;
        int n &#x3D; nums.size();
        int left &#x3D; 0;
        for (int right &#x3D; 0; right &lt; n; right++) &#123;
            if (nums[right] !&#x3D; val) &#123;
                nums[left] &#x3D; nums[right];
                left++;
            &#125;
        &#125;
        return left;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="13-罗马数字转整数"><a href="#13-罗马数字转整数" class="headerlink" title="13. 罗马数字转整数"></a>13. 罗马数字转整数</h3><p>问题地址：<a href="https://leetcode.cn/problems/roman-to-integer/">https://leetcode.cn/problems/roman-to-integer/</a></p>
<p>罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。</p>
<pre class="line-numbers language-none"><code class="language-none">字符          数值
I             1
V             5
X             10
L             50
C             100
D             500
M             1000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>例如， 罗马数字 2 写做 II ，即为两个并列的 1 。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</p>
<p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p>
<ul>
<li>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。</li>
<li>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 </li>
<li>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。</li>
</ul>
<p>给定一个罗马数字，将其转换成整数。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
private:
    unordered_map&lt;char, int&gt; symbolValues &#x3D; &#123;
        &#123;&#39;I&#39;, 1&#125;,
        &#123;&#39;V&#39;, 5&#125;,
        &#123;&#39;X&#39;, 10&#125;,
        &#123;&#39;L&#39;, 50&#125;,
        &#123;&#39;C&#39;, 100&#125;,
        &#123;&#39;D&#39;, 500&#125;,
        &#123;&#39;M&#39;, 1000&#125;,
    &#125;;
public:
    int romanToInt(string s) &#123;
        int ans &#x3D; 0;
        int n &#x3D; s.length();
        for (int i &#x3D; 0; i &lt; n; ++i) &#123;
            int value &#x3D; symbolValues[s[i]];
            if (i &lt; n - 1 &amp;&amp; value &lt; symbolValues[s[i + 1]]) &#123;
                ans -&#x3D; value;
            &#125; else &#123;
                ans +&#x3D; value;
            &#125;
        &#125;
        return ans;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21. 合并两个有序链表"></a>21. 合并两个有序链表</h3><p>问题地址：<a href="https://leetcode.cn/problems/merge-two-sorted-lists/">https://leetcode.cn/problems/merge-two-sorted-lists/</a></p>
<p>将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;**
 * Definition for singly-linked list.
 * struct ListNode &#123;
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) &#123;&#125;
 *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;
 *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;
 * &#125;;
 *&#x2F;
class Solution &#123;
public:
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) &#123;
        ListNode * preHead &#x3D; new ListNode(-1);
        ListNode * prev &#x3D; preHead;
        while (list1 !&#x3D; nullptr &amp;&amp; list2 !&#x3D; nullptr) &#123;
            if (list1-&gt;val &lt; list2-&gt;val) &#123;
                prev-&gt;next &#x3D; list1;
                list1 &#x3D; list1-&gt;next;
            &#125; else &#123;
                prev-&gt;next &#x3D; list2;
                list2 &#x3D; list2-&gt;next;
            &#125;
            prev &#x3D; prev-&gt;next;
        &#125;
        prev-&gt;next &#x3D; list1 &#x3D;&#x3D; nullptr ? list2 : list1;
        return preHead-&gt;next;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a>1. 两数之和</h3><p>问题地址：<a href="https://leetcode.cn/problems/two-sum/">https://leetcode.cn/problems/two-sum/</a></p>
<p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p>
<p>你可以按任意顺序返回答案。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;
        auto n &#x3D; nums.size();
        for (int i &#x3D; 0; i &lt; n; i++) &#123;
            for (int j &#x3D; i + 1; j &lt; n; j++) &#123;
                if (nums[i] + nums[j] &#x3D;&#x3D; target) &#123;
                    return &#123;i, j&#125;;
                &#125;
            &#125;
        &#125;
        return &#123;&#125;;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="144-二叉树的前序遍历"><a href="#144-二叉树的前序遍历" class="headerlink" title="144. 二叉树的前序遍历"></a>144. 二叉树的前序遍历</h3><p>问题地址：<a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/">https://leetcode.cn/problems/binary-tree-preorder-traversal/</a></p>
<p>给你二叉树的根节点 root ，返回它节点值的 前序 遍历。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;**
 * Definition for a binary tree node.
 * struct TreeNode &#123;
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;
 * &#125;;
 *&#x2F;
class Solution &#123;
public:
    void preorder(TreeNode * root, vector&lt;int&gt; &amp;res) &#123;
        if (root &#x3D;&#x3D; nullptr) &#123;
            return;
        &#125;
        res.push_back(root-&gt;val);
        preorder(root-&gt;left, res);
        preorder(root-&gt;right, res);
    &#125;
    vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123;
        vector&lt;int&gt; res;
        preorder(root, res);
        return res;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="26-删除有序数组中的重复项"><a href="#26-删除有序数组中的重复项" class="headerlink" title="26. 删除有序数组中的重复项"></a>26. 删除有序数组中的重复项</h3><p>问题地址：<a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/">https://leetcode.cn/problems/remove-duplicates-from-sorted-array/</a></p>
<p>给你一个 非严格递增排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。然后返回 nums 中唯一元素的个数。</p>
<p>考虑 nums 的唯一元素的数量为 k ，你需要做以下事情确保你的题解可以被通过：</p>
<ul>
<li>更改数组 nums ，使 nums 的前 k 个元素包含唯一元素，并按照它们最初在 nums 中出现的顺序排列。nums 的其余元素与 nums 的大小不重要。</li>
<li>返回 k 。</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123;
        int n &#x3D; nums.size();
        if (n &#x3D;&#x3D; 0) &#123;
            return 0;
        &#125;
        int fast &#x3D; 1, slow &#x3D; 1;
        while (fast &lt; n) &#123;
            if (nums[fast] !&#x3D; nums[fast - 1]) &#123;
                nums[slow] &#x3D; nums[fast];
                ++slow;
            &#125;
            ++fast;
        &#125;
        return slow;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="2760-最长奇偶子数组"><a href="#2760-最长奇偶子数组" class="headerlink" title="2760. 最长奇偶子数组"></a>2760. 最长奇偶子数组</h3><p>问题地址：<a href="https://leetcode.cn/problems/longest-even-odd-subarray-with-threshold/">https://leetcode.cn/problems/longest-even-odd-subarray-with-threshold/</a></p>
<p>给你一个下标从 0 开始的整数数组 nums 和一个整数 threshold 。</p>
<p>请你从 nums 的子数组中找出以下标 l 开头、下标 r 结尾 (0 &lt;&#x3D; l &lt;&#x3D; r &lt; nums.length) 且满足以下条件的 最长子数组 ：</p>
<p>nums[l] % 2 &#x3D;&#x3D; 0<br>对于范围 [l, r - 1] 内的所有下标 i ，nums[i] % 2 !&#x3D; nums[i + 1] % 2<br>对于范围 [l, r] 内的所有下标 i ，nums[i] &lt;&#x3D; threshold<br>以整数形式返回满足题目要求的最长子数组的长度。</p>
<p>注意：子数组 是数组中的一个连续非空元素序列。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int longestAlternatingSubarray(vector&lt;int&gt;&amp; nums, int threshold) &#123;
        int ans &#x3D; 0;
        for (int i &#x3D; 0; i &lt; nums.size(); ++i) &#123;
            if (nums[i] % 2 !&#x3D; 0) continue;
            int len1 &#x3D; 1;
            for (int j &#x3D; i; j &lt; nums.size() - 1; ++j) &#123;
                if (nums[j] % 2 &#x3D;&#x3D; nums[j + 1] % 2) break;
                else ++len1;
            &#125;
            int len2 &#x3D; 0;
            for (int j &#x3D; i; j &lt; nums.size(); ++j) &#123;
                if (nums[j] &gt; threshold) break;
                else ++len2;
            &#125;
            ans &#x3D; max(ans, min(len1, len2));
        &#125;
        return ans;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="28-找出字符串中第一个匹配项的下标"><a href="#28-找出字符串中第一个匹配项的下标" class="headerlink" title="28. 找出字符串中第一个匹配项的下标"></a>28. 找出字符串中第一个匹配项的下标</h3><p>问题地址：<a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/">https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/</a></p>
<p>给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串的第一个匹配项的下标（下标从 0 开始）。如果 needle 不是 haystack 的一部分，则返回  -1 。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int strStr(string haystack, string needle) &#123;
        int n &#x3D; haystack.size(), m &#x3D; needle.size();
        for (int i &#x3D; 0; i &lt;&#x3D; n - m; i++) &#123;
            int j &#x3D; i, k &#x3D; 0;
            while (k &lt; m and haystack[j] &#x3D;&#x3D; needle[k]) &#123;
                j++;
                k++;
            &#125;
            if (k &#x3D;&#x3D; m) return i;
        &#125;
        return -1;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="35-搜索插入位置"><a href="#35-搜索插入位置" class="headerlink" title="35. 搜索插入位置"></a>35. 搜索插入位置</h3><p>问题地址：<a href="https://leetcode.cn/problems/search-insert-position/">https://leetcode.cn/problems/search-insert-position/</a></p>
<p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p>
<p>请必须使用时间复杂度为 O(log n) 的算法。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123;
        int n &#x3D; nums.size();
        int left &#x3D; 0, right &#x3D; n -1, ans &#x3D; n;
        while (left &lt;&#x3D; right) &#123;
            int mid &#x3D; ((right - left) &gt;&gt; 1) + left;
            if (target &lt;&#x3D; nums[mid]) &#123;
                ans &#x3D; mid;
                right &#x3D; mid - 1;
            &#125; else &#123;
                left &#x3D; mid + 1;
            &#125;
        &#125;
        return ans;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="58-最后一个单词的长度"><a href="#58-最后一个单词的长度" class="headerlink" title="58. 最后一个单词的长度"></a>58. 最后一个单词的长度</h3><p>问题地址：<a href="https://leetcode.cn/problems/length-of-last-word/">https://leetcode.cn/problems/length-of-last-word/</a></p>
<p>给你一个字符串 s，由若干单词组成，单词前后用一些空格字符隔开。返回字符串中 最后一个 单词的长度。</p>
<p>单词 是指仅由字母组成、不包含任何空格字符的最大子字符串。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int lengthOfLastWord(string s) &#123;
        int index &#x3D; s.size() - 1;
        while (s[index] &#x3D;&#x3D; &#39; &#39;) &#123;
            index--;
        &#125;
        int wordLength &#x3D; 0;
        while (index &gt;&#x3D; 0 &amp;&amp; s[index] !&#x3D; &#39; &#39;) &#123;
            wordLength++;
            index--;
        &#125;
        return wordLength;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="2600-K-件物品的最大和"><a href="#2600-K-件物品的最大和" class="headerlink" title="2600. K 件物品的最大和"></a>2600. K 件物品的最大和</h3><p>问题地址：<a href="https://leetcode.cn/problems/k-items-with-the-maximum-sum/">https://leetcode.cn/problems/k-items-with-the-maximum-sum/</a></p>
<p>袋子中装有一些物品，每个物品上都标记着数字 1 、0 或 -1 。</p>
<p>给你四个非负整数 numOnes 、numZeros 、numNegOnes 和 k 。</p>
<p>袋子最初包含：</p>
<ul>
<li>numOnes 件标记为 1 的物品。</li>
<li>numZeros 件标记为 0 的物品。</li>
<li>numNegOnes 件标记为 -1 的物品。</li>
</ul>
<p>现计划从这些物品中恰好选出 k 件物品。返回所有可行方案中，物品上所标记数字之和的最大值。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) &#123;
        if (k &lt;&#x3D; numOnes) &#123;
            return k;
        &#125; else if (k &lt;&#x3D; numOnes + numZeros) &#123;
            return numOnes;
        &#125; else &#123;
            return numOnes - (k - numOnes - numZeros);
        &#125;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="66-加一"><a href="#66-加一" class="headerlink" title="66. 加一"></a>66. 加一</h3><p>问题地址：<a href="https://leetcode.cn/problems/plus-one/">https://leetcode.cn/problems/plus-one/</a></p>
<p>给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。</p>
<p>最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。</p>
<p>你可以假设除了整数 0 之外，这个整数不会以零开头。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    vector&lt;int&gt; plusOne(vector&lt;int&gt;&amp; digits) &#123;
        int n &#x3D; digits.size();
        for (int i &#x3D; n - 1; i &gt;&#x3D; 0; --i) &#123;
            if (digits[i] !&#x3D; 9) &#123;
                ++digits[i];
                for (int j &#x3D; i + 1; j &lt; n; ++j) &#123;
                    digits[j] &#x3D; 0;
                &#125;
                return digits;
            &#125;
        &#125;

        vector&lt;int&gt; ans(n + 1);
        ans[0] &#x3D; 1;
        return ans;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="67-二进制求和"><a href="#67-二进制求和" class="headerlink" title="67. 二进制求和"></a>67. 二进制求和</h3><p>问题地址：<a href="https://leetcode.cn/problems/add-binary/">https://leetcode.cn/problems/add-binary/</a></p>
<p>给你两个二进制字符串 a 和 b ，以二进制字符串的形式返回它们的和。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    string addBinary(string a, string b) &#123;
        string ans;
        reverse(a.begin(), a.end());
        reverse(b.begin(), b.end());
        int n &#x3D; max(a.size(), b.size()), carry &#x3D; 0;
        for (size_t i &#x3D; 0; i &lt; n; ++i) &#123;
            carry +&#x3D; i &lt; a.size() ? (a.at(i) &#x3D;&#x3D; &#39;1&#39;) : 0;
            carry +&#x3D; i &lt; b.size() ? (b.at(i) &#x3D;&#x3D; &#39;1&#39;) : 0;
            ans.push_back((carry % 2) ? &#39;1&#39; : &#39;0&#39;);
            carry &#x2F;&#x3D; 2;
        &#125;
        if (carry) &#123;
            ans.push_back(&#39;1&#39;);
        &#125;
        reverse(ans.begin(), ans.end());
        return ans;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="69-x-的平方根"><a href="#69-x-的平方根" class="headerlink" title="69. x 的平方根"></a>69. x 的平方根</h3><p>问题地址：<a href="https://leetcode.cn/problems/sqrtx/">https://leetcode.cn/problems/sqrtx/</a></p>
<p>给你一个非负整数 x ，计算并返回 x 的 算术平方根 。</p>
<p>由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 。</p>
<p>注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 <code>x ** 0.5</code> 。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int mySqrt(int x) &#123;
        if (x &#x3D;&#x3D; 0) &#123;
            return 0;
        &#125;
        int ans &#x3D; exp(0.5 * log(x));
        return ((long long)(ans + 1) * (ans + 1) &lt;&#x3D; x ? ans + 1 : ans);
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a>70. 爬楼梯</h3><p>问题地址：<a href="https://leetcode.cn/problems/climbing-stairs/">https://leetcode.cn/problems/climbing-stairs/</a></p>
<p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p>
<p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int climbStairs(int n) &#123;
        int p &#x3D; 0, q &#x3D; 0, r &#x3D; 1;
        for (int i &#x3D; 1; i &lt;&#x3D; n; ++i) &#123;
            p &#x3D; q;
            q &#x3D; r;
            r &#x3D; p + q;
        &#125;
        return r;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="83-删除排序链表中的重复元素"><a href="#83-删除排序链表中的重复元素" class="headerlink" title="83. 删除排序链表中的重复元素"></a>83. 删除排序链表中的重复元素</h3><p>问题地址：<a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list/">https://leetcode.cn/problems/remove-duplicates-from-sorted-list/</a></p>
<p>给定一个已排序的链表的头 head ， 删除所有重复的元素，使每个元素只出现一次 。返回 已排序的链表 。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;**
 * Definition for singly-linked list.
 * struct ListNode &#123;
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) &#123;&#125;
 *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;
 *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;
 * &#125;;
 *&#x2F;
class Solution &#123;
public:
    ListNode* deleteDuplicates(ListNode* head) &#123;
        if (!head) &#123;
            return head;
        &#125;
        ListNode * cur &#x3D; head;
        while (cur-&gt;next) &#123;
            if (cur-&gt;val &#x3D;&#x3D; cur-&gt;next-&gt;val) &#123;
                cur-&gt;next &#x3D; cur-&gt;next-&gt;next;
            &#125; else &#123;
                cur &#x3D; cur-&gt;next;
            &#125;
        &#125;
        return head;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="88-合并两个有序数组"><a href="#88-合并两个有序数组" class="headerlink" title="88. 合并两个有序数组"></a>88. 合并两个有序数组</h3><p>问题地址：<a href="https://leetcode.cn/problems/merge-sorted-array/">https://leetcode.cn/problems/merge-sorted-array/</a></p>
<p>给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。</p>
<p>请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。</p>
<p>注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) &#123;
        int i &#x3D; nums1.size() - 1;
        m--;
        n--;
        while (n &gt;&#x3D; 0) &#123;
            while (m &gt;&#x3D; 0 &amp;&amp; nums1[m] &gt; nums2[n]) &#123;
                swap(nums1[i--], nums1[m--]);
            &#125;
            swap(nums1[i--], nums2[n--]);
        &#125;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94. 二叉树的中序遍历"></a>94. 二叉树的中序遍历</h3><p>问题地址：<a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">https://leetcode.cn/problems/binary-tree-inorder-traversal/</a></p>
<p>给定一个二叉树的根节点 root ，返回 它的 中序 遍历 。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;**
 * Definition for a binary tree node.
 * struct TreeNode &#123;
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;
 * &#125;;
 *&#x2F;
class Solution &#123;
public:
    vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;
        vector&lt;int&gt; res;
        inorder(root, res);
        return res;
    &#125;
    void inorder(TreeNode* root, vector&lt;int&gt;&amp; res) &#123;
        if (!root) &#123;
            return;
        &#125;
        inorder(root-&gt;left, res);
        res.push_back(root-&gt;val);
        inorder(root-&gt;right, res);
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="100-相同的树"><a href="#100-相同的树" class="headerlink" title="100. 相同的树"></a>100. 相同的树</h3><p>问题地址：<a href="https://leetcode.cn/problems/same-tree/">https://leetcode.cn/problems/same-tree/</a></p>
<p>给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。</p>
<p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;**
 * Definition for a binary tree node.
 * struct TreeNode &#123;
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;
 * &#125;;
 *&#x2F;
class Solution &#123;
public:
    bool isSameTree(TreeNode* p, TreeNode* q) &#123;
        if (p &#x3D;&#x3D; nullptr &amp;&amp; q &#x3D;&#x3D; nullptr) &#123;
            return true;
        &#125; else if (p &#x3D;&#x3D; nullptr || q &#x3D;&#x3D; nullptr) &#123;
            return false;
        &#125; else if (p-&gt;val !&#x3D; q-&gt;val) &#123;
            return false;
        &#125; else &#123;
            return isSameTree(p-&gt;left, q-&gt;left) &amp;&amp; isSameTree(p-&gt;right, q-&gt;right);
        &#125;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101. 对称二叉树"></a>101. 对称二叉树</h3><p>问题地址：<a href="https://leetcode.cn/problems/symmetric-tree/">https://leetcode.cn/problems/symmetric-tree/</a></p>
<p>给你一个二叉树的根节点 root ， 检查它是否轴对称。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;**
 * Definition for a binary tree node.
 * struct TreeNode &#123;
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;
 * &#125;;
 *&#x2F;
class Solution &#123;
public:
    bool isSymmetric(TreeNode* root) &#123;
        return check(root, root);
    &#125;

    bool check(TreeNode* p, TreeNode* q) &#123;
        if (!p &amp;&amp; !q) return true;
        if (!p || !q) return false;
        return p-&gt;val &#x3D;&#x3D; q-&gt;val &amp;&amp; check(p-&gt;left, q-&gt;right) &amp;&amp; check(p-&gt;right, q-&gt;left);
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104. 二叉树的最大深度"></a>104. 二叉树的最大深度</h3><p>问题地址：<a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">https://leetcode.cn/problems/maximum-depth-of-binary-tree/</a></p>
<p>给定一个二叉树 root ，返回其最大深度。</p>
<p>二叉树的 最大深度 是指从根节点到最远叶子节点的最长路径上的节点数。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;**
 * Definition for a binary tree node.
 * struct TreeNode &#123;
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;
 * &#125;;
 *&#x2F;
class Solution &#123;
public:
    int maxDepth(TreeNode* root) &#123;
        if (root &#x3D;&#x3D; nullptr) return 0;
        return max(maxDepth(root-&gt;left), maxDepth(root-&gt;right)) + 1;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="108-将有序数组转换为二叉搜索树"><a href="#108-将有序数组转换为二叉搜索树" class="headerlink" title="108. 将有序数组转换为二叉搜索树"></a>108. 将有序数组转换为二叉搜索树</h3><p>问题地址：<a href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/">https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/</a></p>
<p>给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。</p>
<p>高度平衡 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;**
 * Definition for a binary tree node.
 * struct TreeNode &#123;
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;
 * &#125;;
 *&#x2F;
class Solution &#123;
public:
    TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) &#123;
        return helper(nums, 0, nums.size() - 1);
    &#125;

    TreeNode* helper(vector&lt;int&gt;&amp; nums, int left, int right) &#123;
        if (left &gt; right) &#123;
            return nullptr;
        &#125;
        int mid &#x3D; (left + right) &#x2F; 2;

        TreeNode* root &#x3D; new TreeNode(nums[mid]);
        root-&gt;left &#x3D; helper(nums, left, mid - 1);
        root-&gt;right &#x3D; helper(nums, mid + 1, right);
        return root;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="110-平衡二叉树"><a href="#110-平衡二叉树" class="headerlink" title="110. 平衡二叉树"></a>110. 平衡二叉树</h3><p>问题地址：<a href="https://leetcode.cn/problems/balanced-binary-tree/">https://leetcode.cn/problems/balanced-binary-tree/</a></p>
<p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p>
<p>本题中，一棵高度平衡二叉树定义为：</p>
<p>一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int height(TreeNode* root) &#123;
        if (root &#x3D;&#x3D; nullptr) &#123;
            return 0;
        &#125; else &#123;
            return max(height(root-&gt;left), height(root-&gt;right)) + 1;
        &#125;
    &#125;

    bool isBalanced(TreeNode* root) &#123;
        if (root &#x3D;&#x3D; nullptr) &#123;
            return true;
        &#125; else &#123;
            return abs(height(root-&gt;left) - height(root-&gt;right)) &lt;&#x3D; 1 &amp;&amp; isBalanced(root-&gt;left) &amp;&amp; isBalanced(root-&gt;right);
        &#125;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="111-二叉树的最小深度"><a href="#111-二叉树的最小深度" class="headerlink" title="111. 二叉树的最小深度"></a>111. 二叉树的最小深度</h3><p>问题地址：<a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/">https://leetcode.cn/problems/minimum-depth-of-binary-tree/</a></p>
<p>给定一个二叉树，找出其最小深度。</p>
<p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p>
<p>说明：叶子节点是指没有子节点的节点。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;**
 * Definition for a binary tree node.
 * struct TreeNode &#123;
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;
 * &#125;;
 *&#x2F;
class Solution &#123;
public:
    int minDepth(TreeNode* root) &#123;
        if (root &#x3D;&#x3D; nullptr) &#123;
            return 0;
        &#125;
        if (root-&gt;left &#x3D;&#x3D; nullptr &amp;&amp; root-&gt;right &#x3D;&#x3D; nullptr) &#123;
            return 1;
        &#125;
        int min_depth &#x3D; INT_MAX;
        if (root-&gt;left !&#x3D; nullptr) &#123;
            min_depth &#x3D; min(minDepth(root-&gt;left), min_depth);
        &#125;
        if (root-&gt;right !&#x3D; nullptr) &#123;
            min_depth &#x3D; min(minDepth(root-&gt;right), min_depth);
        &#125;
        return min_depth + 1;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="112-路径总和"><a href="#112-路径总和" class="headerlink" title="112. 路径总和"></a>112. 路径总和</h3><p>问题地址：<a href="https://leetcode.cn/problems/path-sum/">https://leetcode.cn/problems/path-sum/</a></p>
<p>给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。</p>
<p>叶子节点 是指没有子节点的节点。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    bool hasPathSum(TreeNode *root, int sum) &#123;
        if (root &#x3D;&#x3D; nullptr) &#123;
            return false;
        &#125;
        if (root-&gt;left &#x3D;&#x3D; nullptr &amp;&amp; root-&gt;right &#x3D;&#x3D; nullptr) &#123;
            return sum &#x3D;&#x3D; root-&gt;val;
        &#125;
        return hasPathSum(root-&gt;left, sum - root-&gt;val) ||
               hasPathSum(root-&gt;right, sum - root-&gt;val);
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="118-杨辉三角"><a href="#118-杨辉三角" class="headerlink" title="118. 杨辉三角"></a>118. 杨辉三角</h3><p>问题地址：<a href="https://leetcode.cn/problems/pascals-triangle/">https://leetcode.cn/problems/pascals-triangle/</a></p>
<p>给定一个非负整数 numRows，生成「杨辉三角」的前 numRows 行。</p>
<p>在「杨辉三角」中，每个数是它左上方和右上方的数的和。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    vector&lt;vector&lt;int&gt;&gt; generate(int numRows) &#123;
        vector&lt;vector&lt;int&gt;&gt; ret(numRows);
        for (int i &#x3D; 0; i &lt; numRows; ++i) &#123;
            ret[i].resize(i + 1);
            ret[i][0] &#x3D; ret[i][i] &#x3D; 1;
            for (int j &#x3D; 1; j &lt; i; ++j) &#123;
                ret[i][j] &#x3D; ret[i - 1][j] + ret[i - 1][j - 1];
            &#125;
        &#125;
        return ret;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="119-杨辉三角-II"><a href="#119-杨辉三角-II" class="headerlink" title="119. 杨辉三角 II"></a>119. 杨辉三角 II</h3><p>问题地址：<a href="https://leetcode.cn/problems/pascals-triangle-ii/">https://leetcode.cn/problems/pascals-triangle-ii/</a></p>
<p>给定一个非负索引 rowIndex，返回「杨辉三角」的第 rowIndex 行。</p>
<p>在「杨辉三角」中，每个数是它左上方和右上方的数的和。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    vector&lt;int&gt; getRow(int rowIndex) &#123;
        vector&lt;vector&lt;int&gt;&gt; C(rowIndex + 1);
        for (int i &#x3D; 0; i &lt;&#x3D; rowIndex; ++i) &#123;
            C[i].resize(i + 1);
            C[i][0] &#x3D; C[i][i] &#x3D; 1;
            for (int j &#x3D; 1; j &lt; i; ++j) &#123;
                C[i][j] &#x3D; C[i - 1][j - 1] + C[i - 1][j];
            &#125;
        &#125;
        return C[rowIndex];
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121. 买卖股票的最佳时机"></a>121. 买卖股票的最佳时机</h3><p>问题地址：<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/</a></p>
<p>给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。</p>
<p>你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p>
<p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;
        int inf &#x3D; 1e9;
        int minPrice &#x3D; inf, maxProfit &#x3D; 0;
        for (int price : prices) &#123;
            maxProfit &#x3D; max(maxProfit, price - minPrice);
            minPrice &#x3D; min(price, minPrice);
        &#125;
        return maxProfit;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="125-验证回文串"><a href="#125-验证回文串" class="headerlink" title="125. 验证回文串"></a>125. 验证回文串</h3><p>问题地址：<a href="https://leetcode.cn/problems/valid-palindrome/">https://leetcode.cn/problems/valid-palindrome/</a></p>
<p>如果在将所有大写字符转换为小写字符、并移除所有非字母数字字符之后，短语正着读和反着读都一样。则可以认为该短语是一个 回文串 。</p>
<p>字母和数字都属于字母数字字符。</p>
<p>给你一个字符串 s，如果它是 回文串 ，返回 true ；否则，返回 false 。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    bool isPalindrome(string s) &#123;
        int left &#x3D; 0, right &#x3D; s.length() - 1;
        while (left &lt; right) &#123;
            while (left &lt; right &amp;&amp; !isalnum(s[left])) &#123;
                ++left;
            &#125;
            while (left &lt; right &amp;&amp; !isalnum(s[right])) &#123;
                --right;
            &#125;
            if (tolower(s[left]) !&#x3D; tolower(s[right])) &#123;
                return false;
            &#125;
            ++left;
            --right;
        &#125;
        return true;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="136-只出现一次的数字"><a href="#136-只出现一次的数字" class="headerlink" title="136. 只出现一次的数字"></a>136. 只出现一次的数字</h3><p>问题地址：<a href="https://leetcode.cn/problems/single-number/">https://leetcode.cn/problems/single-number/</a></p>
<p>给你一个 非空 整数数组 nums ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p>
<p>你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int singleNumber(vector&lt;int&gt;&amp; nums) &#123;
        int ret &#x3D; 0;
        for (auto e:nums) ret ^&#x3D; e;
        return ret;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141. 环形链表"></a>141. 环形链表</h3><p>问题地址：<a href="https://leetcode.cn/problems/linked-list-cycle/">https://leetcode.cn/problems/linked-list-cycle/</a></p>
<p>给你一个链表的头节点 head ，判断链表中是否有环。</p>
<p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。</p>
<p>如果链表中存在环 ，则返回 true 。 否则，返回 false 。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;**
 * Definition for singly-linked list.
 * struct ListNode &#123;
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) &#123;&#125;
 * &#125;;
 *&#x2F;
class Solution &#123;
public:
    bool hasCycle(ListNode *head) &#123;
        unordered_set&lt;ListNode*&gt; seen;
        while (head !&#x3D; nullptr) &#123;
            if (seen.count(head)) &#123;
                return true;
            &#125;
            seen.insert(head);
            head &#x3D; head-&gt;next;
        &#125;
        return false;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="145-二叉树的后序遍历"><a href="#145-二叉树的后序遍历" class="headerlink" title="145. 二叉树的后序遍历"></a>145. 二叉树的后序遍历</h3><p>问题地址：<a href="https://leetcode.cn/problems/binary-tree-postorder-traversal/">https://leetcode.cn/problems/binary-tree-postorder-traversal/</a></p>
<p>给你一棵二叉树的根节点 root ，返回其节点值的 后序遍历 。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;**
 * Definition for a binary tree node.
 * struct TreeNode &#123;
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;
 * &#125;;
 *&#x2F;
class Solution &#123;
public:
    vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123;
        vector&lt;int&gt; res;
        postorder(root, res);
        return res;
    &#125;

    void postorder(TreeNode *root, vector&lt;int&gt; &amp;res) &#123;
        if (root &#x3D;&#x3D; nullptr) &#123;
            return;
        &#125;
        postorder(root-&gt;left, res);
        postorder(root-&gt;right, res);
        res.push_back(root-&gt;val);
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160. 相交链表"></a>160. 相交链表</h3><p>问题地址：<a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/">https://leetcode.cn/problems/intersection-of-two-linked-lists/</a></p>
<p>给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;**
 * Definition for singly-linked list.
 * struct ListNode &#123;
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) &#123;&#125;
 * &#125;;
 *&#x2F;
class Solution &#123;
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123;
        unordered_set&lt;ListNode *&gt; visited;
        ListNode *temp &#x3D; headA;
        while (temp !&#x3D; nullptr) &#123;
            visited.insert(temp);
            temp &#x3D; temp-&gt;next;
        &#125;
        temp &#x3D; headB;
        while (temp !&#x3D; nullptr) &#123;
            if (visited.count(temp)) &#123;
                return temp;
            &#125;
            temp &#x3D; temp-&gt;next;
        &#125;
        return nullptr;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="168-Excel表列名称"><a href="#168-Excel表列名称" class="headerlink" title="168. Excel表列名称"></a>168. Excel表列名称</h3><p>问题地址：<a href="https://leetcode.cn/problems/excel-sheet-column-title/">https://leetcode.cn/problems/excel-sheet-column-title/</a></p>
<p>给你一个整数 columnNumber ，返回它在 Excel 表中相对应的列名称。</p>
<p>例如：</p>
<pre class="line-numbers language-none"><code class="language-none">A -&gt; 1
B -&gt; 2
C -&gt; 3
...
Z -&gt; 26
AA -&gt; 27
AB -&gt; 28 
...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    string convertToTitle(int columnNumber) &#123;
        string ans;
        while (columnNumber &gt; 0) &#123;
            int a0 &#x3D; (columnNumber - 1) % 26 + 1;
            ans +&#x3D; a0 - 1 + &#39;A&#39;;
            columnNumber &#x3D; (columnNumber - a0) &#x2F; 26;
        &#125;
        reverse(ans.begin(), ans.end());
        return ans;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a>206. 反转链表</h3><p>问题地址：<a href="https://leetcode.cn/problems/reverse-linked-list/">https://leetcode.cn/problems/reverse-linked-list/</a></p>
<p>给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;**
 * Definition for singly-linked list.
 * struct ListNode &#123;
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) &#123;&#125;
 *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;
 *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;
 * &#125;;
 *&#x2F;
class Solution &#123;
public:
    ListNode* reverseList(ListNode* head) &#123;
        ListNode* prev &#x3D; nullptr;
        ListNode* curr &#x3D; head;
        while (curr) &#123;
            ListNode* next &#x3D; curr-&gt;next;
            curr-&gt;next &#x3D; prev;
            prev &#x3D; curr;
            curr &#x3D; next;
        &#125;
        return prev;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="283-移动零"><a href="#283-移动零" class="headerlink" title="283. 移动零"></a>283. 移动零</h3><p>问题地址：<a href="https://leetcode.cn/problems/move-zeroes/">https://leetcode.cn/problems/move-zeroes/</a></p>
<p>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</p>
<p>请注意 ，必须在不复制数组的情况下原地对数组进行操作。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    void moveZeroes(vector&lt;int&gt;&amp; nums) &#123;
        int n &#x3D; nums.size(), left &#x3D; 0, right &#x3D; 0;
        while (right &lt; n) &#123;
            if (nums[right]) &#123;
                swap(nums[left], nums[right]);
                left++;
            &#125;
            right++;
        &#125;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="344-反转字符串"><a href="#344-反转字符串" class="headerlink" title="344. 反转字符串"></a>344. 反转字符串</h3><p>问题地址：<a href="https://leetcode.cn/problems/reverse-string/">https://leetcode.cn/problems/reverse-string/</a></p>
<p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。</p>
<p>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    void reverseString(vector&lt;char&gt;&amp; s) &#123;
        int n &#x3D; s.size();
        for (int left &#x3D; 0, right &#x3D; n - 1; left &lt; right; ++left, --right) &#123;
            swap(s[left], s[right]);
        &#125;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="228-汇总区间"><a href="#228-汇总区间" class="headerlink" title="228. 汇总区间"></a>228. 汇总区间</h3><p>问题地址：<a href="https://leetcode.cn/problems/summary-ranges/">https://leetcode.cn/problems/summary-ranges/</a></p>
<p>给定一个  无重复元素 的 有序 整数数组 nums 。</p>
<p>返回 恰好覆盖数组中所有数字 的 最小有序 区间范围列表 。也就是说，nums 的每个元素都恰好被某个区间范围所覆盖，并且不存在属于某个范围但不属于 nums 的数字 x 。</p>
<p>列表中的每个区间范围 <code>[a,b]</code> 应该按如下格式输出：</p>
<ul>
<li>“a-&gt;b” ，如果 a !&#x3D; b</li>
<li>“a” ，如果 a &#x3D;&#x3D; b</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    vector&lt;string&gt; summaryRanges(vector&lt;int&gt;&amp; nums) &#123;
        vector&lt;string&gt; ret;
        int i &#x3D; 0;
        int n &#x3D; nums.size();
        while (i &lt; n) &#123;
            int low &#x3D; i;
            i++;
            while (i &lt; n &amp;&amp; nums[i] &#x3D;&#x3D; nums[i - 1] + 1) &#123;
                i++;
            &#125;
            int high &#x3D; i - 1;
            string temp &#x3D; to_string(nums[low]);
            if (low &lt; high) &#123;
                temp.append(&quot;-&gt;&quot;);
                temp.append(to_string(nums[high]));
            &#125;
            ret.push_back(move(temp));
        &#125;
        return ret;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="169-多数元素"><a href="#169-多数元素" class="headerlink" title="169. 多数元素"></a>169. 多数元素</h3><p>问题地址：<a href="https://leetcode.cn/problems/majority-element/">https://leetcode.cn/problems/majority-element/</a></p>
<p>给定一个大小为 n 的数组 nums ，返回其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n&#x2F;2 ⌋ 的元素。</p>
<p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int majorityElement(vector&lt;int&gt;&amp; nums) &#123;
        sort(nums.begin(), nums.end());
        return nums[nums.size() &#x2F; 2];
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="171-Excel-表列序号"><a href="#171-Excel-表列序号" class="headerlink" title="171. Excel 表列序号"></a>171. Excel 表列序号</h3><p>问题地址：<a href="https://leetcode.cn/problems/excel-sheet-column-number/">https://leetcode.cn/problems/excel-sheet-column-number/</a></p>
<p>给你一个字符串 columnTitle ，表示 Excel 表格中的列名称。返回 该列名称对应的列序号 。</p>
<p>例如：</p>
<pre class="line-numbers language-none"><code class="language-none">A -&gt; 1
B -&gt; 2
C -&gt; 3
...
Z -&gt; 26
AA -&gt; 27
AB -&gt; 28 
...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int titleToNumber(string columnTitle) &#123;
        int number &#x3D; 0;
        long multiple &#x3D; 1;
        for (int i &#x3D; columnTitle.size() - 1; i &gt;&#x3D; 0; i--) &#123;
            int k &#x3D; columnTitle[i] - &#39;A&#39; + 1;
            number +&#x3D; k * multiple;
            multiple *&#x3D; 26;
        &#125;
        return number;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="190-颠倒二进制位"><a href="#190-颠倒二进制位" class="headerlink" title="190. 颠倒二进制位"></a>190. 颠倒二进制位</h3><p>问题地址：<a href="https://leetcode.cn/problems/reverse-bits/">https://leetcode.cn/problems/reverse-bits/</a></p>
<p>颠倒给定的 32 位无符号整数的二进制位。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    uint32_t reverseBits(uint32_t n) &#123;
        uint32_t rev &#x3D; 0;
        for (int i &#x3D; 0; i &lt; 32 &amp;&amp; n &gt; 0; ++i) &#123;
            rev |&#x3D; (n &amp; 1) &lt;&lt; (31 - i);
            n &gt;&gt;&#x3D; 1;
        &#125;
        return rev;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="191-位1的个数"><a href="#191-位1的个数" class="headerlink" title="191. 位1的个数"></a>191. 位1的个数</h3><p>问题地址：<a href="https://leetcode.cn/problems/number-of-1-bits/">https://leetcode.cn/problems/number-of-1-bits/</a></p>
<p>编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int hammingWeight(uint32_t n) &#123;
        int ret &#x3D; 0;
        for (int i &#x3D; 0; i &lt; 32; i++) &#123;
            if (n &amp; (1 &lt;&lt; i)) &#123;
                ret++;
            &#125;
        &#125;
        return ret;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="202-快乐数"><a href="#202-快乐数" class="headerlink" title="202. 快乐数"></a>202. 快乐数</h3><p>问题地址：<a href="https://leetcode.cn/problems/happy-number/">https://leetcode.cn/problems/happy-number/</a></p>
<p>编写一个算法来判断一个数 n 是不是快乐数。</p>
<p>「快乐数」 定义为：</p>
<ul>
<li>对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。</li>
<li>然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。</li>
<li>如果这个过程 结果为 1，那么这个数就是快乐数。</li>
</ul>
<p>如果 n 是 快乐数 就返回 true ；不是，则返回 false 。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int bitSquareSum(int n) &#123;
        int sum &#x3D; 0;
        while(n &gt; 0)
        &#123;
            int bit &#x3D; n % 10;
            sum +&#x3D; bit * bit;
            n &#x3D; n &#x2F; 10;
        &#125;
        return sum;
    &#125;
    
    bool isHappy(int n) &#123;
        int slow &#x3D; n, fast &#x3D; n;
        do&#123;
            slow &#x3D; bitSquareSum(slow);
            fast &#x3D; bitSquareSum(fast);
            fast &#x3D; bitSquareSum(fast);
        &#125;while(slow !&#x3D; fast);
        
        return slow &#x3D;&#x3D; 1;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="203. 移除链表元素"></a>203. 移除链表元素</h3><p>问题地址：<a href="https://leetcode.cn/problems/remove-linked-list-elements/">https://leetcode.cn/problems/remove-linked-list-elements/</a></p>
<p>给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val &#x3D;&#x3D; val 的节点，并返回 新的头节点 。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;**
 * Definition for singly-linked list.
 * struct ListNode &#123;
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) &#123;&#125;
 *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;
 *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;
 * &#125;;
 *&#x2F;
class Solution &#123;
public:
    ListNode* removeElements(ListNode* head, int val) &#123;
        if (head &#x3D;&#x3D; nullptr) &#123;
            return head;
        &#125;
        head-&gt;next &#x3D; removeElements(head-&gt;next, val);
        return head-&gt;val &#x3D;&#x3D; val ? head-&gt;next : head;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="205-同构字符串"><a href="#205-同构字符串" class="headerlink" title="205. 同构字符串"></a>205. 同构字符串</h3><p>问题地址：<a href="https://leetcode.cn/problems/isomorphic-strings/">https://leetcode.cn/problems/isomorphic-strings/</a></p>
<p>给定两个字符串 s 和 t ，判断它们是否是同构的。</p>
<p>如果 s 中的字符可以按某种映射关系替换得到 t ，那么这两个字符串是同构的。</p>
<p>每个出现的字符都应当映射到另一个字符，同时不改变字符的顺序。不同字符不能映射到同一个字符上，相同字符只能映射到同一个字符上，字符可以映射到自己本身。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    bool isIsomorphic(string s, string t) &#123;
        unordered_map&lt;char, char&gt; s2t;
        unordered_map&lt;char, char&gt; t2s;
        int len &#x3D; s.length();
        for (int i &#x3D; 0; i &lt; len; ++i) &#123;
            char x &#x3D; s[i], y &#x3D; t[i];
            if ((s2t.count(x) &amp;&amp; s2t[x] !&#x3D; y) || (t2s.count(y) &amp;&amp; t2s[y] !&#x3D; x)) &#123;
                return false;
            &#125;
            s2t[x] &#x3D; y;
            t2s[y] &#x3D; x;
        &#125;
        return true;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="217-存在重复元素"><a href="#217-存在重复元素" class="headerlink" title="217. 存在重复元素"></a>217. 存在重复元素</h3><p>问题地址：<a href="https://leetcode.cn/problems/contains-duplicate/">https://leetcode.cn/problems/contains-duplicate/</a></p>
<p>给你一个整数数组 nums 。如果任一值在数组中出现 至少两次 ，返回 true ；如果数组中每个元素互不相同，返回 false 。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    bool containsDuplicate(vector&lt;int&gt;&amp; nums) &#123;
        sort(nums.begin(), nums.end());
        int n &#x3D; nums.size();
        for (int i &#x3D; 0; i &lt; n - 1; i++) &#123;
            if (nums[i] &#x3D;&#x3D; nums[i + 1]) &#123;
                return true;
            &#125;
        &#125;
        return false;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="219-存在重复元素-II"><a href="#219-存在重复元素-II" class="headerlink" title="219. 存在重复元素 II"></a>219. 存在重复元素 II</h3><p>问题地址：<a href="https://leetcode.cn/problems/contains-duplicate-ii/">https://leetcode.cn/problems/contains-duplicate-ii/</a></p>
<p>给你一个整数数组 nums 和一个整数 k ，判断数组中是否存在两个 不同的索引 i 和 j ，满足 nums[i] &#x3D;&#x3D; nums[j] 且 abs(i - j) &lt;&#x3D; k 。如果存在，返回 true ；否则，返回 false 。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    bool containsNearbyDuplicate(vector&lt;int&gt;&amp; nums, int k) &#123;
        unordered_map&lt;int, int&gt; dict;
        int len &#x3D; nums.size();
        for (int i &#x3D; 0; i &lt; len; i++) &#123;
            int num &#x3D; nums[i];
            if (dict.count(num) &amp;&amp; i - dict[num] &lt;&#x3D; k) &#123;
                return true;
            &#125;
            dict[num] &#x3D; i;
        &#125;
        return false;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="225-用队列实现栈"><a href="#225-用队列实现栈" class="headerlink" title="225. 用队列实现栈"></a>225. 用队列实现栈</h3><p>问题地址：<a href="https://leetcode.cn/problems/implement-stack-using-queues/">https://leetcode.cn/problems/implement-stack-using-queues/</a></p>
<p>请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push、top、pop 和 empty）。</p>
<p>实现 MyStack 类：</p>
<ul>
<li>void push(int x) 将元素 x 压入栈顶。</li>
<li>int pop() 移除并返回栈顶元素。</li>
<li>int top() 返回栈顶元素。</li>
<li>boolean empty() 如果栈是空的，返回 true ；否则，返回 false 。</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class MyStack &#123;
public:
    queue&lt;int&gt; queue1;
    queue&lt;int&gt; queue2;

    MyStack() &#123;

    &#125;
    
    void push(int x) &#123;
        queue2.push(x);
        while (!queue1.empty()) &#123;
            queue2.push(queue1.front());
            queue1.pop();
        &#125;
        swap(queue1, queue2);
    &#125;
    
    int pop() &#123;
        int r &#x3D; queue1.front();
        queue1.pop();
        return r;
    &#125;
    
    int top() &#123;
        int r &#x3D; queue1.front();
        return r;
    &#125;
    
    bool empty() &#123;
        return queue1.empty();
    &#125;
&#125;;

&#x2F;**
 * Your MyStack object will be instantiated and called as such:
 * MyStack* obj &#x3D; new MyStack();
 * obj-&gt;push(x);
 * int param_2 &#x3D; obj-&gt;pop();
 * int param_3 &#x3D; obj-&gt;top();
 * bool param_4 &#x3D; obj-&gt;empty();
 *&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226. 翻转二叉树"></a>226. 翻转二叉树</h3><p>问题地址：<a href="https://leetcode.cn/problems/invert-binary-tree/">https://leetcode.cn/problems/invert-binary-tree/</a></p>
<p>给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;**
 * Definition for a binary tree node.
 * struct TreeNode &#123;
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;
 * &#125;;
 *&#x2F;
class Solution &#123;
public:
    TreeNode* invertTree(TreeNode* root) &#123;
        if (root &#x3D;&#x3D; nullptr) &#123;
            return nullptr;
        &#125;
        TreeNode* left &#x3D; invertTree(root-&gt;left);
        TreeNode* right &#x3D; invertTree(root-&gt;right);
        root-&gt;left &#x3D; right;
        root-&gt;right &#x3D; left;
        return root;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="231-2-的幂"><a href="#231-2-的幂" class="headerlink" title="231. 2 的幂"></a>231. 2 的幂</h3><p>问题地址：<a href="https://leetcode.cn/problems/power-of-two/">https://leetcode.cn/problems/power-of-two/</a></p>
<p>给你一个整数 n，请你判断该整数是否是 2 的幂次方。如果是，返回 true ；否则，返回 false 。</p>
<p>如果存在一个整数 x 使得 n &#x3D;&#x3D; 2x ，则认为 n 是 2 的幂次方。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    bool isPowerOfTwo(int n) &#123;
        return n &gt; 0 &amp;&amp; (n &amp; (n - 1)) &#x3D;&#x3D; 0;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="232-用栈实现队列"><a href="#232-用栈实现队列" class="headerlink" title="232. 用栈实现队列"></a>232. 用栈实现队列</h3><p>问题地址：<a href="https://leetcode.cn/problems/implement-queue-using-stacks/">https://leetcode.cn/problems/implement-queue-using-stacks/</a></p>
<p>请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：</p>
<p>实现 MyQueue 类：</p>
<ul>
<li>void push(int x) 将元素 x 推到队列的末尾</li>
<li>int pop() 从队列的开头移除并返回元素</li>
<li>int peek() 返回队列开头的元素</li>
<li>boolean empty() 如果队列为空，返回 true ；否则，返回 false</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class MyQueue &#123;
private:
    stack&lt;int&gt; inStack, outStack;
    void in2out() &#123;
        while (!inStack.empty()) &#123;
            outStack.push(inStack.top());
            inStack.pop();
        &#125;
    &#125;
public:
    MyQueue() &#123;

    &#125;
    
    void push(int x) &#123;
        inStack.push(x);
    &#125;
    
    int pop() &#123;
        if (outStack.empty()) &#123;
            in2out();
        &#125;
        int x &#x3D; outStack.top();
        outStack.pop();
        return x;
    &#125;
    
    int peek() &#123;
        if (outStack.empty()) &#123;
            in2out();
        &#125;
        return outStack.top();
    &#125;
    
    bool empty() &#123;
        return inStack.empty() &amp;&amp; outStack.empty();
    &#125;
&#125;;

&#x2F;**
 * Your MyQueue object will be instantiated and called as such:
 * MyQueue* obj &#x3D; new MyQueue();
 * obj-&gt;push(x);
 * int param_2 &#x3D; obj-&gt;pop();
 * int param_3 &#x3D; obj-&gt;peek();
 * bool param_4 &#x3D; obj-&gt;empty();
 *&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="234-回文链表"><a href="#234-回文链表" class="headerlink" title="234. 回文链表"></a>234. 回文链表</h3><p>问题地址：<a href="https://leetcode.cn/problems/palindrome-linked-list/">https://leetcode.cn/problems/palindrome-linked-list/</a></p>
<p>给你一个单链表的头节点 head ，请你判断该链表是否为回文链表。如果是，返回 true ；否则，返回 false 。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;**
 * Definition for singly-linked list.
 * struct ListNode &#123;
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) &#123;&#125;
 *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;
 *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;
 * &#125;;
 *&#x2F;
class Solution &#123;
public:
    bool isPalindrome(ListNode* head) &#123;
        vector&lt;int&gt; vals;
        while (head !&#x3D; nullptr) &#123;
            vals.emplace_back(head-&gt;val);
            head &#x3D; head-&gt;next;
        &#125;
        for (int i &#x3D; 0, j &#x3D; vals.size() - 1; i &lt; j; ++i, --j) &#123;
            if (vals[i] !&#x3D; vals[j]) &#123;
                return false;
            &#125;
        &#125;
        return true;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="242-有效的字母异位词"><a href="#242-有效的字母异位词" class="headerlink" title="242. 有效的字母异位词"></a>242. 有效的字母异位词</h3><p>问题地址：<a href="https://leetcode.cn/problems/valid-anagram/">https://leetcode.cn/problems/valid-anagram/</a></p>
<p>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。</p>
<p>注意：若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    bool isAnagram(string s, string t) &#123;
        if (s.length() !&#x3D; t.length()) &#123;
            return false;
        &#125;
        sort(s.begin(), s.end());
        sort(t.begin(), t.end());
        return s &#x3D;&#x3D; t;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="392-判断子序列"><a href="#392-判断子序列" class="headerlink" title="392. 判断子序列"></a>392. 判断子序列</h3><p>问题地址：<a href="https://leetcode.cn/problems/is-subsequence/">https://leetcode.cn/problems/is-subsequence/</a></p>
<p>给定字符串 s 和 t ，判断 s 是否为 t 的子序列。</p>
<p>字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，”ace”是”abcde”的一个子序列，而”aec”不是）。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    bool isSubsequence(string s, string t) &#123;
        int n &#x3D; s.length(), m &#x3D; t.length();
        int i &#x3D; 0, j &#x3D; 0;
        while (i &lt; n &amp;&amp; j &lt; m) &#123;
            if (s[i] &#x3D;&#x3D; t[j]) &#123;
                i++;
            &#125;
            j++;
        &#125;
        return i &#x3D;&#x3D; n;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="257-二叉树的所有路径"><a href="#257-二叉树的所有路径" class="headerlink" title="257. 二叉树的所有路径"></a>257. 二叉树的所有路径</h3><p>问题地址：<a href="https://leetcode.cn/problems/binary-tree-paths/">https://leetcode.cn/problems/binary-tree-paths/</a></p>
<p>给你一个二叉树的根节点 root ，按 任意顺序 ，返回所有从根节点到叶子节点的路径。</p>
<p>叶子节点 是指没有子节点的节点。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;**
 * Definition for a binary tree node.
 * struct TreeNode &#123;
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;
 * &#125;;
 *&#x2F;
class Solution &#123;
public:
    vector&lt;string&gt; binaryTreePaths(TreeNode* root) &#123;
        vector&lt;string&gt; paths;
        construct_paths(root, &quot;&quot;, paths);
        return paths;
    &#125;
    void construct_paths(TreeNode* root, string path, vector&lt;string&gt;&amp; paths) &#123;
        if (root !&#x3D; nullptr) &#123;
            path +&#x3D; to_string(root-&gt;val);
            if (root-&gt;left &#x3D;&#x3D; nullptr &amp;&amp; root-&gt;right &#x3D;&#x3D; nullptr) &#123;
                paths.push_back(path);
            &#125; else &#123;
                path +&#x3D; &quot;-&gt;&quot;;
                construct_paths(root-&gt;left, path, paths);
                construct_paths(root-&gt;right, path, paths);
            &#125;
        &#125;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="258-各位相加"><a href="#258-各位相加" class="headerlink" title="258. 各位相加"></a>258. 各位相加</h3><p>问题地址：<a href="https://leetcode.cn/problems/add-digits/">https://leetcode.cn/problems/add-digits/</a></p>
<p>给定一个非负整数 num，反复将各个位上的数字相加，直到结果为一位数。返回这个结果。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int addDigits(int num) &#123;
        while (num &gt;&#x3D; 10) &#123;
            int sum &#x3D; 0;
            while (num &gt; 0) &#123;
                sum +&#x3D; num % 10;
                num &#x2F;&#x3D; 10;
            &#125;
            num &#x3D; sum;
        &#125;
        return num;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="263-丑数"><a href="#263-丑数" class="headerlink" title="263. 丑数"></a>263. 丑数</h3><p>问题地址：<a href="https://leetcode.cn/problems/ugly-number/">https://leetcode.cn/problems/ugly-number/</a></p>
<p>丑数 就是只包含质因数 2、3 和 5 的正整数。</p>
<p>给你一个整数 n ，请你判断 n 是否为 丑数 。如果是，返回 true ；否则，返回 false 。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    bool isUgly(int n) &#123;
        if (n &lt;&#x3D; 0) &#123;
            return false;
        &#125;
        vector&lt;int&gt; factors &#x3D; &#123;2, 3, 5&#125;;
        for (auto factor : factors) &#123;
            while (n % factor &#x3D;&#x3D; 0) &#123;
                n &#x2F;&#x3D; factor;
            &#125;
        &#125;
        return n &#x3D;&#x3D; 1;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="268-丢失的数字"><a href="#268-丢失的数字" class="headerlink" title="268. 丢失的数字"></a>268. 丢失的数字</h3><p>问题地址：<a href="https://leetcode.cn/problems/missing-number/">https://leetcode.cn/problems/missing-number/</a></p>
<p>给定一个包含 [0, n] 中 n 个数的数组 nums ，找出 [0, n] 这个范围内没有出现在数组中的那个数。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int missingNumber(vector&lt;int&gt;&amp; nums) &#123;
        sort(nums.begin(), nums.end());
        int n &#x3D; nums.size();
        for (int i &#x3D; 0; i &lt; n; i++) &#123;
            if (nums[i] !&#x3D; i) &#123;
                return i;
            &#125;
        &#125;
        return n;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="278-第一个错误的版本"><a href="#278-第一个错误的版本" class="headerlink" title="278. 第一个错误的版本"></a>278. 第一个错误的版本</h3><p>问题地址：<a href="https://leetcode.cn/problems/first-bad-version/">https://leetcode.cn/problems/first-bad-version/</a></p>
<p>你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。</p>
<p>假设你有 n 个版本 [1, 2, …, n]，你想找出导致之后所有版本出错的第一个错误的版本。</p>
<p>你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; The API isBadVersion is defined for you.
&#x2F;&#x2F; bool isBadVersion(int version);

class Solution &#123;
public:
    int firstBadVersion(int n) &#123;
        int left &#x3D; 1, right &#x3D; n;
        while (left &lt; right) &#123;
            int mid &#x3D; left + (right - left) &#x2F; 2;
            if (isBadVersion(mid)) &#123;
                right &#x3D; mid;
            &#125; else &#123;
                left &#x3D; mid + 1;
            &#125;
        &#125;
        return left;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="290-单词规律"><a href="#290-单词规律" class="headerlink" title="290. 单词规律"></a>290. 单词规律</h3><p>问题地址：<a href="https://leetcode.cn/problems/word-pattern/">https://leetcode.cn/problems/word-pattern/</a></p>
<p>给定一种规律 pattern 和一个字符串 s ，判断 s 是否遵循相同的规律。</p>
<p>这里的 遵循 指完全匹配，例如， pattern 里的每个字母和字符串 s 中的每个非空单词之间存在着双向连接的对应规律。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    bool wordPattern(string pattern, string str) &#123;
        unordered_map&lt;string, char&gt; str2ch;
        unordered_map&lt;char, string&gt; ch2str;
        int m &#x3D; str.length();
        int i &#x3D; 0;
        for (auto ch : pattern) &#123;
            if (i &gt;&#x3D; m) &#123;
                return false;
            &#125;
            int j &#x3D; i;
            while (j &lt; m &amp;&amp; str[j] !&#x3D; &#39; &#39;) j++;
            const string &amp;tmp &#x3D; str.substr(i, j - i);
            if (str2ch.count(tmp) &amp;&amp; str2ch[tmp] !&#x3D; ch) &#123;
                return false;
            &#125;
            if (ch2str.count(ch) &amp;&amp; ch2str[ch] !&#x3D; tmp) &#123;
                return false;
            &#125;
            str2ch[tmp] &#x3D; ch;
            ch2str[ch] &#x3D; tmp;
            i &#x3D; j + 1;
        &#125;
        return i &gt;&#x3D; m;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="292-Nim-游戏"><a href="#292-Nim-游戏" class="headerlink" title="292. Nim 游戏"></a>292. Nim 游戏</h3><p>问题地址：<a href="https://leetcode.cn/problems/nim-game/">https://leetcode.cn/problems/nim-game/</a></p>
<p>你和你的朋友，两个人一起玩 Nim 游戏：</p>
<ul>
<li>桌子上有一堆石头。</li>
<li>你们轮流进行自己的回合， 你作为先手 。</li>
<li>每一回合，轮到的人拿掉 1 - 3 块石头。</li>
<li>拿掉最后一块石头的人就是获胜者。</li>
</ul>
<p>假设你们每一步都是最优解。请编写一个函数，来判断你是否可以在给定石头数量为 n 的情况下赢得游戏。如果可以赢，返回 true；否则，返回 false 。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    bool canWinNim(int n) &#123;
        return n % 4 !&#x3D; 0;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="326-3-的幂"><a href="#326-3-的幂" class="headerlink" title="326. 3 的幂"></a>326. 3 的幂</h3><p>问题地址：<a href="https://leetcode.cn/problems/power-of-three/">https://leetcode.cn/problems/power-of-three/</a></p>
<p>给定一个整数，写一个函数来判断它是否是 3 的幂次方。如果是，返回 true ；否则，返回 false 。</p>
<p>整数 n 是 3 的幂次方需满足：存在整数 x 使得 n &#x3D;&#x3D; 3x</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    bool isPowerOfThree(int n) &#123;
        while (n &amp;&amp; n % 3 &#x3D;&#x3D; 0) &#123;
            n &#x2F;&#x3D; 3;
        &#125;
        return n &#x3D;&#x3D; 1;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="342-4的幂"><a href="#342-4的幂" class="headerlink" title="342. 4的幂"></a>342. 4的幂</h3><p>问题地址：<a href="https://leetcode.cn/problems/power-of-four/">https://leetcode.cn/problems/power-of-four/</a></p>
<p>给定一个整数，写一个函数来判断它是否是 4 的幂次方。如果是，返回 true ；否则，返回 false 。</p>
<p>整数 n 是 4 的幂次方需满足：存在整数 x 使得 n &#x3D;&#x3D; 4x</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    bool isPowerOfFour(int n) &#123;
        while (n &amp;&amp; n % 4 &#x3D;&#x3D; 0) &#123;
            n &#x2F;&#x3D; 4;
        &#125;
        return n &#x3D;&#x3D; 1;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="383-赎金信"><a href="#383-赎金信" class="headerlink" title="383. 赎金信"></a>383. 赎金信</h3><p>问题地址：<a href="https://leetcode.cn/problems/ransom-note/">https://leetcode.cn/problems/ransom-note/</a></p>
<p>给你两个字符串：ransomNote 和 magazine ，判断 ransomNote 能不能由 magazine 里面的字符构成。</p>
<p>如果可以，返回 true ；否则返回 false 。</p>
<p>magazine 中的每个字符只能在 ransomNote 中使用一次。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    bool canConstruct(string ransomNote, string magazine) &#123;
        if (ransomNote.size() &gt; magazine.size()) &#123;
            return false;
        &#125;
        vector&lt;int&gt; cnt(26);
        for (auto &amp; c : magazine) &#123;
            cnt[c - &#39;a&#39;]++;
        &#125;
        for (auto &amp; c : ransomNote) &#123;
            cnt[c - &#39;a&#39;]--;
            if (cnt[c - &#39;a&#39;] &lt; 0) &#123;
                return false;
            &#125;
        &#125;
        return true;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="222-完全二叉树的节点个数"><a href="#222-完全二叉树的节点个数" class="headerlink" title="222. 完全二叉树的节点个数"></a>222. 完全二叉树的节点个数</h3><p>问题地址：<a href="https://leetcode.cn/problems/count-complete-tree-nodes/">https://leetcode.cn/problems/count-complete-tree-nodes/</a></p>
<p>给你一棵 完全二叉树 的根节点 root ，求出该树的节点个数。</p>
<p>完全二叉树 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;**
 * Definition for a binary tree node.
 * struct TreeNode &#123;
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;
 * &#125;;
 *&#x2F;
class Solution &#123;
public:
    int countNodes(TreeNode* root) &#123;
        if (!root) return 0;
        return countNodes(root-&gt;left) + countNodes(root-&gt;right) + 1;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="637-二叉树的层平均值"><a href="#637-二叉树的层平均值" class="headerlink" title="637. 二叉树的层平均值"></a>637. 二叉树的层平均值</h3><p>问题地址：<a href="https://leetcode.cn/problems/average-of-levels-in-binary-tree/">https://leetcode.cn/problems/average-of-levels-in-binary-tree/</a></p>
<p>给定一个非空二叉树的根节点 root , 以数组的形式返回每一层节点的平均值。与实际答案相差 10-5 以内的答案可以被接受。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;**
 * Definition for a binary tree node.
 * struct TreeNode &#123;
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;
 * &#125;;
 *&#x2F;
class Solution &#123;
public:
    vector&lt;double&gt; averageOfLevels(TreeNode* root) &#123;
        vector&lt;double&gt; ans;
        if (!root) return ans;
        queue&lt;TreeNode*&gt; q;
        q.push(root);
        while (!q.empty()) &#123;
            double total &#x3D; 0;
            int count &#x3D; q.size();
            int n &#x3D; count;
            while (count--) &#123;
                TreeNode* tmp &#x3D; q.front();
                q.pop();
                total +&#x3D; tmp-&gt;val;
                if (tmp-&gt;left) q.push(tmp-&gt;left);
                if (tmp-&gt;right) q.push(tmp-&gt;right);
            &#125;
            ans.push_back(total&#x2F;n);
        &#125;
        return ans;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="530-二叉搜索树的最小绝对差"><a href="#530-二叉搜索树的最小绝对差" class="headerlink" title="530. 二叉搜索树的最小绝对差"></a>530. 二叉搜索树的最小绝对差</h3><p>问题地址：<a href="https://leetcode.cn/problems/minimum-absolute-difference-in-bst/">https://leetcode.cn/problems/minimum-absolute-difference-in-bst/</a></p>
<p>给你一个二叉搜索树的根节点 root ，返回 树中任意两不同节点值之间的最小差值 。</p>
<p>差值是一个正数，其数值等于两值之差的绝对值。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;**
 * Definition for a binary tree node.
 * struct TreeNode &#123;
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;
 * &#125;;
 *&#x2F;
class Solution &#123;
public:
    int getMinimumDifference(TreeNode* root) &#123;
        int ans &#x3D; INT_MAX, pre &#x3D; -1;
        dfs(root, pre, ans);
        return ans;
    &#125;
    void dfs(TreeNode* root, int&amp; pre, int&amp; ans) &#123;
        if (root &#x3D;&#x3D; nullptr) return;
        dfs(root-&gt;left, pre, ans);
        if (pre &#x3D;&#x3D; -1) &#123;
            pre &#x3D; root-&gt;val;
        &#125; else &#123;
            ans &#x3D; min(ans, root-&gt;val - pre);
            pre &#x3D; root-&gt;val;
        &#125;
        dfs(root-&gt;right, pre, ans);
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="557-反转字符串中的单词-III"><a href="#557-反转字符串中的单词-III" class="headerlink" title="557. 反转字符串中的单词 III"></a>557. 反转字符串中的单词 III</h3><p>问题地址：<a href="https://leetcode.cn/problems/reverse-words-in-a-string-iii/">https://leetcode.cn/problems/reverse-words-in-a-string-iii/</a></p>
<p>给定一个字符串 s ，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    string reverseWords(string s) &#123;
        string ret;
        int length &#x3D; s.length();
        int i &#x3D; 0;
        while (i &lt; length) &#123;
            int start &#x3D; i;
            while (i &lt; length &amp;&amp; s[i] !&#x3D; &#39; &#39;) &#123;
                i++;
            &#125;
            for (int p &#x3D; start; p &lt; i; p++) &#123;
                ret.push_back(s[start + i - 1 - p]);
            &#125;
            while (i &lt; length &amp;&amp; s[i] &#x3D;&#x3D; &#39; &#39;) &#123;
                i++;
                ret.push_back(&#39; &#39;);
            &#125;
        &#125;
        return ret;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="1768-交替合并字符串"><a href="#1768-交替合并字符串" class="headerlink" title="1768. 交替合并字符串"></a>1768. 交替合并字符串</h3><p>问题地址：<a href="https://leetcode.cn/problems/merge-strings-alternately/">https://leetcode.cn/problems/merge-strings-alternately/</a></p>
<p>给你两个字符串 word1 和 word2 。请你从 word1 开始，通过交替添加字母来合并字符串。如果一个字符串比另一个字符串长，就将多出来的字母追加到合并后字符串的末尾。</p>
<p>返回 合并后的字符串 。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    string mergeAlternately(string word1, string word2) &#123;
        int m &#x3D; word1.size(), n &#x3D; word2.size();
        int i &#x3D; 0, j &#x3D; 0;

        string ans;
        while (i &lt; m || j &lt; n) &#123;
            if (i &lt; m) &#123;
                ans.push_back(word1[i]);
                ++i;
            &#125;
            if (j &lt; n) &#123;
                ans.push_back(word2[j]);
                ++j;
            &#125;
        &#125;
        return ans;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="1071-字符串的最大公因子"><a href="#1071-字符串的最大公因子" class="headerlink" title="1071. 字符串的最大公因子"></a>1071. 字符串的最大公因子</h3><p>问题地址：<a href="https://leetcode.cn/problems/greatest-common-divisor-of-strings/">https://leetcode.cn/problems/greatest-common-divisor-of-strings/</a></p>
<p>对于字符串 s 和 t，只有在 s &#x3D; t + … + t（t 自身连接 1 次或多次）时，我们才认定 “t 能除尽 s”。</p>
<p>给定两个字符串 str1 和 str2 。返回 最长字符串 x，要求满足 x 能除尽 str1 且 x 能除尽 str2 。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    string gcdOfStrings(string str1, string str2) &#123;
        int len1 &#x3D; str1.length(), len2 &#x3D; str2.length();
        for (int i &#x3D; min(len1, len2); i &gt;&#x3D; 1; --i) &#123;
            if (len1 % i &#x3D;&#x3D; 0 &amp;&amp; len2 % i &#x3D;&#x3D; 0) &#123;
                string x &#x3D; str1.substr(0, i);
                if (check(x, str1) &amp;&amp; check(x, str2)) return x;
            &#125;
        &#125;
        return &quot;&quot;;
    &#125;
    bool check(string t, string s) &#123;
        int len &#x3D; s.length() &#x2F; t.length();
        string ans &#x3D; &quot;&quot;;
        for (int i &#x3D; 0; i &lt; len; ++i) &#123;
            ans &#x3D; ans + t;
        &#125;
        return ans &#x3D;&#x3D; s;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="1431-拥有最多糖果的孩子"><a href="#1431-拥有最多糖果的孩子" class="headerlink" title="1431. 拥有最多糖果的孩子"></a>1431. 拥有最多糖果的孩子</h3><p>问题地址：<a href="https://leetcode.cn/problems/kids-with-the-greatest-number-of-candies/">https://leetcode.cn/problems/kids-with-the-greatest-number-of-candies/</a></p>
<p>给你一个数组 candies 和一个整数 extraCandies ，其中 candies[i] 代表第 i 个孩子拥有的糖果数目。</p>
<p>对每一个孩子，检查是否存在一种方案，将额外的 extraCandies 个糖果分配给孩子们之后，此孩子有 最多 的糖果。注意，允许有多个孩子同时拥有 最多 的糖果数目。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    vector&lt;bool&gt; kidsWithCandies(vector&lt;int&gt;&amp; candies, int extraCandies) &#123;
        int n &#x3D; candies.size();
        int maxCandies &#x3D; *max_element(candies.begin(), candies.end());
        vector&lt;bool&gt; ret;
        for (int i &#x3D; 0; i &lt; n; ++i) &#123;
            ret.push_back(candies[i] + extraCandies &gt;&#x3D; maxCandies);
        &#125;
        return ret;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="605-种花问题"><a href="#605-种花问题" class="headerlink" title="605. 种花问题"></a>605. 种花问题</h3><p>问题地址：<a href="https://leetcode.cn/problems/can-place-flowers/">https://leetcode.cn/problems/can-place-flowers/</a></p>
<p>假设有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花不能种植在相邻的地块上，它们会争夺水源，两者都会死去。</p>
<p>给你一个整数数组 flowerbed 表示花坛，由若干 0 和 1 组成，其中 0 表示没种植花，1 表示种植了花。另有一个数 n ，能否在不打破种植规则的情况下种入 n 朵花？能则返回 true ，不能则返回 false 。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    bool canPlaceFlowers(vector&lt;int&gt;&amp; flowerbed, int n) &#123;
        int cnt &#x3D; 0, m &#x3D; flowerbed.size();
        for (int i &#x3D; 0; i &lt; m; ++i) &#123;
            if ((i &#x3D;&#x3D; 0 || flowerbed[i - 1] &#x3D;&#x3D; 0) &amp;&amp; flowerbed[i] &#x3D;&#x3D; 0 &amp;&amp; (i &#x3D;&#x3D; m - 1 || flowerbed[i + 1] &#x3D;&#x3D; 0)) &#123;
                cnt +&#x3D; 1;
                flowerbed[i] &#x3D; 1;
            &#125;
        &#125;
        return cnt &gt;&#x3D; n;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="345-反转字符串中的元音字母"><a href="#345-反转字符串中的元音字母" class="headerlink" title="345. 反转字符串中的元音字母"></a>345. 反转字符串中的元音字母</h3><p>问题地址：<a href="https://leetcode.cn/problems/reverse-vowels-of-a-string/">https://leetcode.cn/problems/reverse-vowels-of-a-string/</a></p>
<p>给你一个字符串 s ，仅反转字符串中的所有元音字母，并返回结果字符串。</p>
<p>元音字母包括 ‘a’、’e’、’i’、’o’、’u’，且可能以大小写两种形式出现不止一次。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    string reverseVowels(string s) &#123;
        auto isVowel &#x3D; [vowels &#x3D; &quot;aeiouAEIOU&quot;s](char ch) &#123;
            return vowels.find(ch) !&#x3D; string::npos;
        &#125;;
        int n &#x3D; s.size();
        int i &#x3D; 0, j &#x3D; n - 1;
        while (i &lt; j) &#123;
            while (i &lt; n &amp;&amp; !isVowel(s[i])) &#123;
                ++i;
            &#125;
            while (j &gt; 0 &amp;&amp; !isVowel(s[j])) &#123;
                --j;
            &#125;
            if (i &lt; j) &#123;
                swap(s[i], s[j]);
                ++i;
                --j;
            &#125;
        &#125;
        return s;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="643-子数组最大平均数-I"><a href="#643-子数组最大平均数-I" class="headerlink" title="643. 子数组最大平均数 I"></a>643. 子数组最大平均数 I</h3><p>问题地址：<a href="https://leetcode.cn/problems/maximum-average-subarray-i/">https://leetcode.cn/problems/maximum-average-subarray-i/</a></p>
<p>给你一个由 n 个元素组成的整数数组 nums 和一个整数 k 。</p>
<p>请你找出平均数最大且 长度为 k 的连续子数组，并输出该最大平均数。</p>
<p>任何误差小于 10-5 的答案都将被视为正确答案。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    double findMaxAverage(vector&lt;int&gt;&amp; nums, int k) &#123;
        int sum &#x3D; 0;
        int n &#x3D; nums.size();
        for (int i &#x3D; 0; i &lt; k; i++) &#123;
            sum +&#x3D; nums[i];
        &#125;
        int maxSum &#x3D; sum;
        for (int i &#x3D; k; i &lt; n; i++) &#123;
            sum &#x3D; sum - nums[i - k] + nums[i];
            maxSum &#x3D; max(maxSum, sum);
        &#125;
        return static_cast&lt;double&gt;(maxSum) &#x2F; k;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="1732-找到最高海拔"><a href="#1732-找到最高海拔" class="headerlink" title="1732. 找到最高海拔"></a>1732. 找到最高海拔</h3><p>问题地址：<a href="https://leetcode.cn/problems/find-the-highest-altitude/">https://leetcode.cn/problems/find-the-highest-altitude/</a></p>
<p>有一个自行车手打算进行一场公路骑行，这条路线总共由 n + 1 个不同海拔的点组成。自行车手从海拔为 0 的点 0 开始骑行。</p>
<p>给你一个长度为 n 的整数数组 gain ，其中 gain[i] 是点 i 和点 i + 1 的 净海拔高度差（0 &lt;&#x3D; i &lt; n）。请你返回 最高点的海拔 。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int largestAltitude(vector&lt;int&gt;&amp; gain) &#123;
        int ans &#x3D; 0, sum &#x3D; 0;
        for (int x : gain) &#123;
            sum +&#x3D; x;
            ans &#x3D; max(ans, sum);
        &#125;
        return ans;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="724-寻找数组的中心下标"><a href="#724-寻找数组的中心下标" class="headerlink" title="724. 寻找数组的中心下标"></a>724. 寻找数组的中心下标</h3><p>问题地址：<a href="https://leetcode.cn/problems/find-pivot-index/">https://leetcode.cn/problems/find-pivot-index/</a></p>
<p>给你一个整数数组 nums ，请计算数组的 中心下标 。</p>
<p>数组 中心下标 是数组的一个下标，其左侧所有元素相加的和等于右侧所有元素相加的和。</p>
<p>如果中心下标位于数组最左端，那么左侧数之和视为 0 ，因为在下标的左侧不存在元素。这一点对于中心下标位于数组最右端同样适用。</p>
<p>如果数组有多个中心下标，应该返回 最靠近左边 的那一个。如果数组不存在中心下标，返回 -1 。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int pivotIndex(vector&lt;int&gt;&amp; nums) &#123;
        int total &#x3D; accumulate(nums.begin(), nums.end(), 0);
        int sum &#x3D; 0;
        for (int i &#x3D; 0; i &lt; nums.size(); ++i) &#123;
            if (2 * sum + nums[i] &#x3D;&#x3D; total) &#123;
                return i;
            &#125;
            sum +&#x3D; nums[i];
        &#125;
        return -1;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="700-二叉搜索树中的搜索"><a href="#700-二叉搜索树中的搜索" class="headerlink" title="700. 二叉搜索树中的搜索"></a>700. 二叉搜索树中的搜索</h3><p>问题地址：<a href="https://leetcode.cn/problems/search-in-a-binary-search-tree/">https://leetcode.cn/problems/search-in-a-binary-search-tree/</a></p>
<p>给定二叉搜索树（BST）的根节点 root 和一个整数值 val。</p>
<p>你需要在 BST 中找到节点值等于 val 的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 null 。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;**
 * Definition for a binary tree node.
 * struct TreeNode &#123;
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;
 * &#125;;
 *&#x2F;
class Solution &#123;
public:
    TreeNode* searchBST(TreeNode* root, int val) &#123;
        if (root &#x3D;&#x3D; nullptr) return nullptr;
        if (root-&gt;val &#x3D;&#x3D; val) return root;
        return searchBST(val &lt; root-&gt;val ? root-&gt;left : root-&gt;right, val);
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="2215-找出两数组的不同"><a href="#2215-找出两数组的不同" class="headerlink" title="2215. 找出两数组的不同"></a>2215. 找出两数组的不同</h3><p>问题地址：<a href="https://leetcode.cn/problems/find-the-difference-of-two-arrays/">https://leetcode.cn/problems/find-the-difference-of-two-arrays/</a></p>
<p>给你两个下标从 0 开始的整数数组 nums1 和 nums2 ，请你返回一个长度为 2 的列表 answer ，其中：</p>
<ul>
<li>answer[0] 是 nums1 中所有 不 存在于 nums2 中的 不同 整数组成的列表。</li>
<li>answer[1] 是 nums2 中所有 不 存在于 nums1 中的 不同 整数组成的列表。</li>
</ul>
<p>注意：列表中的整数可以按 任意 顺序返回。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    vector&lt;vector&lt;int&gt;&gt; findDifference(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;
        unordered_set&lt;int&gt; set1, set2;
        for (auto num : nums1) &#123;
            set1.insert(num);
        &#125;
        for (auto num : nums2) &#123;
            set2.insert(num);
        &#125;
        vector&lt;vector&lt;int&gt;&gt; res(2);
        for (auto num : set1) &#123;
            if (!set2.count(num)) &#123;
                res[0].push_back(num);
            &#125;
        &#125;
        for (auto num : set2) &#123;
            if (!set1.count(num)) &#123;
                res[1].push_back(num);
            &#125;
        &#125;
        return res;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="1207-独一无二的出现次数"><a href="#1207-独一无二的出现次数" class="headerlink" title="1207. 独一无二的出现次数"></a>1207. 独一无二的出现次数</h3><p>问题地址：<a href="https://leetcode.cn/problems/unique-number-of-occurrences/">https://leetcode.cn/problems/unique-number-of-occurrences/</a></p>
<p>给你一个整数数组 arr，请你帮忙统计数组中每个数的出现次数。</p>
<p>如果每个数的出现次数都是独一无二的，就返回 true；否则返回 false。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    bool uniqueOccurrences(vector&lt;int&gt;&amp; arr) &#123;
        unordered_map&lt;int, int&gt; occur;
        for (const auto&amp; x : arr) &#123;
            occur[x]++;
        &#125;
        unordered_set&lt;int&gt; times;
        for (const auto&amp; x : occur) &#123;
            times.insert(x.second);
        &#125;
        return times.size() &#x3D;&#x3D; occur.size();
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="933-最近的请求次数"><a href="#933-最近的请求次数" class="headerlink" title="933. 最近的请求次数"></a>933. 最近的请求次数</h3><p>问题地址：<a href="https://leetcode.cn/problems/number-of-recent-calls/">https://leetcode.cn/problems/number-of-recent-calls/</a></p>
<p>写一个 RecentCounter 类来计算特定时间范围内最近的请求。</p>
<p>请你实现 RecentCounter 类：</p>
<ul>
<li>RecentCounter() 初始化计数器，请求数为 0 。</li>
<li>int ping(int t) 在时间 t 添加一个新请求，其中 t 表示以毫秒为单位的某个时间，并返回过去 3000 毫秒内发生的所有请求数（包括新请求）。确切地说，返回在 [t-3000, t] 内发生的请求数。</li>
</ul>
<p>保证 每次对 ping 的调用都使用比之前更大的 t 值。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class RecentCounter &#123;
private:
    queue&lt;int&gt; q;
public:
    RecentCounter() &#123;&#125;
    
    int ping(int t) &#123;
        q.push(t);
        while ( q.front() &lt; t - 3000) &#123;
            q.pop();
        &#125;
        return q.size();
    &#125;
&#125;;

&#x2F;**
 * Your RecentCounter object will be instantiated and called as such:
 * RecentCounter* obj &#x3D; new RecentCounter();
 * int param_1 &#x3D; obj-&gt;ping(t);
 *&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="872-叶子相似的树"><a href="#872-叶子相似的树" class="headerlink" title="872. 叶子相似的树"></a>872. 叶子相似的树</h3><p>问题地址：<a href="https://leetcode.cn/problems/leaf-similar-trees/">https://leetcode.cn/problems/leaf-similar-trees/</a></p>
<p>请考虑一棵二叉树上所有的叶子，这些叶子的值按从左到右的顺序排列形成一个 叶值序列 。</p>
<p><img src="https://cos.luyf-lemon-love.space/images/20231121214116.png"></p>
<p>举个例子，如上图所示，给定一棵叶值序列为 (6, 7, 4, 9, 8) 的树。</p>
<p>如果有两棵二叉树的叶值序列是相同，那么我们就认为它们是 叶相似 的。</p>
<p>如果给定的两个根结点分别为 root1 和 root2 的树是叶相似的，则返回 true；否则返回 false 。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;**
 * Definition for a binary tree node.
 * struct TreeNode &#123;
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;
 * &#125;;
 *&#x2F;
class Solution &#123;
public:
    bool leafSimilar(TreeNode* root1, TreeNode* root2) &#123;
        vector&lt;int&gt; seq1;
        if (root1) &#123;
            dfs(root1, seq1);
        &#125;
        vector&lt;int&gt; seq2;
        if (root2) &#123;
            dfs(root2, seq2);
        &#125;
        return seq1 &#x3D;&#x3D; seq2;
    &#125;
    void dfs(TreeNode* node, vector&lt;int&gt;&amp; seq) &#123;
        if (!node-&gt;left &amp;&amp; !node-&gt;right) &#123;
            seq.push_back(node-&gt;val);
        &#125; else &#123;
            if (node-&gt;left) &#123;
                dfs(node-&gt;left, seq);
            &#125;
            if (node-&gt;right) &#123;
                dfs(node-&gt;right, seq);
            &#125;
        &#125;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="338-比特位计数"><a href="#338-比特位计数" class="headerlink" title="338. 比特位计数"></a>338. 比特位计数</h3><p>问题地址：<a href="https://leetcode.cn/problems/counting-bits/">https://leetcode.cn/problems/counting-bits/</a></p>
<p>给你一个整数 n ，对于 0 &lt;&#x3D; i &lt;&#x3D; n 中的每个 i ，计算其二进制表示中 1 的个数 ，返回一个长度为 n + 1 的数组 ans 作为答案。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    vector&lt;int&gt; countBits(int n) &#123;
        vector&lt;int&gt; bits(n + 1);
        for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;
            bits[i] &#x3D; bits[i &gt;&gt; 1] + (i &amp; 1);
        &#125;
        return bits;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="374-猜数字大小"><a href="#374-猜数字大小" class="headerlink" title="374. 猜数字大小"></a>374. 猜数字大小</h3><p>问题地址：<a href="https://leetcode.cn/problems/guess-number-higher-or-lower/">https://leetcode.cn/problems/guess-number-higher-or-lower/</a></p>
<p>猜数字游戏的规则如下：</p>
<ul>
<li>每轮游戏，我都会从 1 到 n 随机选择一个数字。 请你猜选出的是哪个数字。</li>
<li>如果你猜错了，我会告诉你，你猜测的数字比我选出的数字是大了还是小了。</li>
</ul>
<p>你可以通过调用一个预先定义好的接口 int guess(int num) 来获取猜测结果，返回值一共有 3 种可能的情况（-1，1 或 0）：</p>
<ul>
<li>-1：我选出的数字比你猜的数字小 pick &lt; num</li>
<li>1：我选出的数字比你猜的数字大 pick &gt; num</li>
<li>0：我选出的数字和你猜的数字一样。恭喜！你猜对了！pick &#x3D;&#x3D; num</li>
</ul>
<p>返回我选出的数字。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;** 
 * Forward declaration of guess API.
 * @param  num   your guess
 * @return 	     -1 if num is higher than the picked number
 *			      1 if num is lower than the picked number
 *               otherwise return 0
 * int guess(int num);
 *&#x2F;

class Solution &#123;
public:
    int guessNumber(int n) &#123;
        int left &#x3D; 1, right &#x3D; n;
        while (left &lt; right) &#123;
            int mid &#x3D; left + (right - left) &#x2F; 2;
            if (guess(mid) &lt;&#x3D; 0) &#123;
                right &#x3D; mid;
            &#125; else &#123;
                left &#x3D; mid + 1;
            &#125;
        &#125;
        return right;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="1137-第-N-个泰波那契数"><a href="#1137-第-N-个泰波那契数" class="headerlink" title="1137. 第 N 个泰波那契数"></a>1137. 第 N 个泰波那契数</h3><p>问题地址：<a href="https://leetcode.cn/problems/n-th-tribonacci-number/">https://leetcode.cn/problems/n-th-tribonacci-number/</a></p>
<p>泰波那契序列 Tn 定义如下： </p>
<p>T0 &#x3D; 0, T1 &#x3D; 1, T2 &#x3D; 1, 且在 n &gt;&#x3D; 0 的条件下 Tn+3 &#x3D; Tn + Tn+1 + Tn+2</p>
<p>给你整数 n，请返回第 n 个泰波那契数 Tn 的值。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int tribonacci(int n) &#123;
        if (n &#x3D;&#x3D; 0) &#123;
            return 0;
        &#125;
        if (n &lt;&#x3D; 2) &#123;
            return 1;
        &#125;
        int p &#x3D; 0, q &#x3D; 0, r &#x3D; 1, s &#x3D; 1;
        for (int i &#x3D; 3; i &lt;&#x3D; n; ++i) &#123;
            p &#x3D; q;
            q &#x3D; r;
            r &#x3D; s;
            s &#x3D; p + q + r;
        &#125;
        return s;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="746-使用最小花费爬楼梯"><a href="#746-使用最小花费爬楼梯" class="headerlink" title="746. 使用最小花费爬楼梯"></a>746. 使用最小花费爬楼梯</h3><p>问题地址：<a href="https://leetcode.cn/problems/min-cost-climbing-stairs/">https://leetcode.cn/problems/min-cost-climbing-stairs/</a></p>
<p>给你一个整数数组 cost ，其中 cost[i] 是从楼梯第 i 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。</p>
<p>你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。</p>
<p>请你计算并返回达到楼梯顶部的最低花费。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int minCostClimbingStairs(vector&lt;int&gt;&amp; cost) &#123;
        int n &#x3D; cost.size();
        vector&lt;int&gt; dp(n + 1);
        dp[0] &#x3D; dp[0] &#x3D; 0;
        for (int i &#x3D; 2; i &lt;&#x3D; n; i++) &#123;
            dp[i] &#x3D; min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);
        &#125;
        return dp[n];
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="面试题-01-01-判定字符是否唯一"><a href="#面试题-01-01-判定字符是否唯一" class="headerlink" title="面试题 01.01. 判定字符是否唯一"></a>面试题 01.01. 判定字符是否唯一</h3><p>问题地址：<a href="https://leetcode.cn/problems/is-unique-lcci/">https://leetcode.cn/problems/is-unique-lcci/</a></p>
<p>实现一个算法，确定一个字符串 s 的所有字符是否全都不同。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    bool isUnique(string astr) &#123;
        int x &#x3D; 0;
        for (int i &#x3D; 0; i &lt; astr.size(); i++) &#123;
            if (x &amp; (1 &lt;&lt; (astr[i] - &#39;a&#39;))) &#123;
                return false;
            &#125; else &#123;
                x |&#x3D; (1 &lt;&lt; (astr[i] - &#39;a&#39;));
            &#125;
        &#125;
        return true;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="面试题-01-02-判定是否互为字符重排"><a href="#面试题-01-02-判定是否互为字符重排" class="headerlink" title="面试题 01.02. 判定是否互为字符重排"></a>面试题 01.02. 判定是否互为字符重排</h3><p>问题地址：<a href="https://leetcode.cn/problems/check-permutation-lcci/">https://leetcode.cn/problems/check-permutation-lcci/</a></p>
<p>给定两个由小写字母组成的字符串 s1 和 s2，请编写一个程序，确定其中一个字符串的字符重新排列后，能否变成另一个字符串。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    bool CheckPermutation(string s1, string s2) &#123;
        if (s1.length() !&#x3D; s2.length()) &#123;
            return false;
        &#125;
        sort(s1.begin(), s1.end());
        sort(s2.begin(), s2.end());
        return s1 &#x3D;&#x3D; s2;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="面试题-01-03-URL化"><a href="#面试题-01-03-URL化" class="headerlink" title="面试题 01.03. URL化"></a>面试题 01.03. URL化</h3><p>问题地址：<a href="https://leetcode.cn/problems/string-to-url-lcci/">https://leetcode.cn/problems/string-to-url-lcci/</a></p>
<p>URL化。编写一种方法，将字符串中的空格全部替换为%20。假定该字符串尾部有足够的空间存放新增字符，并且知道字符串的“真实”长度。（注：用Java实现的话，请使用字符数组实现，以便直接在数组上操作。）</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    string replaceSpaces(string S, int length) &#123;
        int idx &#x3D; S.size() - 1;
        for (int i &#x3D; length - 1; i &gt;&#x3D; 0; i--) &#123;
            if (S[i] &#x3D;&#x3D; &#39; &#39;) &#123;
                S[idx] &#x3D; &#39;0&#39;;
                S[idx - 1] &#x3D; &#39;2&#39;;
                S[idx - 2] &#x3D; &#39;%&#39;;
                idx -&#x3D; 3;
            &#125; else &#123;
                S[idx] &#x3D; S[i];
                idx--;
            &#125;
        &#125;
        S &#x3D; S.substr(idx + 1);
        return S;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="面试题-01-04-回文排列"><a href="#面试题-01-04-回文排列" class="headerlink" title="面试题 01.04. 回文排列"></a>面试题 01.04. 回文排列</h3><p>问题地址：<a href="https://leetcode.cn/problems/palindrome-permutation-lcci/">https://leetcode.cn/problems/palindrome-permutation-lcci/</a></p>
<p>给定一个字符串，编写一个函数判定其是否为某个回文串的排列之一。</p>
<p>回文串是指正反两个方向都一样的单词或短语。排列是指字母的重新排列。</p>
<p>回文串不一定是字典当中的单词。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    bool canPermutePalindrome(string s) &#123;
        unordered_map&lt;char, int&gt; dict;
        for (auto c : s) &#123;
            dict[c] +&#x3D; 1;
        &#125;
        int odd &#x3D; 0;
        for (auto item : dict) &#123;
            if (item.second % 2 &#x3D;&#x3D; 1) &#123;
                if (++odd &gt; 1) &#123;
                    return false;
                &#125;
            &#125;
        &#125;
        return true;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="面试题-01-06-字符串压缩"><a href="#面试题-01-06-字符串压缩" class="headerlink" title="面试题 01.06. 字符串压缩"></a>面试题 01.06. 字符串压缩</h3><p>问题地址：<a href="https://leetcode.cn/problems/compress-string-lcci/">https://leetcode.cn/problems/compress-string-lcci/</a></p>
<p>字符串压缩。利用字符重复出现的次数，编写一种方法，实现基本的字符串压缩功能。比如，字符串aabcccccaaa会变为a2b1c5a3。若“压缩”后的字符串没有变短，则返回原先的字符串。你可以假设字符串中只包含大小写英文字母（a至z）。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    string compressString(string S) &#123;
        if (S.length() &#x3D;&#x3D; 0) return S;
        string ans &#x3D; &quot;&quot;;
        int cnt &#x3D; 1;
        char ch &#x3D; S[0];
        for (int i &#x3D; 1; i &lt; S.length(); ++i) &#123;
            if (ch &#x3D;&#x3D; S[i]) cnt++;
            else &#123;
                ans +&#x3D; ch + to_string(cnt);
                ch &#x3D; S[i];
                cnt &#x3D; 1;
            &#125;
        &#125;
        ans +&#x3D; ch + to_string(cnt);
        return ans.length() &gt;&#x3D; S.length() ? S : ans;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="面试题-01-09-字符串轮转"><a href="#面试题-01-09-字符串轮转" class="headerlink" title="面试题 01.09. 字符串轮转"></a>面试题 01.09. 字符串轮转</h3><p>问题地址：<a href="https://leetcode.cn/problems/string-rotation-lcci/">https://leetcode.cn/problems/string-rotation-lcci/</a></p>
<p>字符串轮转。给定两个字符串s1和s2，请编写代码检查s2是否为s1旋转而成（比如，waterbottle是erbottlewat旋转后的字符串）。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    bool isFlipedString(string s1, string s2) &#123;
        return s1.size() &#x3D;&#x3D; s2.size() &amp;&amp; (s1 + s1).find(s2) !&#x3D; string::npos;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="面试题-02-01-移除重复节点"><a href="#面试题-02-01-移除重复节点" class="headerlink" title="面试题 02.01. 移除重复节点"></a>面试题 02.01. 移除重复节点</h3><p>问题地址：<a href="https://leetcode.cn/problems/remove-duplicate-node-lcci/">https://leetcode.cn/problems/remove-duplicate-node-lcci/</a></p>
<p>编写代码，移除未排序链表中的重复节点。保留最开始出现的节点。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;**
 * Definition for singly-linked list.
 * struct ListNode &#123;
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) &#123;&#125;
 * &#125;;
 *&#x2F;
class Solution &#123;
public:
    ListNode* removeDuplicateNodes(ListNode* head) &#123;
        if (head &#x3D;&#x3D; nullptr) &#123;
            return head;
        &#125;
        unordered_set&lt;int&gt; occurred &#x3D; &#123;head-&gt;val&#125;;
        ListNode* pos &#x3D; head;
        while (pos-&gt;next !&#x3D; nullptr) &#123;
            auto cur &#x3D; pos-&gt;next;
            if (!occurred.count(cur-&gt;val)) &#123;
                occurred.insert(cur-&gt;val);
                pos &#x3D; pos-&gt;next;
            &#125; else &#123;
                pos-&gt;next &#x3D; pos-&gt;next-&gt;next;
            &#125;
        &#125;
        pos-&gt;next &#x3D; nullptr;
        return head;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="面试题-02-02-返回倒数第-k-个节点"><a href="#面试题-02-02-返回倒数第-k-个节点" class="headerlink" title="面试题 02.02. 返回倒数第 k 个节点"></a>面试题 02.02. 返回倒数第 k 个节点</h3><p>问题地址：<a href="https://leetcode.cn/problems/kth-node-from-end-of-list-lcci/">https://leetcode.cn/problems/kth-node-from-end-of-list-lcci/</a></p>
<p>实现一种算法，找出单向链表中倒数第 k 个节点。返回该节点的值。</p>
<p>注意：本题相对原题稍作改动</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;**
 * Definition for singly-linked list.
 * struct ListNode &#123;
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) &#123;&#125;
 * &#125;;
 *&#x2F;
class Solution &#123;
public:
    int kthToLast(ListNode* head, int k) &#123;
        ListNode* pre &#x3D; head, *cur &#x3D; head;
        for (int i &#x3D; 0; i &lt; k; i++) &#123;
            cur &#x3D; cur-&gt;next;
        &#125;
        while (cur !&#x3D; nullptr) &#123;
            pre &#x3D; pre-&gt;next;
            cur &#x3D; cur-&gt;next;
        &#125;
        return pre-&gt;val;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="面试题-02-03-删除中间节点"><a href="#面试题-02-03-删除中间节点" class="headerlink" title="面试题 02.03. 删除中间节点"></a>面试题 02.03. 删除中间节点</h3><p>问题地址：<a href="https://leetcode.cn/problems/delete-middle-node-lcci/">https://leetcode.cn/problems/delete-middle-node-lcci/</a></p>
<p>若链表中的某个节点，既不是链表头节点，也不是链表尾节点，则称其为该链表的「中间节点」。</p>
<p>假定已知链表的某一个中间节点，请实现一种算法，将该节点从链表中删除。</p>
<p>例如，传入节点 c（位于单向链表 a-&gt;b-&gt;c-&gt;d-&gt;e-&gt;f 中），将其删除后，剩余链表为 a-&gt;b-&gt;d-&gt;e-&gt;f</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;**
 * Definition for singly-linked list.
 * struct ListNode &#123;
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) &#123;&#125;
 * &#125;;
 *&#x2F;
class Solution &#123;
public:
    void deleteNode(ListNode* node) &#123;
        node-&gt;val &#x3D; node-&gt;next-&gt;val;
        node-&gt;next &#x3D; node-&gt;next-&gt;next;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="面试题-02-06-回文链表"><a href="#面试题-02-06-回文链表" class="headerlink" title="面试题 02.06. 回文链表"></a>面试题 02.06. 回文链表</h3><p>问题地址：<a href="https://leetcode.cn/problems/palindrome-linked-list-lcci/">https://leetcode.cn/problems/palindrome-linked-list-lcci/</a></p>
<p>编写一个函数，检查输入的链表是否是回文的。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;**
 * Definition for singly-linked list.
 * struct ListNode &#123;
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) &#123;&#125;
 * &#125;;
 *&#x2F;
class Solution &#123;
public:
    bool isPalindrome(ListNode* head) &#123;
        vector&lt;int&gt; vals;
        while (head !&#x3D; nullptr) &#123;
            vals.emplace_back(head-&gt;val);
            head &#x3D; head-&gt;next;
        &#125;
        for (int i &#x3D; 0, j &#x3D; vals.size() - 1; i &lt; j; ++i, --j) &#123;
            if (vals[i] !&#x3D; vals[j]) &#123;
                return false;
            &#125;
        &#125;
        return true;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="面试题-02-07-链表相交"><a href="#面试题-02-07-链表相交" class="headerlink" title="面试题 02.07. 链表相交"></a>面试题 02.07. 链表相交</h3><p>问题地址：<a href="https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/">https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/</a></p>
<p>给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;**
 * Definition for singly-linked list.
 * struct ListNode &#123;
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) &#123;&#125;
 * &#125;;
 *&#x2F;
class Solution &#123;
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123;
        unordered_set&lt;ListNode*&gt; visited;
        ListNode* temp &#x3D; headA;
        while (temp !&#x3D; nullptr) &#123;
            visited.insert(temp);
            temp &#x3D; temp-&gt;next;
        &#125;
        temp &#x3D; headB;
        while (temp !&#x3D; nullptr) &#123;
            if (visited.count(temp)) &#123;
                return temp;
            &#125;
            temp &#x3D; temp-&gt;next;
        &#125;
        return nullptr;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="面试题-03-02-栈的最小值"><a href="#面试题-03-02-栈的最小值" class="headerlink" title="面试题 03.02. 栈的最小值"></a>面试题 03.02. 栈的最小值</h3><p>问题地址：<a href="https://leetcode.cn/problems/min-stack-lcci/">https://leetcode.cn/problems/min-stack-lcci/</a></p>
<p>请设计一个栈，除了常规栈支持的pop与push函数以外，还支持min函数，该函数返回栈元素中的最小值。执行push、pop和min操作的时间复杂度必须为O(1)。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class MinStack &#123;
private:
    stack&lt;int&gt; x_stack;
    stack&lt;int&gt; min_stack;
public:
    &#x2F;** initialize your data structure here. *&#x2F;
    MinStack() &#123;
        min_stack.push(INT_MAX);
    &#125;
    
    void push(int x) &#123;
        x_stack.push(x);
        min_stack.push(min(min_stack.top(), x));
    &#125;
    
    void pop() &#123;
        x_stack.pop();
        min_stack.pop();
    &#125;
    
    int top() &#123;
        return x_stack.top();
    &#125;
    
    int getMin() &#123;
        return min_stack.top();
    &#125;
&#125;;

&#x2F;**
 * Your MinStack object will be instantiated and called as such:
 * MinStack* obj &#x3D; new MinStack();
 * obj-&gt;push(x);
 * obj-&gt;pop();
 * int param_3 &#x3D; obj-&gt;top();
 * int param_4 &#x3D; obj-&gt;getMin();
 *&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="面试题-03-04-化栈为队"><a href="#面试题-03-04-化栈为队" class="headerlink" title="面试题 03.04. 化栈为队"></a>面试题 03.04. 化栈为队</h3><p>问题地址：<a href="https://leetcode.cn/problems/implement-queue-using-stacks-lcci/">https://leetcode.cn/problems/implement-queue-using-stacks-lcci/</a></p>
<p>实现一个MyQueue类，该类用两个栈来实现一个队列。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class MyQueue &#123;
private:
    stack&lt;int&gt; inStack, outStack;
    void in2out() &#123;
        while (!inStack.empty()) &#123;
            outStack.push(inStack.top());
            inStack.pop();
        &#125;
    &#125;
public:
    &#x2F;** Initialize your data structure here. *&#x2F;
    MyQueue() &#123;&#125;
    
    &#x2F;** Push element x to the back of queue. *&#x2F;
    void push(int x) &#123;
        inStack.push(x);
    &#125;
    
    &#x2F;** Removes the element from in front of queue and returns that element. *&#x2F;
    int pop() &#123;
        if (outStack.empty()) &#123;
            in2out();
        &#125;
        int x &#x3D; outStack.top();
        outStack.pop();
        return x;
    &#125;
    
    &#x2F;** Get the front element. *&#x2F;
    int peek() &#123;
        if (outStack.empty()) &#123;
            in2out();
        &#125;
        return outStack.top();
    &#125;
    
    &#x2F;** Returns whether the queue is empty. *&#x2F;
    bool empty() &#123;
        return inStack.empty() &amp;&amp; outStack.empty();
    &#125;
&#125;;

&#x2F;**
 * Your MyQueue object will be instantiated and called as such:
 * MyQueue* obj &#x3D; new MyQueue();
 * obj-&gt;push(x);
 * int param_2 &#x3D; obj-&gt;pop();
 * int param_3 &#x3D; obj-&gt;peek();
 * bool param_4 &#x3D; obj-&gt;empty();
 *&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="面试题-03-06-动物收容所"><a href="#面试题-03-06-动物收容所" class="headerlink" title="面试题 03.06. 动物收容所"></a>面试题 03.06. 动物收容所</h3><p>问题地址：<a href="https://leetcode.cn/problems/animal-shelter-lcci/">https://leetcode.cn/problems/animal-shelter-lcci/</a></p>
<p>动物收容所。有家动物收容所只收容狗与猫，且严格遵守“先进先出”的原则。在收养该收容所的动物时，收养人只能收养所有动物中“最老”（由其进入收容所的时间长短而定）的动物，或者可以挑选猫或狗（同时必须收养此类动物中“最老”的）。换言之，收养人不能自由挑选想收养的对象。请创建适用于这个系统的数据结构，实现各种操作方法，比如enqueue、dequeueAny、dequeueDog和dequeueCat。允许使用Java内置的LinkedList数据结构。</p>
<p>enqueue方法有一个animal参数，animal[0]代表动物编号，animal[1]代表动物种类，其中 0 代表猫，1 代表狗。</p>
<p>dequeue*方法返回一个列表[动物编号, 动物种类]，若没有可以收养的动物，则返回[-1,-1]。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class AnimalShelf &#123;
public:
    queue&lt;int&gt; cat;
    queue&lt;int&gt; dog;
    AnimalShelf() &#123;

    &#125;
    
    void enqueue(vector&lt;int&gt; animal) &#123;
        if (animal[1] &#x3D;&#x3D; 0) cat.push(animal[0]);
        else dog.push(animal[0]);
    &#125;
    
    vector&lt;int&gt; dequeueAny() &#123;
        vector&lt;int&gt; res &#x3D; &#123;-1, -1&#125;;
        if (cat.empty() &amp;&amp; dog.empty()) return res;
        if (dog.empty())
        &#123;
            res &#x3D; &#123;cat.front(), 0&#125;;
            cat.pop();
            return res;
        &#125;
        if (cat.empty())
        &#123;
            res &#x3D; &#123;dog.front(), 1&#125;;
            dog.pop();
            return res;
        &#125;

        if (cat.front() &lt; dog.front())
        &#123;
            res &#x3D; &#123;cat.front(), 0&#125;;
            cat.pop();
            return res;
        &#125;

        if (cat.front() &gt; dog.front())
        &#123;
            res &#x3D; &#123;dog.front(), 1&#125;;
            dog.pop();
            return res;
        &#125;
        return res;
    &#125;
    
    vector&lt;int&gt; dequeueDog() &#123;
        vector&lt;int&gt; res &#x3D; &#123;-1, -1&#125;;
        if (dog.empty()) return res;
        res &#x3D; &#123;dog.front(), 1&#125;;
        dog.pop();
        return res;
    &#125;
    
    vector&lt;int&gt; dequeueCat() &#123;
        vector&lt;int&gt; res &#x3D; &#123;-1, -1&#125;;
        if (cat.empty()) return res;
        res &#x3D; &#123;cat.front(), 0&#125;;
        cat.pop();
        return res;
    &#125;
&#125;;

&#x2F;**
 * Your AnimalShelf object will be instantiated and called as such:
 * AnimalShelf* obj &#x3D; new AnimalShelf();
 * obj-&gt;enqueue(animal);
 * vector&lt;int&gt; param_2 &#x3D; obj-&gt;dequeueAny();
 * vector&lt;int&gt; param_3 &#x3D; obj-&gt;dequeueDog();
 * vector&lt;int&gt; param_4 &#x3D; obj-&gt;dequeueCat();
 *&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="面试题-04-02-最小高度树"><a href="#面试题-04-02-最小高度树" class="headerlink" title="面试题 04.02. 最小高度树"></a>面试题 04.02. 最小高度树</h3><p>问题地址：<a href="https://leetcode.cn/problems/minimum-height-tree-lcci/">https://leetcode.cn/problems/minimum-height-tree-lcci/</a></p>
<p>给定一个有序整数数组，元素各不相同且按升序排列，编写一个算法，创建一棵高度最小的二叉搜索树。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;**
 * Definition for a binary tree node.
 * struct TreeNode &#123;
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;
 * &#125;;
 *&#x2F;
class Solution &#123;
public:
    TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) &#123;
        return helper(nums, 0, nums.size() - 1);
    &#125;
    TreeNode* helper(vector&lt;int&gt;&amp; nums, int left, int right) &#123;
        if (left &gt; right) &#123;
            return nullptr;
        &#125;
        int mid &#x3D; (left + right) &#x2F; 2;
        auto root &#x3D; new TreeNode(nums[mid]);
        root-&gt;left &#x3D; helper(nums, left, mid - 1);
        root-&gt;right &#x3D; helper(nums, mid + 1, right);
        return root;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="面试题-04-04-检查平衡性"><a href="#面试题-04-04-检查平衡性" class="headerlink" title="面试题 04.04. 检查平衡性"></a>面试题 04.04. 检查平衡性</h3><p>问题地址：<a href="https://leetcode.cn/problems/check-balance-lcci/">https://leetcode.cn/problems/check-balance-lcci/</a></p>
<p>实现一个函数，检查二叉树是否平衡。在这个问题中，平衡树的定义如下：任意一个节点，其两棵子树的高度差不超过 1。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;**
 * Definition for a binary tree node.
 * struct TreeNode &#123;
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;
 * &#125;;
 *&#x2F;
class Solution &#123;
public:
    bool isBalanced(TreeNode* root) &#123;
        if (root &#x3D;&#x3D; nullptr) &#123;
            return true;
        &#125; else &#123;
            return abs(height(root-&gt;left) - height(root-&gt;right)) &lt;&#x3D; 1 &amp;&amp;
                   isBalanced(root-&gt;left) &amp;&amp;
                   isBalanced(root-&gt;right);
        &#125;
    &#125;
    int height(TreeNode* root) &#123;
        if (root &#x3D;&#x3D; nullptr) &#123;
            return 0;
        &#125; else &#123;
            return max(height(root-&gt;left), height(root-&gt;right)) + 1;
        &#125;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="面试题-05-01-插入"><a href="#面试题-05-01-插入" class="headerlink" title="面试题 05.01. 插入"></a>面试题 05.01. 插入</h3><p>问题地址：<a href="https://leetcode.cn/problems/insert-into-bits-lcci/">https://leetcode.cn/problems/insert-into-bits-lcci/</a></p>
<p>给定两个整型数字 N 与 M，以及表示比特位置的 i 与 j（i &lt;&#x3D; j，且从 0 位开始计算）。</p>
<p>编写一种方法，使 M 对应的二进制数字插入 N 对应的二进制数字的第 i ~ j 位区域，不足之处用 0 补齐。具体插入过程如图所示。</p>
<p><img src="https://cos.luyf-lemon-love.space/images/20231215214055.png"></p>
<p>题目保证从 i 位到 j 位足以容纳 M， 例如： M &#x3D; 10011，则 i～j 区域至少可容纳 5 位。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int insertBits(int N, int M, int i, int j) &#123;
        for (int k &#x3D; i; k &lt;&#x3D; j; ++k) &#123;
            N &amp;&#x3D; ~(1 &lt;&lt; k);
        &#125;
        return N + (M &lt;&lt; i);
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="面试题-05-03-翻转数位"><a href="#面试题-05-03-翻转数位" class="headerlink" title="面试题 05.03. 翻转数位"></a>面试题 05.03. 翻转数位</h3><p>问题地址：<a href="https://leetcode.cn/problems/reverse-bits-lcci/">https://leetcode.cn/problems/reverse-bits-lcci/</a></p>
<p>给定一个32位整数 num，你可以将一个数位从0变为1。请编写一个程序，找出你能够获得的最长的一串1的长度。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int reverseBits(int num) &#123;
        bitset&lt;32&gt; bst(num);
        int cnt1 &#x3D; 0, cnt2 &#x3D; 0;
        bool flag &#x3D; false;
        int ans &#x3D; 1;
        int i &#x3D; 0;
        while (i &lt; 32) &#123;
            cnt2 &#x3D; 0;
            while (i &lt; 32 &amp;&amp; bst[i]) &#123;
                ++i;
                ++cnt2;
            &#125;
            ans &#x3D; max(ans, flag ? (cnt1 + cnt2 + 1) : (cnt2 + 1));
            cnt1 &#x3D; cnt2;
            cnt2 &#x3D; 0;
            while (i &lt; 32 &amp;&amp; !bst[i]) &#123;
                ++i;
                ++cnt2;
            &#125;
            flag &#x3D; cnt2 &#x3D;&#x3D; 1;
        &#125;
        return min(ans, 32);
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="面试题-05-06-整数转换"><a href="#面试题-05-06-整数转换" class="headerlink" title="面试题 05.06. 整数转换"></a>面试题 05.06. 整数转换</h3><p>问题地址：<a href="https://leetcode.cn/problems/convert-integer-lcci/">https://leetcode.cn/problems/convert-integer-lcci/</a></p>
<p>整数转换。编写一个函数，确定需要改变几个位才能将整数A转成整数B。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int convertInteger(int A, int B) &#123;
        int res &#x3D; 0;
        for (unsigned c &#x3D; A ^ B; c !&#x3D; 0; c &#x3D; c &gt;&gt; 1) &#123;
            res +&#x3D; c &amp; 1;
        &#125;
        return res;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="面试题-08-01-三步问题"><a href="#面试题-08-01-三步问题" class="headerlink" title="面试题 08.01. 三步问题"></a>面试题 08.01. 三步问题</h3><p>问题地址：<a href="https://leetcode.cn/problems/three-steps-problem-lcci/">https://leetcode.cn/problems/three-steps-problem-lcci/</a></p>
<p>三步问题。有个小孩正在上楼梯，楼梯有n阶台阶，小孩一次可以上1阶、2阶或3阶。实现一种方法，计算小孩有多少种上楼梯的方式。结果可能很大，你需要对结果模1000000007。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int waysToStep(int n) &#123;
        if (n &lt;&#x3D; 2) return n;
        vector&lt;int&gt; dp(n + 1, 0);
        dp[1] &#x3D; 1, dp[2] &#x3D; 2, dp[3] &#x3D; 4;
        for (auto i &#x3D; 4; i &lt; dp.size(); ++i) &#123;
            dp[i] &#x3D; ((dp[i - 1] + dp[i - 2]) % 1000000007 + dp[i - 3]) % 1000000007;
        &#125;
        return dp.back();
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="面试题-08-03-魔术索引"><a href="#面试题-08-03-魔术索引" class="headerlink" title="面试题 08.03. 魔术索引"></a>面试题 08.03. 魔术索引</h3><p>问题地址：<a href="https://leetcode.cn/problems/magic-index-lcci/">https://leetcode.cn/problems/magic-index-lcci/</a></p>
<p>魔术索引。 在数组A[0…n-1]中，有所谓的魔术索引，满足条件A[i] &#x3D; i。给定一个有序整数数组，编写一种方法找出魔术索引，若有的话，在数组A中找出一个魔术索引，如果没有，则返回-1。若有多个魔术索引，返回索引值最小的一个。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int findMagicIndex(vector&lt;int&gt;&amp; nums) &#123;
        return getAnswer(nums, 0, nums.size() - 1);
    &#125;
    int getAnswer(vector&lt;int&gt;&amp; nums, int left, int right) &#123;
        if (left &gt; right) &#123;
            return -1;
        &#125;
        int mid &#x3D; left + (right - left) &#x2F; 2;
        int leftAnswer &#x3D; getAnswer(nums, left, mid - 1);
        if (leftAnswer !&#x3D; -1) &#123;
            return leftAnswer;
        &#125; else if (nums[mid] &#x3D;&#x3D; mid) &#123;
            return mid;
        &#125;
        return getAnswer(nums, mid + 1, right);
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="面试题-08-06-汉诺塔问题"><a href="#面试题-08-06-汉诺塔问题" class="headerlink" title="面试题 08.06. 汉诺塔问题"></a>面试题 08.06. 汉诺塔问题</h3><p>问题地址：<a href="https://leetcode.cn/problems/hanota-lcci/">https://leetcode.cn/problems/hanota-lcci/</a></p>
<p>在经典汉诺塔问题中，有 3 根柱子及 N 个不同大小的穿孔圆盘，盘子可以滑入任意一根柱子。一开始，所有盘子自上而下按升序依次套在第一根柱子上(即每一个盘子只能放在更大的盘子上面)。移动圆盘时受到以下限制:<br>(1) 每次只能移动一个盘子;<br>(2) 盘子只能从柱子顶端滑出移到下一根柱子;<br>(3) 盘子只能叠在比它大的盘子上。</p>
<p>请编写程序，用栈将所有盘子从第一根柱子移到最后一根柱子。</p>
<p>你需要原地修改栈。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    void hanota(vector&lt;int&gt;&amp; A, vector&lt;int&gt;&amp; B, vector&lt;int&gt;&amp; C) &#123;
        int n &#x3D; A.size();
        move(n, A, B, C);
    &#125;
    void move(int n, vector&lt;int&gt;&amp; A, vector&lt;int&gt;&amp; B, vector&lt;int&gt;&amp; C) &#123;
        if (n &#x3D;&#x3D; 1) &#123;
            C.push_back(A.back());
            A.pop_back();
            return;
        &#125;
        move(n - 1, A, C, B);
        C.push_back(A.back());
        A.pop_back();
        move(n - 1, B, A, C);
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="面试题-08-10-颜色填充"><a href="#面试题-08-10-颜色填充" class="headerlink" title="面试题 08.10. 颜色填充"></a>面试题 08.10. 颜色填充</h3><p>问题地址：<a href="https://leetcode.cn/problems/color-fill-lcci/">https://leetcode.cn/problems/color-fill-lcci/</a></p>
<p>编写函数，实现许多图片编辑软件都支持的「颜色填充」功能。</p>
<p>待填充的图像用二维数组 image 表示，元素为初始颜色值。初始坐标点的行坐标为 sr 列坐标为 sc。需要填充的新颜色为 newColor 。</p>
<p>「周围区域」是指颜色相同且在上、下、左、右四个方向上存在相连情况的若干元素。</p>
<p>请用新颜色填充初始坐标点的周围区域，并返回填充后的图像。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
private:
    const int dx[4] &#x3D; &#123;1, 0, 0, -1&#125;;
    const int dy[4] &#x3D; &#123;0, 1, -1, 0&#125;;
public:
    vector&lt;vector&lt;int&gt;&gt; floodFill(vector&lt;vector&lt;int&gt;&gt;&amp; image, int sr, int sc, int newColor) &#123;
        int currColor &#x3D; image[sr][sc];
        if (currColor !&#x3D; newColor) &#123;
            dfs(image, sr, sc, currColor, newColor);
        &#125;
        return image;
    &#125;
    void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; image, int x, int y, int color, int newColor) &#123;
        if (image[x][y] &#x3D;&#x3D; color) &#123;
            image[x][y] &#x3D; newColor;
            for (int i &#x3D; 0; i &lt; 4; i++) &#123;
                int mx &#x3D; x + dx[i], my &#x3D; y + dy[i];
                if (mx &gt;&#x3D; 0 &amp;&amp; mx &lt; image.size() &amp;&amp; my &gt;&#x3D; 0 &amp;&amp; my &lt; image[0].size()) &#123;
                    dfs(image, mx, my, color, newColor);
                &#125;
            &#125;
        &#125;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="面试题-10-01-合并排序的数组"><a href="#面试题-10-01-合并排序的数组" class="headerlink" title="面试题 10.01. 合并排序的数组"></a>面试题 10.01. 合并排序的数组</h3><p>问题地址：<a href="https://leetcode.cn/problems/sorted-merge-lcci/">https://leetcode.cn/problems/sorted-merge-lcci/</a></p>
<p>给定两个排序后的数组 A 和 B，其中 A 的末端有足够的缓冲空间容纳 B。 编写一个方法，将 B 合并入 A 并排序。</p>
<p>初始化 A 和 B 的元素数量分别为 m 和 n。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    void merge(vector&lt;int&gt;&amp; A, int m, vector&lt;int&gt;&amp; B, int n) &#123;
        int idx1 &#x3D; m - 1;
        int idx2 &#x3D; n - 1;
        int cur &#x3D; m + n - 1;
        while (idx1 &gt; -1 &amp;&amp; idx2 &gt; -1) &#123;
            if (A[idx1] &lt; B[idx2]) &#123;
                A[cur] &#x3D; B[idx2];
                idx2--;
            &#125; else &#123;
                A[cur] &#x3D; A[idx1];
                idx1--;
            &#125;
            cur--;
        &#125;
        if (idx2 !&#x3D; -1) &#123;
            for (int i &#x3D; 0; i &lt;&#x3D; idx2; ++i) &#123;
                A[i] &#x3D; B[i];
            &#125;
        &#125;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="面试题-10-05-稀疏数组搜索"><a href="#面试题-10-05-稀疏数组搜索" class="headerlink" title="面试题 10.05. 稀疏数组搜索"></a>面试题 10.05. 稀疏数组搜索</h3><p>问题地址：<a href="https://leetcode.cn/problems/sparse-array-search-lcci/">https://leetcode.cn/problems/sparse-array-search-lcci/</a></p>
<p>稀疏数组搜索。有个排好序的字符串数组，其中散布着一些空字符串，编写一种方法，找出给定字符串的位置。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int findString(vector&lt;string&gt;&amp; words, string s) &#123;
        int left &#x3D; 0, right &#x3D; words.size() - 1;
        while (left &lt;&#x3D; right) &#123;
            if (words[left].size() &#x3D;&#x3D; 0) &#123;
                left++;
                continue;
            &#125;
            if (words[right].size() &#x3D;&#x3D; 0) &#123;
                right--;
                continue;
            &#125;
            int mid &#x3D; (left + right) &#x2F; 2;
            while (words[mid].size() &#x3D;&#x3D; 0) &#123;
                mid++;
                if (mid &#x3D;&#x3D; right) &#123;
                    right &#x3D; (left + right) &#x2F; 2;
                    continue;
                &#125;
            &#125;
            if (words[mid] &#x3D;&#x3D; s) &#123;
                return mid;
            &#125; else if (words[mid] &gt; s) &#123;
                right &#x3D; mid - 1;
            &#125; else &#123;
                left &#x3D; mid + 1;
            &#125;
        &#125;
        return -1;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="面试题-16-05-阶乘尾数"><a href="#面试题-16-05-阶乘尾数" class="headerlink" title="面试题 16.05. 阶乘尾数"></a>面试题 16.05. 阶乘尾数</h3><p>问题地址：<a href="https://leetcode.cn/problems/factorial-zeros-lcci/">https://leetcode.cn/problems/factorial-zeros-lcci/</a></p>
<p>设计一个算法，算出 n 阶乘有多少个尾随零。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int trailingZeroes(int n) &#123;
        int ans &#x3D; 0;
        while (n) &#123;
            n &#x2F;&#x3D; 5;
            ans +&#x3D; n;
        &#125;
        return ans;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="面试题-16-07-最大数值"><a href="#面试题-16-07-最大数值" class="headerlink" title="面试题 16.07. 最大数值"></a>面试题 16.07. 最大数值</h3><p>问题地址：<a href="https://leetcode.cn/problems/maximum-lcci/">https://leetcode.cn/problems/maximum-lcci/</a></p>
<p>编写一个方法，找出两个数字a和b中最大的那一个。不得使用if-else或其他比较运算符。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int maximum(int a, int b) &#123;
        bool sign &#x3D; ((long)a - (long)b) &gt;&gt; 63;
        return a * (int)(!sign) + b * (int)sign;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="面试题-16-11-跳水板"><a href="#面试题-16-11-跳水板" class="headerlink" title="面试题 16.11. 跳水板"></a>面试题 16.11. 跳水板</h3><p>问题地址：<a href="https://leetcode.cn/problems/diving-board-lcci/">https://leetcode.cn/problems/diving-board-lcci/</a></p>
<p>你正在使用一堆木板建造跳水板。有两种类型的木板，其中长度较短的木板长度为shorter，长度较长的木板长度为longer。你必须正好使用k块木板。编写一个方法，生成跳水板所有可能的长度。</p>
<p>返回的长度需要从小到大排列。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    vector&lt;int&gt; divingBoard(int shorter, int longer, int k) &#123;
        if (k &#x3D;&#x3D; 0) &#123;
            return vector&lt;int&gt;();
        &#125;
        if (shorter &#x3D;&#x3D; longer) &#123;
            return vector&lt;int&gt;(1, shorter * k);
        &#125;
        vector&lt;int&gt; lengths(k + 1);
        for (int i &#x3D; 0; i &lt;&#x3D; k; ++i) &#123;
            lengths[i] &#x3D; shorter * (k - i) + longer * i;
        &#125;
        return lengths;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="面试题-16-17-连续数列"><a href="#面试题-16-17-连续数列" class="headerlink" title="面试题 16.17. 连续数列"></a>面试题 16.17. 连续数列</h3><p>问题地址：<a href="https://leetcode.cn/problems/contiguous-sequence-lcci/">https://leetcode.cn/problems/contiguous-sequence-lcci/</a></p>
<p>给定一个整数数组，找出总和最大的连续数列，并返回总和。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;
        int pre &#x3D; 0, maxAns &#x3D; nums[0];
        for (const auto &amp;x : nums) &#123;
            pre &#x3D; max(pre + x, x);
            maxAns &#x3D; max(maxAns, pre);
        &#125;
        return maxAns;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="543-二叉树的直径"><a href="#543-二叉树的直径" class="headerlink" title="543. 二叉树的直径"></a>543. 二叉树的直径</h3><p>问题地址：<a href="https://leetcode.cn/problems/diameter-of-binary-tree/">https://leetcode.cn/problems/diameter-of-binary-tree/</a></p>
<p>给你一棵二叉树的根节点，返回该树的 直径 。</p>
<p>二叉树的 直径 是指树中任意两个节点之间最长路径的 长度 。这条路径可能经过也可能不经过根节点 root 。</p>
<p>两节点之间路径的 长度 由它们之间边数表示。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;**
 * Definition for a binary tree node.
 * struct TreeNode &#123;
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;
 * &#125;;
 *&#x2F;
class Solution &#123;
private:
    int ans;
    int depth(TreeNode* root) &#123;
        if (root &#x3D;&#x3D; nullptr) &#123;
            return 0;
        &#125;
        int l &#x3D; depth(root-&gt;left);
        int r &#x3D; depth(root-&gt;right);
        ans &#x3D; max(ans, l + r + 1);
        return max(l, r) + 1;
    &#125;
public:
    int diameterOfBinaryTree(TreeNode* root) &#123;
        ans &#x3D; 1;
        depth(root);
        return ans - 1;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="349-两个数组的交集"><a href="#349-两个数组的交集" class="headerlink" title="349. 两个数组的交集"></a>349. 两个数组的交集</h3><p>问题地址：<a href="https://leetcode.cn/problems/intersection-of-two-arrays/">https://leetcode.cn/problems/intersection-of-two-arrays/</a></p>
<p>给定两个数组 nums1 和 nums2 ，返回 它们的交集 。输出结果中的每个元素一定是 唯一 的。我们可以 不考虑输出结果的顺序 。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;
        unordered_set&lt;int&gt; result_set;
        unordered_set&lt;int&gt; set(nums1.begin(), nums1.end());
        for (auto num : nums2) &#123;
            if (set.find(num) !&#x3D; set.end()) &#123;
                result_set.insert(num);
            &#125;
        &#125;
        return vector&lt;int&gt;(result_set.begin(), result_set.end());
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="350-两个数组的交集-II"><a href="#350-两个数组的交集-II" class="headerlink" title="350. 两个数组的交集 II"></a>350. 两个数组的交集 II</h3><p>问题地址：<a href="https://leetcode.cn/problems/intersection-of-two-arrays-ii/">https://leetcode.cn/problems/intersection-of-two-arrays-ii/</a></p>
<p>给你两个整数数组 nums1 和 nums2 ，请你以数组形式返回两数组的交集。返回结果中每个元素出现的次数，应与元素在两个数组中都出现的次数一致（如果出现次数不一致，则考虑取较小值）。可以不考虑输出结果的顺序。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    vector&lt;int&gt; intersect(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;
        sort(nums1.begin(), nums1.end());
        sort(nums2.begin(), nums2.end());
        int len1 &#x3D; nums1.size(), len2 &#x3D; nums2.size();
        vector&lt;int&gt; intersection;
        int index1 &#x3D; 0, index2 &#x3D; 0;
        while (index1 &lt; len1 &amp;&amp; index2 &lt; len2) &#123;
            if (nums1[index1] &lt; nums2[index2]) &#123;
                index1++;
            &#125; else if (nums1[index1] &gt; nums2[index2]) &#123;
                index2++;
            &#125; else &#123;
                intersection.push_back(nums1[index1]);
                index1++;
                index2++;
            &#125;
        &#125;
        return intersection;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="367-有效的完全平方数"><a href="#367-有效的完全平方数" class="headerlink" title="367. 有效的完全平方数"></a>367. 有效的完全平方数</h3><p>问题地址：<a href="https://leetcode.cn/problems/valid-perfect-square/">https://leetcode.cn/problems/valid-perfect-square/</a></p>
<p>给你一个正整数 num 。如果 num 是一个完全平方数，则返回 true ，否则返回 false 。</p>
<p>完全平方数 是一个可以写成某个整数的平方的整数。换句话说，它可以写成某个整数和自身的乘积。</p>
<p>不能使用任何内置的库函数，如  sqrt 。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    bool isPerfectSquare(int num) &#123;
        int left &#x3D; 0, right &#x3D; num;
        while (left &lt;&#x3D; right) &#123;
            int mid &#x3D; left + (right - left) &#x2F; 2;
            long square &#x3D; (long) mid * mid;
            if (square &lt; num) &#123;
                left &#x3D; mid + 1;
            &#125; else if (square &gt; num) &#123;
                right &#x3D; mid - 1;
            &#125; else &#123;
                return true;
            &#125;
        &#125;
        return false;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="387-字符串中的第一个唯一字符"><a href="#387-字符串中的第一个唯一字符" class="headerlink" title="387. 字符串中的第一个唯一字符"></a>387. 字符串中的第一个唯一字符</h3><p>问题地址：<a href="https://leetcode.cn/problems/first-unique-character-in-a-string/">https://leetcode.cn/problems/first-unique-character-in-a-string/</a></p>
<p>给定一个字符串 s ，找到 它的第一个不重复的字符，并返回它的索引 。如果不存在，则返回 -1 。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int firstUniqChar(string s) &#123;
        unordered_map&lt;char, int&gt; frequency;
        for (auto ch : s) &#123;
            ++frequency[ch];
        &#125;
        for (auto i &#x3D; 0; i &lt; s.size(); ++i) &#123;
            if (frequency[s[i]] &#x3D;&#x3D; 1) &#123;
                return i;
            &#125;
        &#125;
        return -1;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="389-找不同"><a href="#389-找不同" class="headerlink" title="389. 找不同"></a>389. 找不同</h3><p>问题地址：<a href="https://leetcode.cn/problems/find-the-difference/">https://leetcode.cn/problems/find-the-difference/</a></p>
<p>给定两个字符串 s 和 t ，它们只包含小写字母。</p>
<p>字符串 t 由字符串 s 随机重排，然后在随机位置添加一个字母。</p>
<p>请找出在 t 中被添加的字母。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    char findTheDifference(string s, string t) &#123;
        vector&lt;int&gt; cnt(26, 0);
        for (auto ch : s) &#123;
            cnt[ch - &#39;a&#39;]++;
        &#125;
        for (auto ch : t) &#123;
            cnt[ch - &#39;a&#39;]--;
            if (cnt[ch - &#39;a&#39;] &lt; 0) &#123;
                return ch;
            &#125;
        &#125;
        return &#39; &#39;;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="409-最长回文串"><a href="#409-最长回文串" class="headerlink" title="409. 最长回文串"></a>409. 最长回文串</h3><p>问题地址：<a href="https://leetcode.cn/problems/longest-palindrome/">https://leetcode.cn/problems/longest-palindrome/</a></p>
<p>给定一个包含大写字母和小写字母的字符串 s ，返回 通过这些字母构造成的 最长的回文串 。</p>
<p>在构造过程中，请注意 区分大小写 。比如 “Aa” 不能当做一个回文字符串。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int longestPalindrome(string s) &#123;
        unordered_map&lt;char, int&gt; count;
        int ans &#x3D; 0;
        for (char c : s) &#123;
            ++count[c];
        &#125;
        for (auto p : count) &#123;
            int v &#x3D; p.second;
            ans +&#x3D; v &#x2F; 2 * 2;
            if (v % 2 &#x3D;&#x3D; 1 and ans % 2 &#x3D;&#x3D; 0) &#123;
                ++ans;
            &#125;
        &#125;
        return ans;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="414-第三大的数"><a href="#414-第三大的数" class="headerlink" title="414. 第三大的数"></a>414. 第三大的数</h3><p>问题地址：<a href="https://leetcode.cn/problems/third-maximum-number/">https://leetcode.cn/problems/third-maximum-number/</a></p>
<p>给你一个非空数组，返回此数组中 第三大的数 。如果不存在，则返回数组中最大的数。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int thirdMax(vector&lt;int&gt;&amp; nums) &#123;
        sort(nums.begin(), nums.end(), greater&lt;&gt;());
        for (auto i &#x3D; 1, diff &#x3D; 1; i &lt; nums.size(); ++i) &#123;
            if (nums[i] !&#x3D; nums[i - 1] &amp;&amp; ++diff &#x3D;&#x3D; 3) &#123;
                return nums[i];
            &#125;
        &#125;
        return nums[0];
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="415-字符串相加"><a href="#415-字符串相加" class="headerlink" title="415. 字符串相加"></a>415. 字符串相加</h3><p>问题地址：<a href="https://leetcode.cn/problems/add-strings/">https://leetcode.cn/problems/add-strings/</a></p>
<p>给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和并同样以字符串形式返回。</p>
<p>你不能使用任何內建的用于处理大整数的库（比如 BigInteger）， 也不能直接将输入的字符串转换为整数形式。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    string addStrings(string num1, string num2) &#123;
        int i &#x3D; num1.length() - 1, j &#x3D; num2.length() - 1, add &#x3D; 0;
        string ans &#x3D; &quot;&quot;;
        while (i &gt;&#x3D; 0 || j &gt;&#x3D; 0 || add !&#x3D; 0) &#123;
            int x &#x3D; i &gt;&#x3D; 0 ? num1[i] - &#39;0&#39; : 0;
            int y &#x3D; j &gt;&#x3D; 0 ? num2[j] - &#39;0&#39; : 0;
            int result &#x3D; x + y + add;
            ans.push_back(&#39;0&#39; + result % 10);
            add &#x3D; result &#x2F; 10;
            i -&#x3D; 1;
            j -&#x3D; 1;
        &#125;
        reverse(ans.begin(), ans.end());
        return ans;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="434-字符串中的单词数"><a href="#434-字符串中的单词数" class="headerlink" title="434. 字符串中的单词数"></a>434. 字符串中的单词数</h3><p>问题地址：<a href="https://leetcode.cn/problems/number-of-segments-in-a-string/">https://leetcode.cn/problems/number-of-segments-in-a-string/</a></p>
<p>统计字符串中的单词个数，这里的单词指的是连续的不是空格的字符。</p>
<p>请注意，你可以假定字符串里不包括任何不可打印的字符。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int countSegments(string s) &#123;
        int count &#x3D; 0;
        for (auto i &#x3D; 0; i &lt; s.size(); i++) &#123;
            if ((i &#x3D;&#x3D; 0 || s[i - 1] &#x3D;&#x3D; &#39; &#39;) &amp;&amp; s[i] !&#x3D; &#39; &#39;) &#123;
                count++;
            &#125;
        &#125;
        return count;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="559-N-叉树的最大深度"><a href="#559-N-叉树的最大深度" class="headerlink" title="559. N 叉树的最大深度"></a>559. N 叉树的最大深度</h3><p>问题地址：<a href="https://leetcode.cn/problems/maximum-depth-of-n-ary-tree/">https://leetcode.cn/problems/maximum-depth-of-n-ary-tree/</a></p>
<p>给定一个 N 叉树，找到其最大深度。</p>
<p>最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。</p>
<p>N 叉树输入按层序遍历序列化表示，每组子节点由空值分隔（请参见示例）。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;*
&#x2F;&#x2F; Definition for a Node.
class Node &#123;
public:
    int val;
    vector&lt;Node*&gt; children;

    Node() &#123;&#125;

    Node(int _val) &#123;
        val &#x3D; _val;
    &#125;

    Node(int _val, vector&lt;Node*&gt; _children) &#123;
        val &#x3D; _val;
        children &#x3D; _children;
    &#125;
&#125;;
*&#x2F;

class Solution &#123;
public:
    int maxDepth(Node* root) &#123;
        if (root &#x3D;&#x3D; nullptr) &#123;
            return 0;
        &#125;
        int maxChildDepth &#x3D; 0;
        vector&lt;Node *&gt; children &#x3D; root-&gt;children;
        for (auto child : children) &#123;
            int childDepth &#x3D; maxDepth(child);
            maxChildDepth &#x3D; max(maxChildDepth, childDepth);
        &#125;
        return maxChildDepth + 1;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="561-数组拆分"><a href="#561-数组拆分" class="headerlink" title="561. 数组拆分"></a>561. 数组拆分</h3><p>问题地址：<a href="https://leetcode.cn/problems/array-partition/">https://leetcode.cn/problems/array-partition/</a></p>
<p>给定长度为 2n 的整数数组 nums ，你的任务是将这些数分成 n 对, 例如 (a1, b1), (a2, b2), …, (an, bn) ，使得从 1 到 n 的 min(ai, bi) 总和最大。</p>
<p>返回该 最大总和 。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int arrayPairSum(vector&lt;int&gt;&amp; nums) &#123;
        sort(nums.begin(), nums.end());
        int ans &#x3D; 0;
        for (auto i &#x3D; 0; i &lt; nums.size(); i +&#x3D; 2) &#123;
            ans +&#x3D; nums[i];
        &#125;
        return ans;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="590-N-叉树的后序遍历"><a href="#590-N-叉树的后序遍历" class="headerlink" title="590. N 叉树的后序遍历"></a>590. N 叉树的后序遍历</h3><p>问题地址：<a href="https://leetcode.cn/problems/n-ary-tree-postorder-traversal/">https://leetcode.cn/problems/n-ary-tree-postorder-traversal/</a></p>
<p>给定一个 n 叉树的根节点 root ，返回 其节点值的 后序遍历 。</p>
<p>n 叉树 在输入中按层序遍历进行序列化表示，每组子节点由空值 null 分隔（请参见示例）。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;*
&#x2F;&#x2F; Definition for a Node.
class Node &#123;
public:
    int val;
    vector&lt;Node*&gt; children;

    Node() &#123;&#125;

    Node(int _val) &#123;
        val &#x3D; _val;
    &#125;

    Node(int _val, vector&lt;Node*&gt; _children) &#123;
        val &#x3D; _val;
        children &#x3D; _children;
    &#125;
&#125;;
*&#x2F;

class Solution &#123;
public:
    vector&lt;int&gt; postorder(Node* root) &#123;
        vector&lt;int&gt; res;
        helper(root, res);
        return res;
    &#125;
    void helper(const Node* root, vector&lt;int&gt;&amp; res) &#123;
        if (root &#x3D;&#x3D; nullptr) &#123;
            return;
        &#125;
        for (auto &amp; ch : root-&gt;children) &#123;
            helper(ch, res);
        &#125;
        res.emplace_back(root-&gt;val);
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="671-二叉树中第二小的节点"><a href="#671-二叉树中第二小的节点" class="headerlink" title="671. 二叉树中第二小的节点"></a>671. 二叉树中第二小的节点</h3><p>问题地址：<a href="https://leetcode.cn/problems/second-minimum-node-in-a-binary-tree/">https://leetcode.cn/problems/second-minimum-node-in-a-binary-tree/</a></p>
<p>给定一个非空特殊的二叉树，每个节点都是正数，并且每个节点的子节点数量只能为 2 或 0。如果一个节点有两个子节点的话，那么该节点的值等于两个子节点中较小的一个。</p>
<p>更正式地说，即 root.val &#x3D; min(root.left.val, root.right.val) 总成立。</p>
<p>给出这样的一个二叉树，你需要输出所有节点中的 第二小的值 。</p>
<p>如果第二小的值不存在的话，输出 -1 。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;**
 * Definition for a binary tree node.
 * struct TreeNode &#123;
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;
 * &#125;;
 *&#x2F;
class Solution &#123;
public:
    int findSecondMinimumValue(TreeNode* root) &#123;
        set&lt;int&gt; s;
        inorder(root, s);
        if (s.size() &lt; 2) &#123;
            return -1;
        &#125; else &#123;
            auto it &#x3D; ++s.begin();
            return *it;
        &#125;
    &#125;
    void inorder(TreeNode* root, set&lt;int&gt;&amp; s) &#123;
        if (!root) return;
        inorder(root-&gt;left, s);
        s.insert(root-&gt;val);
        inorder(root-&gt;right, s);
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="中等"><a href="#中等" class="headerlink" title="中等"></a>中等</h2><h3 id="LCR-095-最长公共子序列"><a href="#LCR-095-最长公共子序列" class="headerlink" title="LCR 095. 最长公共子序列"></a>LCR 095. 最长公共子序列</h3><p>问题地址：<a href="https://leetcode.cn/problems/qJnOS7/">https://leetcode.cn/problems/qJnOS7/</a></p>
<p>给定两个字符串 <code>text1</code> 和 <code>text2</code>，返回这两个字符串的最长 <code>公共子序列</code> 的长度。如果不存在 <code>公共子序列</code> ，返回 <code>0</code> 。</p>
<p>一个字符串的 <code>子序列</code> 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p>
<ul>
<li>例如，<code>&quot;ace&quot;</code> 是 <code>&quot;abcde&quot;</code> 的子序列，但 <code>&quot;aec&quot;</code> 不是 <code>&quot;abcde&quot;</code> 的子序列。</li>
</ul>
<p>两个字符串的 <code>公共子序列</code> 是这两个字符串所共同拥有的子序列。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int longestCommonSubsequence(string text1, string text2) &#123;
        int m &#x3D; text1.length(), n &#x3D; text2.length();
        vector&lt;vector&lt;int&gt;&gt; dp(m + 1, vector&lt;int&gt;(n + 1));
        for (int i &#x3D; 1; i &lt;&#x3D; m; i++) &#123;
            char c1 &#x3D; text1.at(i - 1);
            for (int j &#x3D; 1; j &lt;&#x3D; n; j++) &#123;
                char c2 &#x3D; text2.at(j - 1);
                if (c1 &#x3D;&#x3D; c2) &#123;
                    dp[i][j] &#x3D; dp[i - 1][j - 1] + 1;
                &#125; else &#123;
                    dp[i][j] &#x3D; max(dp[i - 1][j], dp[i][j - 1]);
                &#125;
            &#125;
        &#125;
        return dp[m][n];
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="1717-删除子字符串的最大得分"><a href="#1717-删除子字符串的最大得分" class="headerlink" title="1717. 删除子字符串的最大得分"></a>1717. 删除子字符串的最大得分</h3><p>问题地址：<a href="https://leetcode.cn/problems/maximum-score-from-removing-substrings/">https://leetcode.cn/problems/maximum-score-from-removing-substrings/</a></p>
<p>给你一个字符串 <code>s</code> 和两个整数 <code>x</code> 和 <code>y</code> 。你可以执行下面两种操作任意次。</p>
<ul>
<li>删除子字符串 <code>&quot;ab&quot;</code> 并得到 <code>x</code> 分。<ul>
<li>比方说，从 <code>&quot;cabxbae&quot;</code> 删除 <code>ab</code> ，得到 <code>&quot;cxbae&quot;</code> 。</li>
</ul>
</li>
<li>删除子字符串 <code>&quot;ba&quot;</code> 并得到 <code>y</code> 分。<ul>
<li>比方说，从 <code>&quot;cabxbae&quot;</code> 删除 <code>ba</code> ，得到 <code>&quot;cabxe&quot;</code> 。</li>
</ul>
</li>
</ul>
<p>请返回对 <code>s</code> 字符串执行上面操作若干次能得到的最大得分。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int maximumGain(string s, int x, int y) &#123;
        int n &#x3D; s.length();
        if (x &lt; y) &#123;
            swap(x, y);
            for (int i &#x3D; 0; i &lt; n; i++) &#123;
                if (s[i] &#x3D;&#x3D; &#39;a&#39;) s[i] &#x3D; &#39;b&#39;;
                else if (s[i] &#x3D;&#x3D; &#39;b&#39;) s[i] &#x3D; &#39;a&#39;;
            &#125;
        &#125;

        int ret &#x3D; 0;
        int i &#x3D; 0;
        while (i &lt; n) &#123;
            while (i &lt; n &amp;&amp; s[i] !&#x3D; &#39;a&#39; &amp;&amp; s[i] !&#x3D; &#39;b&#39;) i++;
            
            int ca &#x3D; 0, cb &#x3D; 0;
            while (i &lt; n &amp;&amp; (s[i] &#x3D;&#x3D; &#39;a&#39; || s[i] &#x3D;&#x3D; &#39;b&#39;)) &#123;
                if (s[i] &#x3D;&#x3D; &#39;a&#39;) &#123;
                    ca++;
                &#125; else &#123;
                    if (ca &gt; 0) &#123;
                        ca--;
                        ret +&#x3D; x;
                    &#125; else &#123;
                        cb++;
                    &#125;
                &#125;
                i++;
            &#125;
            
            ret +&#x3D; min(ca, cb) * y;
        &#125;

        return ret;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="2256-最小平均差"><a href="#2256-最小平均差" class="headerlink" title="2256. 最小平均差"></a>2256. 最小平均差</h3><p>问题地址：<a href="https://leetcode.cn/problems/minimum-average-difference/">https://leetcode.cn/problems/minimum-average-difference/</a></p>
<p>给你一个下标从 <code>0</code> 开始长度为 <code>n</code> 的整数数组 <code>nums</code> 。</p>
<p>下标 <code>i</code> 处的 <code>平均差</code> 指的是 <code>nums</code> 中 前 <code>i + 1</code> 个元素平均值和 后 <code>n - i - 1</code> 个元素平均值的 <code>绝对差</code> 。两个平均值都需要 <code>向下取整</code> 到最近的整数。</p>
<p>请你返回产生 <code>最小平均差</code> 的下标。如果有多个下标最小平均差相等，请你返回 <code>最小</code> 的一个下标。</p>
<p>注意：</p>
<ul>
<li>两个数的 <code>绝对差</code> 是两者差的绝对值。</li>
<li><code>n</code> 个元素的平均值是 <code>n</code> 个元素之 <code>和</code> 除以（整数除法） <code>n</code> 。</li>
<li><code>0</code> 个元素的平均值视为 <code>0</code> 。</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int minimumAverageDifference(vector&lt;int&gt;&amp; nums) &#123;
        long sum &#x3D; 0;
        for (auto &amp;num : nums) &#123;
            sum +&#x3D; num;
        &#125;
        long preSum &#x3D; 0;
        int mi &#x3D; INT_MAX;
        int n &#x3D; nums.size();
        int ans &#x3D; 0;
        for (int i &#x3D; 0; i &lt; n; i++) &#123;
            preSum +&#x3D; nums[i];
            long last &#x3D; (i &#x3D;&#x3D; n - 1) ? 0 : (sum - preSum) &#x2F; (n - i - 1);
            long diff &#x3D; abs(preSum &#x2F; (i + 1) - last); &#x2F;* 前后数组和的差值 *&#x2F;
            if (mi &gt; diff) &#123;
                ans &#x3D; i;
                mi &#x3D; diff;
            &#125;
        &#125;
        return ans;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="1513-仅含-1-的子串数"><a href="#1513-仅含-1-的子串数" class="headerlink" title="1513. 仅含 1 的子串数"></a>1513. 仅含 1 的子串数</h3><p>问题地址：<a href="https://leetcode.cn/problems/number-of-substrings-with-only-1s/">https://leetcode.cn/problems/number-of-substrings-with-only-1s/</a></p>
<p>给你一个二进制字符串 <code>s</code>（仅由 <code>&#39;0&#39;</code> 和 <code>&#39;1&#39;</code> 组成的字符串）。</p>
<p>返回所有字符都为 1 的子字符串的数目。</p>
<p>由于答案可能很大，请你将它对 <code>10^9 + 7</code> 取模后返回。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    static constexpr int P &#x3D; int(1E9) + 7;
    
    int numSub(string s) &#123;
        int p &#x3D; 0;
        long long ans &#x3D; 0;
        while (p &lt; s.size()) &#123;
            if (s[p] &#x3D;&#x3D; &#39;0&#39;) &#123;
                ++p;
                continue;
            &#125;
            int cnt &#x3D; 0;
            while (p &lt; s.size() &amp;&amp; s[p] &#x3D;&#x3D; &#39;1&#39;) &#123;
                ++cnt;
                ++p;
            &#125;
            ans &#x3D; ans + (1LL + (long long)cnt) * cnt &#x2F; 2;
            ans &#x3D; ans % P;
        &#125;
        return ans;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="1898-可移除字符的最大数目"><a href="#1898-可移除字符的最大数目" class="headerlink" title="1898. 可移除字符的最大数目"></a>1898. 可移除字符的最大数目</h3><p>问题地址：<a href="https://leetcode.cn/problems/maximum-number-of-removable-characters/">https://leetcode.cn/problems/maximum-number-of-removable-characters/</a></p>
<p>给你两个字符串 <code>s</code> 和 <code>p</code> ，其中 <code>p</code> 是 <code>s</code> 的一个 <code>子序列</code> 。同时，给你一个元素 <code>互不相同</code> 且下标 <code>从 0 开始</code> 计数的整数数组 <code>removable</code> ，该数组是 <code>s</code> 中下标的一个子集（<code>s</code> 的下标也 <code>从 0 开始</code> 计数）。</p>
<p>请你找出一个整数 <code>k（0 &lt;= k &lt;= removable.length）</code>，选出 <code>removable</code> 中的 前 <code>k</code> 个下标，然后从 <code>s</code> 中移除这些下标对应的 <code>k</code> 个字符。整数 <code>k</code> 需满足：在执行完上述步骤后， <code>p</code> 仍然是 <code>s</code> 的一个 <code>子序列</code> 。更正式的解释是，对于每个 <code>0 &lt;= i &lt; k</code> ，先标记出位于 <code>s[removable[i]]</code> 的字符，接着移除所有标记过的字符，然后检查 <code>p</code> 是否仍然是 <code>s</code> 的一个子序列。</p>
<p>返回你可以找出的 <code>最大 k</code> ，满足在移除字符后 <code>p</code> 仍然是 <code>s</code> 的一个子序列。</p>
<p>字符串的一个 <code>子序列</code> 是一个由原字符串生成的新字符串，生成过程中可能会移除原字符串中的一些字符（也可能不移除）但不改变剩余字符之间的相对顺序。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int maximumRemovals(string s, string p, vector&lt;int&gt;&amp; removable) &#123;
        int ns &#x3D; s.size();
        int np &#x3D; p.size();
        int n &#x3D; removable.size();
        &#x2F;&#x2F; 辅助函数，用来判断移除 k 个下标后 p 是否是 s_k 的子序列
        auto check &#x3D; [&amp;](int k) -&gt; bool &#123;
            vector&lt;int&gt; state(ns, 1);   &#x2F;&#x2F; s 中每个字符的状态
            for (int i &#x3D; 0; i &lt; k; ++i)&#123;
                state[removable[i]] &#x3D; 0;
            &#125;
            &#x2F;&#x2F; 匹配 s_k 与 p 
            int j &#x3D; 0;
            for (int i &#x3D; 0; i &lt; ns; ++i)&#123;
                &#x2F;&#x2F; s[i] 未被删除且与 p[j] 相等时，匹配成功，增加 j
                if (state[i] &amp;&amp; s[i] &#x3D;&#x3D; p[j])&#123;
                    ++j;
                    if (j &#x3D;&#x3D; np)&#123;
                        return true;
                    &#125;
                &#125;
            &#125;
            return false;
        &#125;;

        &#x2F;&#x2F; 二分查找
        int l &#x3D; 0;
        int r &#x3D; n + 1;
        while (l &lt; r)&#123;
            int mid &#x3D; l + (r - l) &#x2F; 2;
            if (check(mid))&#123;
                l &#x3D; mid + 1;
            &#125;
            else&#123;
                r &#x3D; mid;
            &#125;
        &#125;
        return l - 1;

    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="1300-转变数组后最接近目标值的数组和"><a href="#1300-转变数组后最接近目标值的数组和" class="headerlink" title="1300. 转变数组后最接近目标值的数组和"></a>1300. 转变数组后最接近目标值的数组和</h3><p>问题地址：<a href="https://leetcode.cn/problems/sum-of-mutated-array-closest-to-target/">https://leetcode.cn/problems/sum-of-mutated-array-closest-to-target/</a></p>
<p>给你一个整数数组 <code>arr</code> 和一个目标值 <code>target</code> ，请你返回一个整数 <code>value</code> ，使得将数组中所有大于 <code>value</code> 的值变成 <code>value</code> 后，数组的和最接近  <code>target</code> （最接近表示两者之差的绝对值最小）。</p>
<p>如果有多种使得和最接近 <code>target</code> 的方案，请你返回这些整数中的最小值。</p>
<p>请注意，答案不一定是 <code>arr</code> 中的数字。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int findBestValue(vector&lt;int&gt;&amp; arr, int target) &#123;
        sort(arr.begin(), arr.end());
        int n &#x3D; arr.size();
        vector&lt;int&gt; prefix(n + 1);
        for (int i &#x3D; 1; i &lt;&#x3D; n; ++i) &#123;
            prefix[i] &#x3D; prefix[i - 1] + arr[i - 1];
        &#125;

        int r &#x3D; *max_element(arr.begin(), arr.end());
        int ans &#x3D; 0, diff &#x3D; target;
        for (int i &#x3D; 1; i &lt;&#x3D; r; ++i) &#123;
            auto iter &#x3D; lower_bound(arr.begin(), arr.end(), i);
            int cur &#x3D; prefix[iter - arr.begin()] + (arr.end() - iter) * i;
            if (abs(cur - target) &lt; diff) &#123;
                ans &#x3D; i;
                diff &#x3D; abs(cur - target);
            &#125;
        &#125;
        return ans;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="78-子集"><a href="#78-子集" class="headerlink" title="78. 子集"></a>78. 子集</h3><p>问题地址：<a href="https://leetcode.cn/problems/subsets/">https://leetcode.cn/problems/subsets/</a></p>
<p>给你一个整数数组 <code>nums</code> ，数组中的元素 <code>互不相同</code> 。返回该数组所有可能的子集（幂集）。</p>
<p>解集 <code>不能</code> 包含重复的子集。你可以按 <code>任意顺序</code> 返回解集。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    vector&lt;int&gt; t;
    vector&lt;vector&lt;int&gt;&gt; ans;

    vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123;
        int n &#x3D; nums.size();
        for (int mask &#x3D; 0; mask &lt; (1 &lt;&lt; n); ++mask) &#123;
            t.clear();
            for (int i &#x3D; 0; i &lt; n; ++i) &#123;
                if (mask &amp; (1 &lt;&lt; i)) &#123;
                    t.push_back(nums[i]);
                &#125;
            &#125;
            ans.push_back(t);
        &#125;
        return ans;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="2597-美丽子集的数目"><a href="#2597-美丽子集的数目" class="headerlink" title="2597. 美丽子集的数目"></a>2597. 美丽子集的数目</h3><p>问题地址：<a href="https://leetcode.cn/problems/the-number-of-beautiful-subsets/">https://leetcode.cn/problems/the-number-of-beautiful-subsets/</a></p>
<p>给你一个由正整数组成的数组 <code>nums</code> 和一个 <code>正</code> 整数 <code>k</code> 。</p>
<p>如果 <code>nums</code> 的子集中，任意两个整数的绝对差均不等于 <code>k</code> ，则认为该子数组是一个 <code>美丽</code> 子集。</p>
<p>返回数组 <code>nums</code> 中 <code>非空</code> 且 <code>美丽</code> 的子集数目。</p>
<p><code>nums</code> 的子集定义为：可以经由 <code>nums</code> 删除某些元素（也可能不删除）得到的一个数组。只有在删除元素时选择的索引不同的情况下，两个子集才会被视作是不同的子集。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int beautifulSubsets(vector&lt;int&gt; &amp;nums, int k) &#123;
        int ans &#x3D; -1; &#x2F;&#x2F; 去掉空集
        int cnt[3001]&#123;&#125;; &#x2F;&#x2F; 用数组实现比哈希表更快
        function&lt;void(int)&gt; dfs &#x3D; [&amp;](int i) &#123;
            if (i &#x3D;&#x3D; nums.size()) &#123;
                ans++;
                return;
            &#125;
            dfs(i + 1); &#x2F;&#x2F; 不选
            int x &#x3D; nums[i] + k; &#x2F;&#x2F; 避免负数下标
            if (cnt[x - k] &#x3D;&#x3D; 0 &amp;&amp; cnt[x + k] &#x3D;&#x3D; 0) &#123;
                ++cnt[x]; &#x2F;&#x2F; 选
                dfs(i + 1);
                --cnt[x]; &#x2F;&#x2F; 恢复现场
            &#125;
        &#125;;
        dfs(0);
        return ans;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="1457-二叉树中的伪回文路径"><a href="#1457-二叉树中的伪回文路径" class="headerlink" title="1457. 二叉树中的伪回文路径"></a>1457. 二叉树中的伪回文路径</h3><p>问题地址：<a href="https://leetcode.cn/problems/pseudo-palindromic-paths-in-a-binary-tree/">https://leetcode.cn/problems/pseudo-palindromic-paths-in-a-binary-tree/</a></p>
<p>给你一棵二叉树，每个节点的值为 1 到 9 。我们称二叉树中的一条路径是 「<code>伪回文</code>」的，当它满足：路径经过的所有节点值的排列中，存在一个回文序列。</p>
<p>请你返回从根到叶子节点的所有路径中 <code>伪回文</code> 路径的数目。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;**
 * Definition for a binary tree node.
 * struct TreeNode &#123;
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;
 * &#125;;
 *&#x2F;
class Solution &#123;
public:
    int check(int *cnt) &#123;
        int odd &#x3D; 0;
        for (int i &#x3D; 0; i &lt;&#x3D; 9; i++) &#123;
            if (cnt[i] &amp; 1) &#123;
                odd++;
            &#125;
        &#125;
        if (odd &lt;&#x3D; 1) &#123;
            return 1;
        &#125;
        return 0;
    &#125;

    int dfs(TreeNode *root, int *cnt) &#123;
        if (root &#x3D;&#x3D; nullptr) &#123;
            return 0;
        &#125;
        cnt[root-&gt;val]++;
        if (root-&gt;left &#x3D;&#x3D; nullptr &amp;&amp; root-&gt;right &#x3D;&#x3D; nullptr) &#123;
            int anw &#x3D; check(cnt);
            cnt[root-&gt;val]--;
            return anw;
        &#125;
        int anw &#x3D; 0;
        if (root-&gt;left !&#x3D; nullptr) &#123;
            anw +&#x3D; dfs(root-&gt;left, cnt);
        &#125;
        if (root-&gt;right !&#x3D; nullptr) &#123;
            anw +&#x3D; dfs(root-&gt;right, cnt);
        &#125;
        cnt[root-&gt;val]--;
        return anw;
    &#125;

    int pseudoPalindromicPaths (TreeNode* root) &#123;
        int cnt[10] &#x3D; &#123;0&#125;;
        return dfs(root, cnt);
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="720-词典中最长的单词"><a href="#720-词典中最长的单词" class="headerlink" title="720. 词典中最长的单词"></a>720. 词典中最长的单词</h3><p>问题地址：<a href="https://leetcode.cn/problems/longest-word-in-dictionary/">https://leetcode.cn/problems/longest-word-in-dictionary/</a></p>
<p>给出一个字符串数组 <code>words</code> 组成的一本英语词典。返回 <code>words</code> 中最长的一个单词，该单词是由 <code>words</code> 词典中其他单词逐步添加一个字母组成。</p>
<p>若其中有多个可行的答案，则返回答案中字典序最小的单词。若无答案，则返回空字符串。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    string longestWord(vector&lt;string&gt;&amp; words) &#123;
        sort(words.begin(), words.end(), [](const string &amp;a, const string &amp;b) &#123;
            return a.size() !&#x3D; b.size() ? a.size() &lt; b.size() : a &gt; b;
        &#125;);
        string longest;
        unordered_set&lt;string&gt; candidates &#x3D; &#123;&quot;&quot;&#125;;
        for (const auto &amp;word : words) &#123;
            if (candidates.count(word.substr(0, word.size() - 1))) &#123;
                candidates.emplace(word);
                longest &#x3D; word;
            &#125;
        &#125;
        return longest;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198. 打家劫舍"></a>198. 打家劫舍</h3><p>问题地址：<a href="https://leetcode.cn/problems/house-robber/">https://leetcode.cn/problems/house-robber/</a></p>
<p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<code>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</code></p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <code>不触动警报装置的情况下</code> ，一夜之内能够偷窃到的最高金额。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int rob(vector&lt;int&gt;&amp; nums) &#123;
        if (nums.size() &#x3D;&#x3D; 0) &#123;
            return 0;
        &#125;

        int N &#x3D; nums.size();
        vector&lt;int&gt; dp(N+1, 0);
        dp[0] &#x3D; 0;
        dp[1] &#x3D; nums[0];
        for (int k &#x3D; 2; k &lt;&#x3D; N; k++) &#123;
            dp[k] &#x3D; max(dp[k-1], nums[k-1] + dp[k-2]);
        &#125;
        return dp[N];
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="50-Pow-x-n"><a href="#50-Pow-x-n" class="headerlink" title="50. Pow(x, n)"></a>50. Pow(x, n)</h3><p>问题地址：<a href="https://leetcode.cn/problems/powx-n/">https://leetcode.cn/problems/powx-n/</a></p>
<p>实现 <code>pow(x, n)</code> ，即计算 <code>x</code> 的整数 <code>n</code> 次幂函数（即，$x^n$ ）。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    double quickMul(double x, long long N) &#123;
        double ans &#x3D; 1.0;
        double x_contribute &#x3D; x;
        while (N &gt; 0) &#123;
            if (N % 2 &#x3D;&#x3D; 1) &#123;
                ans *&#x3D; x_contribute;
            &#125;
            x_contribute *&#x3D; x_contribute;
            N &#x2F;&#x3D; 2;
        &#125;
        return ans;
    &#125;
    double myPow(double x, int n) &#123;
        long long N &#x3D; n;
        return N &gt;&#x3D; 0 ? quickMul(x, N) : 1.0 &#x2F;quickMul(x, -N);
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="1922-统计好数字的数目"><a href="#1922-统计好数字的数目" class="headerlink" title="1922. 统计好数字的数目"></a>1922. 统计好数字的数目</h3><p>问题地址：<a href="https://leetcode.cn/problems/count-good-numbers/">https://leetcode.cn/problems/count-good-numbers/</a></p>
<p>我们称一个数字字符串是 <code>好数字</code> 当它满足（下标从 <code>0</code> 开始）<code>偶数</code> 下标处的数字为 <code>偶数</code> 且 <code>奇数</code> 下标处的数字为 <code>质数</code> （2，3，5 或 7）。</p>
<ul>
<li>比方说，<code>&quot;2582&quot;</code> 是好数字，因为偶数下标处的数字（<code>2</code> 和 <code>8</code>）是偶数且奇数下标处的数字（<code>5</code> 和 <code>2</code>）为质数。但 <code>&quot;3245&quot;</code> 不是 好数字，因为 <code>3</code> 在偶数下标处但不是偶数。</li>
</ul>
<p>给你一个整数 <code>n</code> ，请你返回长度为 <code>n</code> 且为好数字的数字字符串 <code>总数</code> 。由于答案可能会很大，请你将它对 $10^9 + 7$ 取余后返回 。</p>
<p>一个 <code>数字字符串</code> 是每一位都由 0 到 9 组成的字符串，且可能包含前导 0 。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
private:
    static constexpr int mod &#x3D; 1e9 + 7;

public:
    int countGoodNumbers(long long n) &#123;
        auto quickmul &#x3D; [](int x, long long y) -&gt; int &#123;
            int ret &#x3D; 1, mul &#x3D; x;
            while (y &gt; 0) &#123;
                if (y % 2 &#x3D;&#x3D; 1) &#123;
                    ret &#x3D; (long long)ret * mul % mod;
                &#125;
                mul &#x3D; (long long)mul * mul % mod;
                y &#x2F;&#x3D; 2;
            &#125;
            return ret;
        &#125;;

        return (long long)quickmul(5, (n + 1) &#x2F; 2) * quickmul(4, n &#x2F; 2) % mod;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="86-分隔链表"><a href="#86-分隔链表" class="headerlink" title="86. 分隔链表"></a>86. 分隔链表</h3><p>问题地址：<a href="https://leetcode.cn/problems/partition-list/">https://leetcode.cn/problems/partition-list/</a></p>
<p>给你一个链表的头节点 <code>head</code> 和一个特定值 <code>x</code> ，请你对链表进行分隔，使得所有 <code>小于</code> x 的节点都出现在 <code>大于或等于</code> x 的节点之前。</p>
<p>你应当 <code>保留</code> 两个分区中每个节点的初始相对位置。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;**
 * Definition for singly-linked list.
 * struct ListNode &#123;
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) &#123;&#125;
 *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;
 *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;
 * &#125;;
 *&#x2F;
class Solution &#123;
public:
    ListNode* partition(ListNode* head, int x) &#123;
        ListNode* small &#x3D; new ListNode(0);
        ListNode* smallHead &#x3D; small;
        ListNode* large &#x3D; new ListNode(0);
        ListNode* largeHead &#x3D; large;
        while (head !&#x3D; nullptr) &#123;
            if (head-&gt;val &lt; x) &#123;
                small-&gt;next &#x3D; head;
                small &#x3D; small-&gt;next;
            &#125; else &#123;
                large-&gt;next &#x3D; head;
                large &#x3D; large-&gt;next;
            &#125;
            head &#x3D; head-&gt;next;
        &#125;
        large-&gt;next &#x3D; nullptr;
        small-&gt;next &#x3D; largeHead-&gt;next;
        return smallHead-&gt;next;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="2531-使字符串总不同字符的数目相等"><a href="#2531-使字符串总不同字符的数目相等" class="headerlink" title="2531. 使字符串总不同字符的数目相等"></a>2531. 使字符串总不同字符的数目相等</h3><p>问题地址：<a href="https://leetcode.cn/problems/make-number-of-distinct-characters-equal/">https://leetcode.cn/problems/make-number-of-distinct-characters-equal/</a></p>
<p>给你两个下标从 <code>0</code> 开始的字符串 <code>word1</code> 和 <code>word2</code> 。</p>
<p>一次 <code>移动</code> 由以下两个步骤组成：</p>
<ul>
<li>选中两个下标 <code>i</code> 和 <code>j</code> ，分别满足 <code>0 &lt;= i &lt; word1.length</code> 和 <code>0 &lt;= j &lt; word2.length</code> ，</li>
<li>交换 <code>word1[i]</code> 和 <code>word2[j]</code> 。</li>
</ul>
<p>如果可以通过 <code>恰好一次</code> 移动，使 <code>word1</code> 和 <code>word2</code> 中不同字符的数目相等，则返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    bool isItPossible(string word1, string word2) &#123;
        unordered_map&lt;char, int&gt; c1, c2;
        for (char c : word1) ++c1[c];
        for (char c : word2) ++c2[c];
        for (auto[x, c] : c1) &#123;
            for (auto[y, d] : c2) &#123;
                if (y &#x3D;&#x3D; x) &#123;
                    if (c1.size() &#x3D;&#x3D; c2.size()) return true;
                &#125; else if (c1.size() - (c &#x3D;&#x3D; 1) + !c1.count(y) &#x3D;&#x3D;
                           c2.size() - (d &#x3D;&#x3D; 1) + !c2.count(x))
                    return true;
            &#125;
        &#125;
        return false;        
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="494-目标和"><a href="#494-目标和" class="headerlink" title="494. 目标和"></a>494. 目标和</h3><p>问题地址：<a href="https://leetcode.cn/problems/target-sum/">https://leetcode.cn/problems/target-sum/</a></p>
<p>给你一个非负整数数组 <code>nums</code> 和一个整数 <code>target</code> 。</p>
<p>向数组中的每个整数前添加 <code>&#39;+&#39;</code> 或 <code>&#39;-&#39;</code> ，然后串联起所有整数，可以构造一个 <code>表达式</code> ：</p>
<ul>
<li>例如，<code>nums = [2, 1]</code> ，可以在 <code>2</code> 之前添加 <code>&#39;+&#39;</code> ，在 <code>1</code> 之前添加 <code>&#39;-&#39;</code> ，然后串联起来得到表达式 <code>&quot;+2-1&quot;</code> 。</li>
</ul>
<p>返回可以通过上述方法构造的、运算结果等于 <code>target</code> 的不同 <code>表达式</code> 的数目。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int count &#x3D; 0;

    int findTargetSumWays(vector&lt;int&gt;&amp; nums, int target) &#123;
        backtrack(nums, target, 0, 0);
        return count;
    &#125;

    void backtrack(vector&lt;int&gt;&amp; nums, int target, int index, int sum) &#123;
        if (index &#x3D;&#x3D; nums.size()) &#123;
            if (sum &#x3D;&#x3D; target) &#123;
                count++;
            &#125;
        &#125; else &#123;
            backtrack(nums, target, index + 1, sum + nums[index]);
            backtrack(nums, target, index + 1, sum - nums[index]);
        &#125;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="535-TinyURL-的加密与解密"><a href="#535-TinyURL-的加密与解密" class="headerlink" title="535. TinyURL 的加密与解密"></a>535. TinyURL 的加密与解密</h3><p>问题地址：<a href="https://leetcode.cn/problems/encode-and-decode-tinyurl/">https://leetcode.cn/problems/encode-and-decode-tinyurl/</a></p>
<p>TinyURL 是一种 URL 简化服务， 比如：当你输入一个 URL <code>https://leetcode.com/problems/design-tinyurl</code> 时，它将返回一个简化的URL <code>http://tinyurl.com/4e9iAk</code> 。请你设计一个类来加密与解密 TinyURL 。</p>
<p>加密和解密算法如何设计和运作是没有限制的，你只需要保证一个 URL 可以被加密成一个 TinyURL ，并且这个 TinyURL 可以用解密方法恢复成原本的 URL 。</p>
<p>实现 <code>Solution</code> 类：</p>
<ul>
<li><code>Solution()</code> 初始化 TinyURL 系统对象。</li>
<li><code>String encode(String longUrl)</code> 返回 <code>longUrl</code> 对应的 TinyURL 。</li>
<li><code>String decode(String shortUrl)</code> 返回 <code>shortUrl</code> 原本的 <code>URL</code> 。题目数据保证给定的 <code>shortUrl</code> 是由同一个系统对象加密的。</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
private:
    unordered_map&lt;int, string&gt; dataBase;
    int id;
public:
    Solution() &#123;
        id &#x3D; 0;
    &#125;

    &#x2F;&#x2F; Encodes a URL to a shortened URL.
    string encode(string longUrl) &#123;
        id++;
        dataBase[id] &#x3D; longUrl;
        return string(&quot;http:&#x2F;&#x2F;tinyurl.com&#x2F;&quot;) + to_string(id);
    &#125;

    &#x2F;&#x2F; Decodes a shortened URL to its original URL.
    string decode(string shortUrl) &#123;
        int p &#x3D; shortUrl.rfind(&#39;&#x2F;&#39;) + 1;
        int key &#x3D; stoi(shortUrl.substr(p, int(shortUrl.size()) - p));
        return dataBase[key];
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="215-数组中的第K个最大元素"><a href="#215-数组中的第K个最大元素" class="headerlink" title="215. 数组中的第K个最大元素"></a>215. 数组中的第K个最大元素</h3><p>问题地址：<a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/">https://leetcode.cn/problems/kth-largest-element-in-an-array/</a></p>
<p>给定整数数组 <code>nums</code> 和整数 <code>k</code>，请返回数组中第 <code>k</code> 个最大的元素。</p>
<p>请注意，你需要找的是数组排序后的第 <code>k</code> 个最大的元素，而不是第 <code>k</code> 个不同的元素。</p>
<p>你必须设计并实现时间复杂度为 <code>O(n)</code> 的算法解决此问题。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int quickSelect(vector&lt;int&gt;&amp; a, int l, int r, int index) &#123;
        int q &#x3D; randomPartition(a, l, r);
        if (q &#x3D;&#x3D; index) &#123;
            return a[q];
        &#125; else &#123;
            return q &lt; index ? quickSelect(a, q + 1, r, index) : quickSelect(a, l, q - 1, index);
        &#125;
    &#125;

    inline int randomPartition(vector&lt;int&gt;&amp; a, int l, int r) &#123;
        int i &#x3D; rand() % (r - l + 1) + l;
        swap(a[i], a[r]);
        return partition(a, l, r);
    &#125;

    inline int partition(vector&lt;int&gt;&amp; a, int l, int r) &#123;
        int x &#x3D; a[r], i &#x3D; l - 1;
        for (int j &#x3D; l; j &lt; r; ++j) &#123;
            if (a[j] &lt;&#x3D; x) &#123;
                swap(a[++i], a[j]);
            &#125;
        &#125;
        swap(a[i + 1], a[r]);
        return i + 1;
    &#125;

    int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123;
        srand(time(0));
        return quickSelect(nums, 0, nums.size() - 1, nums.size() - k);
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="2304-网格中的最小路径代价"><a href="#2304-网格中的最小路径代价" class="headerlink" title="2304. 网格中的最小路径代价"></a>2304. 网格中的最小路径代价</h3><p>问题地址：<a href="https://leetcode.cn/problems/minimum-path-cost-in-a-grid/">https://leetcode.cn/problems/minimum-path-cost-in-a-grid/</a></p>
<p>给你一个下标从 <code>0</code> 开始的整数矩阵 <code>grid</code> ，矩阵大小为 <code>m x n</code> ，由从 <code>0</code> 到 <code>m * n - 1</code> 的不同整数组成。你可以在此矩阵中，从一个单元格移动到 <code>下一行</code> 的任何其他单元格。如果你位于单元格 <code>(x, y)</code> ，且满足 <code>x &lt; m - 1</code> ，你可以移动到 <code>(x + 1, 0)</code>, <code>(x + 1, 1)</code>, …, <code>(x + 1, n - 1)</code> 中的任何一个单元格。<code>注意：</code> 在最后一行中的单元格不能触发移动。</p>
<p>每次可能的移动都需要付出对应的代价，代价用一个下标从 <code>0</code> 开始的二维数组 <code>moveCost</code> 表示，该数组大小为 <code>(m * n) x n</code> ，其中 <code>moveCost[i][j]</code> 是从值为 <code>i</code> 的单元格移动到下一行第 <code>j</code> 列单元格的代价。从 <code>grid</code> 最后一行的单元格移动的代价可以忽略。</p>
<p><code>grid</code> 一条路径的代价是：所有路径经过的单元格的 <code>值之和</code> 加上 所有移动的 <code>代价之和</code> 。从 <code>第一行</code> 任意单元格出发，返回到达 <code>最后一行</code> 任意单元格的最小路径代价。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int minPathCost(vector&lt;vector&lt;int&gt;&gt;&amp; grid, vector&lt;vector&lt;int&gt;&gt;&amp; moveCost) &#123;
        int m &#x3D; grid.size(), n &#x3D; grid[0].size();

        vector&lt;vector&lt;int&gt;&gt; f;
        f.resize(m, vector&lt;int&gt;(n));
        for (int j &#x3D; 0; j &lt; n; j++) f[0][j] &#x3D; grid[0][j];
        for (int i &#x3D; 1; i &lt; m; i++) for (int j &#x3D; 0; j &lt; n; j++) &#123;
            f[i][j] &#x3D; 1e9;
            for (int k &#x3D; 0; k &lt; n; k++) f[i][j] &#x3D; min(f[i][j], f[i - 1][k] + moveCost[grid[i - 1][k]][j] + grid[i][j]);
        &#125;

        int ans &#x3D; 1e9;
        for (int j &#x3D; 0; j &lt; n; j++) ans &#x3D; min(ans, f[m - 1][j]);
        return ans;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="139-单词拆分"><a href="#139-单词拆分" class="headerlink" title="139. 单词拆分"></a>139. 单词拆分</h3><p>问题地址：<a href="https://leetcode.cn/problems/word-break/">https://leetcode.cn/problems/word-break/</a></p>
<p>给你一个字符串 <code>s</code> 和一个字符串列表 <code>wordDict</code> 作为字典。请你判断是否可以利用字典中出现的单词拼接出 <code>s</code> 。</p>
<p><code>注意：</code>不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) &#123;
        auto wordDictSet &#x3D; unordered_set&lt;string&gt;();
        for (auto word : wordDict) &#123;
            wordDictSet.insert(word);
        &#125;

        auto dp &#x3D; vector&lt;bool&gt;(s.size() + 1);
        dp[0] &#x3D; true;
        for (int i &#x3D; 1; i &lt;&#x3D; s.size(); ++i) &#123;
            for (int j &#x3D; 0; j &lt; i; ++j) &#123;
                if (dp[j] &amp;&amp; wordDictSet.find(s.substr(j, i - j)) !&#x3D; wordDictSet.end()) &#123;
                    dp[i] &#x3D; true;
                    break;
                &#125;
            &#125;
        &#125;
        return dp[s.size()];
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="731-我的日程安排表-II"><a href="#731-我的日程安排表-II" class="headerlink" title="731. 我的日程安排表 II"></a>731. 我的日程安排表 II</h3><p>问题地址：<a href="https://leetcode.cn/problems/my-calendar-ii/">https://leetcode.cn/problems/my-calendar-ii/</a></p>
<p>实现一个 <code>MyCalendar</code> 类来存放你的日程安排。如果要添加的时间内不会导致三重预订时，则可以存储这个新的日程安排。</p>
<p><code>MyCalendar</code> 有一个 <code>book(int start, int end)</code>方法。它意味着在 <code>start</code> 到 <code>end</code> 时间内增加一个日程安排，注意，这里的时间是半开区间，即 <code>[start, end)</code>, 实数 <code>x</code> 的范围为，  <code>start &lt;= x &lt; end</code>。</p>
<p>当三个日程安排有一些时间上的交叉时（例如三个日程安排都在同一时间内），就会产生三重预订。</p>
<p>每次调用 <code>MyCalendar.book</code>方法时，如果可以将日程安排成功添加到日历中而不会导致三重预订，返回 <code>true</code>。否则，返回 <code>false</code> 并且不要将该日程安排添加到日历中。</p>
<p>请按照以下步骤调用<code>MyCalendar</code> 类: <code>MyCalendar cal = new MyCalendar()</code>; <code>MyCalendar.book(start, end)</code></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class MyCalendarTwo &#123;
public:
    MyCalendarTwo() &#123;

    &#125;
    
    bool book(int start, int end) &#123;
        for (auto &amp;[l, r] : overlaps) &#123;
            if (l &lt; end &amp;&amp; start &lt; r) &#123;
                return false;
            &#125;
        &#125;
        for (auto &amp;[l, r] : booked) &#123;
            if (l &lt; end &amp;&amp; start &lt; r) &#123;
                overlaps.emplace_back(max(l, start), min(r, end));
            &#125;
        &#125;
        booked.emplace_back(start, end);
        return true;
    &#125;
private:
    vector&lt;pair&lt;int, int&gt;&gt; booked;
    vector&lt;pair&lt;int, int&gt;&gt; overlaps;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="LCR-007-三数之和"><a href="#LCR-007-三数之和" class="headerlink" title="LCR 007. 三数之和"></a>LCR 007. 三数之和</h3><p>问题地址：<a href="https://leetcode.cn/problems/1fGaJU/">https://leetcode.cn/problems/1fGaJU/</a></p>
<p>给定一个包含 <code>n</code> 个整数的数组 <code>nums</code>，判断 <code>nums</code> 中是否存在三个元素 <code>a</code> ，<code>b</code> ，<code>c</code> ，使得 <code>a + b + c = 0</code> ？请找出所有和为 <code>0</code> 且 <code>不重复</code> 的三元组。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123;
        int n &#x3D; nums.size();
        sort(nums.begin(), nums.end());
        vector&lt;vector&lt;int&gt;&gt; ans;
        &#x2F;&#x2F; 枚举 a
        for (int first &#x3D; 0; first &lt; n; ++first) &#123;
            &#x2F;&#x2F; 需要和上一次枚举的数不相同
            if (first &gt; 0 &amp;&amp; nums[first] &#x3D;&#x3D; nums[first - 1]) &#123;
                continue;
            &#125;
            &#x2F;&#x2F; c 对应的指针初始指向数组的最右端
            int third &#x3D; n - 1;
            int target &#x3D; -nums[first];
            &#x2F;&#x2F; 枚举 b
            for (int second &#x3D; first + 1; second &lt; n; ++second) &#123;
                &#x2F;&#x2F; 需要和上一次枚举的数不相同
                if (second &gt; first + 1 &amp;&amp; nums[second] &#x3D;&#x3D; nums[second - 1]) &#123;
                    continue;
                &#125;
                &#x2F;&#x2F; 需要保证 b 的指针在 c 的指针的左侧
                while (second &lt; third &amp;&amp; nums[second] + nums[third] &gt; target) &#123;
                    --third;
                &#125;
                &#x2F;&#x2F; 如果指针重合，随着 b 后续的增加
                &#x2F;&#x2F; 就不会有满足 a+b+c&#x3D;0 并且 b&lt;c 的 c 了，可以退出循环
                if (second &#x3D;&#x3D; third) &#123;
                    break;
                &#125;
                if (nums[second] + nums[third] &#x3D;&#x3D; target) &#123;
                    ans.push_back(&#123;nums[first], nums[second], nums[third]&#125;);
                &#125;
            &#125;
        &#125;
        return ans;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="1594-矩阵的最大非负积"><a href="#1594-矩阵的最大非负积" class="headerlink" title="1594. 矩阵的最大非负积"></a>1594. 矩阵的最大非负积</h3><p>问题地址：<a href="https://leetcode.cn/problems/maximum-non-negative-product-in-a-matrix/">https://leetcode.cn/problems/maximum-non-negative-product-in-a-matrix/</a></p>
<p>给你一个大小为 <code>m x n</code> 的矩阵 <code>grid</code> 。最初，你位于左上角 <code>(0, 0)</code> ，每一步，你可以在矩阵中 <code>向右</code> 或 <code>向下</code> 移动。</p>
<p>在从左上角 <code>(0, 0)</code> 开始到右下角 <code>(m - 1, n - 1)</code> 结束的所有路径中，找出具有 <code>最大非负积</code> 的路径。路径的积是沿路径访问的单元格中所有整数的乘积。</p>
<p>返回 最大非负积 对 109 + 7 取余 的结果。如果最大积为 <code>负数</code> ，则返回 <code>-1</code> 。</p>
<p>注意，取余是在得到最大积之后执行的。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int maxProductPath(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;
        const int mod &#x3D; 1000000000 + 7;
        int m &#x3D; grid.size(), n &#x3D; grid[0].size();
        vector&lt;vector&lt;long long&gt;&gt; maxgt(m, vector&lt;long long&gt;(n));
        vector&lt;vector&lt;long long&gt;&gt; minlt(m, vector&lt;long long&gt;(n));

        maxgt[0][0] &#x3D; minlt[0][0] &#x3D; grid[0][0];
        for (int i &#x3D; 1; i &lt; n; i++) &#123;
            maxgt[0][i] &#x3D; minlt[0][i] &#x3D; maxgt[0][i - 1] * grid[0][i];
        &#125;
        for (int i &#x3D; 1; i &lt; m; i++) &#123;
            maxgt[i][0] &#x3D; minlt[i][0] &#x3D; maxgt[i - 1][0] * grid[i][0];
        &#125;

        for (int i &#x3D; 1; i &lt; m; i++) &#123;
            for (int j &#x3D; 1; j &lt; n; j++) &#123;
                if (grid[i][j] &gt;&#x3D; 0) &#123;
                    maxgt[i][j] &#x3D; max(maxgt[i][j - 1], maxgt[i - 1][j]) * grid[i][j];
                    minlt[i][j] &#x3D; min(minlt[i][j - 1], minlt[i - 1][j]) * grid[i][j];
                &#125; else &#123;
                    maxgt[i][j] &#x3D; min(minlt[i][j - 1], minlt[i - 1][j]) * grid[i][j];
                    minlt[i][j] &#x3D; max(maxgt[i][j - 1], maxgt[i - 1][j]) * grid[i][j];
                &#125;
            &#125;
        &#125;
        if (maxgt[m - 1][n - 1] &lt; 0) &#123;
            return -1;
        &#125; else &#123;
            return maxgt[m - 1][n - 1] % mod;
        &#125;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="面试题-16-16-部分排序"><a href="#面试题-16-16-部分排序" class="headerlink" title="面试题 16.16. 部分排序"></a>面试题 16.16. 部分排序</h3><p>问题地址：<a href="https://leetcode.cn/problems/sub-sort-lcci/">https://leetcode.cn/problems/sub-sort-lcci/</a></p>
<p>给定一个整数数组，编写一个函数，找出索引<code>m</code>和<code>n</code>，只要将索引区间<code>[m,n]</code>的元素排好序，整个数组就是有序的。注意：<code>n-m</code>尽量最小，也就是说，找出符合条件的最短序列。函数返回值为<code>[m,n]</code>，若不存在这样的<code>m</code>和<code>n</code>（例如整个数组是有序的），请返回<code>[-1,-1]</code>。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    vector&lt;int&gt; subSort(vector&lt;int&gt;&amp; array) &#123;
        int n &#x3D; array.size();
        int maxx &#x3D; INT_MIN, minn &#x3D; INT_MAX;
        int l &#x3D; -1, r &#x3D; -1;
        for (int i &#x3D; 0; i &lt; n; ++i) &#123;
            if (array[i] &lt; maxx) r &#x3D; i;
            else maxx &#x3D; array[i];
        &#125;
        for (int i &#x3D; n - 1; i &gt;&#x3D; 0; --i) &#123;
            if (array[i] &gt; minn) l &#x3D; i;
            else minn &#x3D; array[i];
        &#125;
        return &#123;l, r&#125;;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="328-奇偶链表"><a href="#328-奇偶链表" class="headerlink" title="328. 奇偶链表"></a>328. 奇偶链表</h3><p>问题地址：<a href="https://leetcode.cn/problems/odd-even-linked-list/">https://leetcode.cn/problems/odd-even-linked-list/</a></p>
<p>给定单链表的头节点 head ，将所有索引为奇数的节点和索引为偶数的节点分别组合在一起，然后返回重新排序的列表。</p>
<p>第一个节点的索引被认为是 奇数 ， 第二个节点的索引为 偶数 ，以此类推。</p>
<p>请注意，偶数组和奇数组内部的相对顺序应该与输入时保持一致。</p>
<p>你必须在 O(1) 的额外空间复杂度和 O(n) 的时间复杂度下解决这个问题。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;**
 * Definition for singly-linked list.
 * struct ListNode &#123;
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) &#123;&#125;
 *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;
 *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;
 * &#125;;
 *&#x2F;
class Solution &#123;
public:
    ListNode* oddEvenList(ListNode* head) &#123;
        if (head &#x3D;&#x3D; nullptr) &#123;
            return head;
        &#125;
        ListNode * evenHead &#x3D; head-&gt;next;
        ListNode * odd &#x3D; head;
        ListNode * even &#x3D; evenHead;
        while (even !&#x3D; nullptr &amp;&amp; even-&gt;next !&#x3D; nullptr) &#123;
            odd-&gt;next &#x3D; even-&gt;next;
            odd &#x3D; odd-&gt;next;
            even-&gt;next &#x3D; odd-&gt;next;
            even &#x3D; even-&gt;next;
        &#125;
        odd-&gt;next &#x3D; evenHead;
        return head;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="994-腐烂的橘子"><a href="#994-腐烂的橘子" class="headerlink" title="994. 腐烂的橘子"></a>994. 腐烂的橘子</h3><p>问题地址：<a href="https://leetcode.cn/problems/rotting-oranges/">https://leetcode.cn/problems/rotting-oranges/</a></p>
<p>在给定的 <code>m x n</code> 网格 <code>grid</code> 中，每个单元格可以有以下三个值之一：</p>
<ul>
<li>值 0 代表空单元格；</li>
<li>值 1 代表新鲜橘子；</li>
<li>值 2 代表腐烂的橘子。</li>
</ul>
<p>每分钟，腐烂的橘子 <code>周围 4 个方向上相邻</code> 的新鲜橘子都会腐烂。</p>
<p>返回 直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 <code>-1</code> 。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
private:
    int cnt;
    int dis[10][10];
    int dir_x[4] &#x3D; &#123;0, 1, 0, -1&#125;;
    int dir_y[4] &#x3D; &#123;1, 0, -1, 0&#125;;
public:
    int orangesRotting(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;
        queue&lt;pair&lt;int, int&gt;&gt; Q;
        memset(dis, -1, sizeof(dis));
        cnt &#x3D; 0;
        int m &#x3D; (int)grid.size(), n &#x3D; (int)grid[0].size(), ans &#x3D; 0;
        for (int i &#x3D; 0; i &lt; m; ++i) &#123;
            for (int j &#x3D; 0; j &lt; n; ++j) &#123;
                if (grid[i][j] &#x3D;&#x3D; 2) &#123;
                    Q.push(make_pair(i, j));
                    dis[i][j] &#x3D; 0;
                &#125;
                else if (grid[i][j] &#x3D;&#x3D; 1) cnt +&#x3D; 1;
            &#125;
        &#125;
        while (!Q.empty()) &#123;
            pair&lt;int, int&gt; x &#x3D; Q.front();
            Q.pop();
            for (int i &#x3D; 0; i &lt; 4; i++) &#123;
                int tx &#x3D; x.first + dir_x[i];
                int ty &#x3D; x.second + dir_y[i];
                if (tx &lt; 0 || tx &gt;&#x3D; m || ty &lt; 0 || ty &gt;&#x3D; n || ~dis[tx][ty] || !grid[tx][ty]) continue;
                dis[tx][ty] &#x3D; dis[x.first][x.second] + 1;
                Q.push(make_pair(tx, ty));
                if (grid[tx][ty] &#x3D;&#x3D; 1) &#123;
                    cnt -&#x3D; 1;
                    ans &#x3D; dis[tx][ty];
                &#125; 
            &#125;
            if (!cnt) break;
        &#125;
        return cnt ? -1 : ans;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="919-完全二叉树插入器"><a href="#919-完全二叉树插入器" class="headerlink" title="919. 完全二叉树插入器"></a>919. 完全二叉树插入器</h3><p>问题地址：<a href="https://leetcode.cn/problems/complete-binary-tree-inserter/">https://leetcode.cn/problems/complete-binary-tree-inserter/</a></p>
<p><code>完全二叉树</code> 是每一层（除最后一层外）都是完全填充（即，节点数达到最大）的，并且所有的节点都尽可能地集中在左侧。</p>
<p>设计一种算法，将一个新节点插入到一个完整的二叉树中，并在插入后保持其完整。</p>
<p>实现 <code>CBTInserter</code> 类:</p>
<ul>
<li><code>CBTInserter(TreeNode root)</code> 使用头节点为 <code>root</code> 的给定树初始化该数据结构；</li>
<li><code>CBTInserter.insert(int v)</code>  向树中插入一个值为 <code>Node.val == val</code> 的新节点 <code>TreeNode</code>。使树保持完全二叉树的状态，<code>并返回插入节点 TreeNode 的父节点的值</code>；</li>
<li><code>CBTInserter.get_root()</code> 将返回树的头节点。</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;**
 * Definition for a binary tree node.
 * struct TreeNode &#123;
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;
 * &#125;;
 *&#x2F;
class CBTInserter &#123;
public:
    CBTInserter(TreeNode* root) &#123;
        this-&gt;root &#x3D; root;
        
        queue&lt;TreeNode *&gt; q;
        q.push(root);

        while (!q.empty()) &#123;
            TreeNode * node &#x3D; q.front();
            q.pop();
            if (node-&gt;left) &#123;
                q.push(node-&gt;left);
            &#125;
            if (node-&gt;right) &#123;
                q.push(node-&gt;right);
            &#125;
            if (!(node-&gt;left &amp;&amp; node-&gt;right)) &#123;
                candidate.push(node);
            &#125;
        &#125;
    &#125;
    
    int insert(int val) &#123;
        TreeNode * child &#x3D; new TreeNode(val);
        TreeNode * node &#x3D; candidate.front();
        int ret &#x3D; node-&gt;val;
        if (!node-&gt;left) &#123;
            node-&gt;left &#x3D; child;
        &#125; else &#123;
            node-&gt;right &#x3D; child;
            candidate.pop();
        &#125;
        candidate.push(child);
        return ret;
    &#125;
    
    TreeNode* get_root() &#123;
        return root;
    &#125;
    
private:
    queue&lt;TreeNode *&gt; candidate;
    TreeNode * root;
&#125;;

&#x2F;**
 * Your CBTInserter object will be instantiated and called as such:
 * CBTInserter* obj &#x3D; new CBTInserter(root);
 * int param_1 &#x3D; obj-&gt;insert(val);
 * TreeNode* param_2 &#x3D; obj-&gt;get_root();
 *&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="2550-猴子碰撞的方法数"><a href="#2550-猴子碰撞的方法数" class="headerlink" title="2550. 猴子碰撞的方法数"></a>2550. 猴子碰撞的方法数</h3><p>问题地址：<a href="https://leetcode.cn/problems/count-collisions-of-monkeys-on-a-polygon/">https://leetcode.cn/problems/count-collisions-of-monkeys-on-a-polygon/</a></p>
<p>现在有一个正凸多边形，其上共有 n 个顶点。顶点按顺时针方向从 0 到 n - 1 依次编号。每个顶点上 正好有一只猴子 。下图中是一个 6 个顶点的凸多边形。</p>
<p>每个猴子同时移动到相邻的顶点。顶点 i 的相邻顶点可以是：</p>
<ul>
<li>顺时针方向的顶点 (i + 1) % n ，或</li>
<li>逆时针方向的顶点 (i - 1 + n) % n 。</li>
</ul>
<p>如果移动后至少有两只猴子停留在同一个顶点上或者相交在一条边上，则会发生 <code>碰撞</code> 。</p>
<p>返回猴子至少发生 <code>一次碰撞</code> 的移动方法数。由于答案可能非常大，请返回对 $10^9+7$ 取余后的结果。</p>
<p>注意，每只猴子只能移动一次。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">using INT &#x3D; long long;

class Solution &#123;
public:
    INT pow(INT x, INT N) &#123;
        INT ans &#x3D; 1;
        while (N) &#123;
            if (N &amp; 1) &#123;
                ans &#x3D; ((ans % mod) * (x % mod)) % mod;
            &#125;
            x &#x3D; (x % mod) * (x % mod);
            N &gt;&gt;&#x3D; 1;
        &#125;
        return ans % mod;
    &#125;
    int monkeyMove(int n) &#123;
        return (pow(2, n) - 2 + mod) % mod;
    &#125;

private:
    const INT mod &#x3D; 1e9 + 7;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="LCP-41-黑白翻转棋"><a href="#LCP-41-黑白翻转棋" class="headerlink" title="LCP 41. 黑白翻转棋"></a>LCP 41. 黑白翻转棋</h3><p>问题地址：<a href="https://leetcode.cn/problems/fHi6rV/">https://leetcode.cn/problems/fHi6rV/</a></p>
<p>在 n*m 大小的棋盘中，有黑白两种棋子，黑棋记作字母 “X”, 白棋记作字母 “O”，空余位置记作 “.”。当落下的棋子与其他相同颜色的棋子在行、列或对角线完全包围（中间不存在空白位置）另一种颜色的棋子，则可以翻转这些棋子的颜色。</p>
<p>「力扣挑战赛」黑白翻转棋项目中，将提供给选手一个未形成可翻转棋子的棋盘残局，其状态记作 chessboard。若下一步可放置一枚黑棋，请问选手最多能翻转多少枚白棋。</p>
<p>注意：</p>
<ul>
<li>若翻转白棋成黑棋后，棋盘上仍存在可以翻转的白棋，将可以 <code>继续</code> 翻转白棋</li>
<li>输入数据保证初始棋盘状态无可以翻转的棋子且存在空余位置</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    const int dirs[8][2] &#x3D; &#123;
        &#123;1, 0&#125;, &#123;-1, 0&#125;, &#123;0, 1&#125;, &#123;0, -1&#125;,
        &#123;1, 1&#125;, &#123;1, -1&#125;, &#123;-1, 1&#125;, &#123;-1, -1&#125;
    &#125;;

    bool judge(const vector&lt;string&gt;&amp; chessboard, int x, int y, int dx, int dy) &#123;
        x +&#x3D; dx;
        y +&#x3D; dy;
        while (0 &lt;&#x3D; x &amp;&amp; x &lt; chessboard.size() &amp;&amp; 0 &lt;&#x3D; y &amp;&amp; y &lt; chessboard[0].size()) &#123;
            if (chessboard[x][y] &#x3D;&#x3D; &#39;X&#39;) &#123;
                return true;
            &#125; else if (chessboard[x][y] &#x3D;&#x3D; &#39;.&#39;) &#123;
                return false;
            &#125;
            x +&#x3D; dx;
            y +&#x3D; dy;
        &#125;
        return false;
    &#125;

    int bfs(vector&lt;string&gt; chessboard, int px, int py) &#123;
        int cnt &#x3D; 0;
        queue&lt;pair&lt;int, int&gt;&gt; q;
        q.emplace(px, py);
        chessboard[px][py] &#x3D; &#39;X&#39;;
        while (!q.empty()) &#123;
            pair&lt;int, int&gt; t &#x3D; q.front();
            q.pop();
            for (int i &#x3D; 0; i &lt; 8; ++i) &#123;
                if (judge(chessboard, t.first, t.second, dirs[i][0], dirs[i][1])) &#123;
                    int x &#x3D; t.first + dirs[i][0], y &#x3D; t.second + dirs[i][1];
                    while (chessboard[x][y] !&#x3D; &#39;X&#39;) &#123;
                        q.emplace(x, y);
                        chessboard[x][y] &#x3D; &#39;X&#39;;
                        x +&#x3D; dirs[i][0];
                        y +&#x3D; dirs[i][1];
                        ++cnt;
                    &#125;
                &#125;
            &#125;
        &#125;
        return cnt;
    &#125;

    int flipChess(vector&lt;string&gt;&amp; chessboard) &#123;
        int res &#x3D; 0;
        for (int i &#x3D; 0; i &lt; chessboard.size(); ++i) &#123;
            for (int j &#x3D; 0; j &lt; chessboard[0].size(); ++j) &#123;
                if (chessboard[i][j] &#x3D;&#x3D; &#39;.&#39;) &#123;
                    res &#x3D; max(res, bfs(chessboard, i, j));
                &#125;
            &#125;
        &#125;
        return res;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="1249-移除无效的括号"><a href="#1249-移除无效的括号" class="headerlink" title="1249. 移除无效的括号"></a>1249. 移除无效的括号</h3><p>问题地址：<a href="https://leetcode.cn/problems/minimum-remove-to-make-valid-parentheses/">https://leetcode.cn/problems/minimum-remove-to-make-valid-parentheses/</a></p>
<p>给你一个由 <code>&#39;(&#39;</code>、<code>&#39;)&#39;</code> 和小写字母组成的字符串 s。</p>
<p>你需要从字符串中删除最少数目的 <code>&#39;(&#39;</code> 或者 <code>&#39;)&#39;</code> （可以删除任意位置的括号)，使得剩下的「括号字符串」有效。</p>
<p>请返回任意一个合法字符串。</p>
<p>有效<code>「括号字符串」</code>应当符合以下 任意一条 要求：</p>
<ul>
<li>空字符串或只包含小写字母的字符串</li>
<li>可以被写作 AB（A 连接 B）的字符串，其中 A 和 B 都是有效<code>「括号字符串」</code></li>
<li>可以被写作 (A) 的字符串，其中 A 是一个有效的<code>「括号字符串」</code></li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    string minRemoveToMakeValid(string s) &#123;
        stack&lt;int&gt; stk1;
        stack&lt;char&gt; stk2;
        for (int m &#x3D; 0; m &lt; s.size(); m++) &#123;
            if(s[m] &#x3D;&#x3D; &#39;(&#39;) &#123;
                stk1.push(m);
                stk2.push(s[m]);
            &#125; else if(s[m] &#x3D;&#x3D; &#39;)&#39;) &#123;
                if (!stk2.empty() &amp;&amp; stk2.top() &#x3D;&#x3D; &#39;(&#39;) &#123;
                    stk1.pop();
                    stk2.pop();
                &#125; else &#123;
                    stk1.push(m);
                    stk2.push(s[m]);
                &#125;
            &#125;
        &#125;
        while(!stk1.empty()) &#123;
            s[stk1.top()] &#x3D; &#39;*&#39;;
            stk1.pop();
        &#125;
        string ans &#x3D; &quot;&quot;;
        for (auto x : s) &#123;
            if (x !&#x3D; &#39;*&#39;) &#123;
                ans +&#x3D; x;
            &#125;
        &#125;
        return ans;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="1234-替换子串得到平衡字符串"><a href="#1234-替换子串得到平衡字符串" class="headerlink" title="1234. 替换子串得到平衡字符串"></a>1234. 替换子串得到平衡字符串</h3><p>问题地址：<a href="https://leetcode.cn/problems/replace-the-substring-for-balanced-string/">https://leetcode.cn/problems/replace-the-substring-for-balanced-string/</a></p>
<p>有一个只含有 <code>&#39;Q&#39;</code>, <code>&#39;W&#39;</code>, <code>&#39;E&#39;</code>, <code>&#39;R&#39;</code> 四种字符，且长度为 <code>n</code> 的字符串。</p>
<p>假如在该字符串中，这四个字符都恰好出现 <code>n/4</code> 次，那么它就是一个<code>「平衡字符串」</code>。</p>
<p>给你一个这样的字符串 <code>s</code>，请通过<code>「替换一个子串」</code>的方式，使原字符串 <code>s</code> 变成一个<code>「平衡字符串」</code>。</p>
<p>你可以用和<code>「待替换子串」</code>长度相同的 <code>任何</code> 其他字符串来完成替换。</p>
<p>请返回待替换子串的最小可能长度。</p>
<p>如果原字符串自身就是一个平衡字符串，则返回 <code>0</code>。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int idx(const char&amp; c) &#123;
        return c - &#39;A&#39;;
    &#125;
    int balancedString(string s) &#123;
        vector&lt;int&gt; cnt(26);
        for (auto c : s) &#123;
            cnt[idx(c)]++;
        &#125;
        int partial &#x3D; s.size() &#x2F; 4;
        int res &#x3D; s.size();
        auto check &#x3D; [&amp;]() &#123;
            if (cnt[idx(&#39;Q&#39;)] &gt; partial || cnt[idx(&#39;W&#39;)] &gt; partial \
                || cnt[idx(&#39;E&#39;)] &gt; partial || cnt[idx(&#39;R&#39;)] &gt; partial) &#123;
                return false;
            &#125;
            return true;
        &#125;;

        if (check()) &#123;
            return 0;
        &#125;

        for (int l &#x3D; 0, r &#x3D; 0; l &lt; s.size(); l++) &#123;
            while (r &lt; s.size() &amp;&amp; !check()) &#123;
                cnt[idx(s[r])]--;
                r++;
            &#125;
            if (!check()) &#123;
                break;
            &#125;
            res &#x3D; min(res, r - l);
            cnt[idx(s[l])]++;
        &#125;
        return res;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="2385-感染二叉树需要的总时间"><a href="#2385-感染二叉树需要的总时间" class="headerlink" title="2385. 感染二叉树需要的总时间"></a>2385. 感染二叉树需要的总时间</h3><p>问题地址：<a href="https://leetcode.cn/problems/amount-of-time-for-binary-tree-to-be-infected/">https://leetcode.cn/problems/amount-of-time-for-binary-tree-to-be-infected/</a></p>
<p>给你一棵二叉树的根节点 root ，二叉树中节点的值 <code>互不相同</code> 。另给你一个整数 start 。在第 0 分钟，感染 将会从值为 start 的节点开始爆发。</p>
<p>每分钟，如果节点满足以下全部条件，就会被感染：</p>
<ul>
<li>节点此前还没有感染。</li>
<li>节点与一个已感染节点相邻。</li>
</ul>
<p>返回感染整棵树需要的分钟数。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;**
 * Definition for a binary tree node.
 * struct TreeNode &#123;
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;
 * &#125;;
 *&#x2F;
class Solution &#123;
public:
    int dfs(TreeNode* root, int start, int sum) &#123;
        if (root &#x3D;&#x3D; nullptr) return -1;
        if (sum &#x3D;&#x3D; -1 &amp;&amp; root-&gt;val &#x3D;&#x3D; start) &#123; &#x2F;&#x2F; 本节点为感染节点
            sum &#x3D; 0;
        &#125;
        if (sum !&#x3D; -1) &#123; &#x2F;&#x2F; 本节点已感染，传递到子树中
            dfs(root-&gt;left, start, sum+1);
            dfs(root-&gt;right, start, sum+1);
            if (sum &gt; max) max &#x3D; sum;
            return sum + 1;
        &#125; else &#123;
            int tem &#x3D; dfs(root-&gt;left, start, sum);
            if (tem !&#x3D; -1) &#123; &#x2F;&#x2F; 左子树被感染，传递到右子树
                sum &#x3D; tem;
                dfs(root-&gt;right, start, sum+1);
            &#125; else &#123; &#x2F;&#x2F; 右子树被感染，传递到左子树
                sum &#x3D; dfs(root-&gt;right, start, sum);
                dfs(root-&gt;left, start, sum+1);
            &#125;
        &#125;
        if (sum &gt; max) max &#x3D; sum;
        if (sum !&#x3D; -1) return sum + 1;
        return -1;
    &#125;
    int amountOfTime(TreeNode * root, int start) &#123;
        dfs(root, start, -1);
        return max;
    &#125;

private:
    int max &#x3D; 0;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="面试题-05-04-下一个数"><a href="#面试题-05-04-下一个数" class="headerlink" title="面试题 05.04. 下一个数"></a>面试题 05.04. 下一个数</h3><p>问题地址：<a href="https://leetcode.cn/problems/closed-number-lcci/">https://leetcode.cn/problems/closed-number-lcci/</a></p>
<p>下一个数。给定一个正整数，找出与其二进制表达式中1的个数相同且大小最接近的那两个数（一个略大，一个略小）。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
   public:
    vector&lt;int&gt; findClosedNumbers(int num) &#123;
        bitset&lt;32&gt; small(num);
        bitset&lt;32&gt; bigger(num);

        int s &#x3D; -1;
        &#x2F;&#x2F; small, 10 转 01，1移到左侧
        for (int i &#x3D; 1; i &lt; 32; i++) &#123;
            if (small[i] &#x3D;&#x3D; 1 &amp;&amp; small[i - 1] &#x3D;&#x3D; 0) &#123;
                small.flip(i);
                small.flip(i - 1);
                for (int left &#x3D; 0, right &#x3D; i - 2; left &lt; right;) &#123;
                    while (left &lt; right &amp;&amp; small[left] &#x3D;&#x3D; 0) left++;
                    while (left &lt; right &amp;&amp; small[right] &#x3D;&#x3D; 1) right--;
                    small.flip(left);
                    small.flip(right);
                &#125;
                s &#x3D; (int)small.to_ulong();
                break;
            &#125;
        &#125;

        &#x2F;&#x2F; bigger, 01转10，1移到最右侧
        &#x2F;&#x2F; bigger要保证正数，最高符号位保证为 0
        int b &#x3D; -1;
        for (int i &#x3D; 1; i &lt; 31; i++) &#123;
            if (bigger[i] &#x3D;&#x3D; 0 &amp;&amp; bigger[i - 1] &#x3D;&#x3D; 1) &#123;
                bigger.flip(i);
                bigger.flip(i - 1);

                for (int left &#x3D; 0, right &#x3D; i - 2; left &lt; right;) &#123;
                    while (left &lt; right &amp;&amp; bigger[left] &#x3D;&#x3D; 1) left++;
                    while (left &lt; right &amp;&amp; bigger[right] &#x3D;&#x3D; 0) right--;
                    bigger.flip(left);
                    bigger.flip(right);
                &#125;
                b &#x3D; (int)bigger.to_ulong();
                break;
            &#125;
        &#125;

        return &#123;b, s&#125;;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="712-两个字符串的最小ASCII删除和"><a href="#712-两个字符串的最小ASCII删除和" class="headerlink" title="712. 两个字符串的最小ASCII删除和"></a>712. 两个字符串的最小ASCII删除和</h3><p>问题地址：<a href="https://leetcode.cn/problems/minimum-ascii-delete-sum-for-two-strings/">https://leetcode.cn/problems/minimum-ascii-delete-sum-for-two-strings/</a></p>
<p>给定两个字符串s1 和 s2，返回 使两个字符串相等所需删除字符的 ASCII 值的最小和 。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int minimumDeleteSum(string s1, string s2) &#123;
        int m &#x3D; s1.size();
        int n &#x3D; s2.size();
        vector&lt;vector&lt;int&gt;&gt; dp(m + 1, vector&lt;int&gt;(n + 1));

        for (int i &#x3D; 1; i &lt;&#x3D; m; ++i) &#123;
            dp[i][0] &#x3D; dp[i - 1][0] + s1[i - 1];
        &#125;

        for (int j &#x3D; 1; j &lt;&#x3D; n; ++j) &#123;
            dp[0][j] &#x3D; dp[0][j - 1] + s2[j - 1];
        &#125;

        for (int i &#x3D; 1; i &lt;&#x3D; m; i++) &#123;
            char c1 &#x3D; s1[i - 1];
            for (int j &#x3D; 1; j &lt;&#x3D; n; j++) &#123;
                char c2 &#x3D; s2[j - 1];
                if (c1 &#x3D;&#x3D; c2) &#123;
                    dp[i][j] &#x3D; dp[i - 1][j - 1];
                &#125; else &#123;
                    dp[i][j] &#x3D; min(dp[i - 1][j] + s1[i - 1], dp[i][j - 1] + s2[j - 1]);
                &#125;
            &#125;
        &#125;

        return dp[m][n];
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="1253-重构-2-行二进制矩阵"><a href="#1253-重构-2-行二进制矩阵" class="headerlink" title="1253. 重构 2 行二进制矩阵"></a>1253. 重构 2 行二进制矩阵</h3><p>问题地址：<a href="https://leetcode.cn/problems/reconstruct-a-2-row-binary-matrix/">https://leetcode.cn/problems/reconstruct-a-2-row-binary-matrix/</a></p>
<p>给你一个 2 行 n 列的二进制数组：</p>
<ul>
<li>矩阵是一个二进制矩阵，这意味着矩阵中的每个元素不是 0 就是 1。</li>
<li>第 0 行的元素之和为 upper。</li>
<li>第 1 行的元素之和为 lower。</li>
<li>第 i 列（从 0 开始编号）的元素之和为 <code>colsum[i]</code>，colsum 是一个长度为 n 的整数数组。</li>
</ul>
<p>你需要利用 upper，lower 和 colsum 来重构这个矩阵，并以二维整数数组的形式返回它。</p>
<p>如果有多个不同的答案，那么任意一个都可以通过本题。</p>
<p>如果不存在符合要求的答案，就请返回一个空的二维数组。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    vector&lt;vector&lt;int&gt;&gt; reconstructMatrix(int upper, int lower, vector&lt;int&gt;&amp; colsum) &#123;
        int n &#x3D; colsum.size();
        int sum &#x3D; 0, two &#x3D; 0;
        for (int i &#x3D; 0; i &lt; n; ++i) &#123;
            if (colsum[i] &#x3D;&#x3D; 2) &#123;
                ++two;
            &#125;
            sum +&#x3D; colsum[i];
        &#125;
        if (sum !&#x3D; upper + lower || min(upper, lower) &lt; two) &#123;
            return &#123;&#125;;
        &#125;
        upper -&#x3D; two;
        lower -&#x3D; two;
        vector&lt;vector&lt;int&gt;&gt; res(2, vector&lt;int&gt;(n, 0));
        for (int i &#x3D; 0; i &lt; n; ++i) &#123;
            if (colsum[i] &#x3D;&#x3D; 2) &#123;
                res[0][i] &#x3D; res[1][i] &#x3D; 1;
            &#125; else if (colsum[i] &#x3D;&#x3D; 1) &#123;
                if (upper &gt; 0) &#123;
                    res[0][i] &#x3D; 1;
                    --upper;
                &#125; else &#123;
                    res[1][i] &#x3D; 1;
                &#125;
            &#125;
        &#125;
        return res;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="229-多数元素-II"><a href="#229-多数元素-II" class="headerlink" title="229. 多数元素 II"></a>229. 多数元素 II</h3><p>问题地址：<a href="https://leetcode.cn/problems/majority-element-ii/">https://leetcode.cn/problems/majority-element-ii/</a></p>
<p>给定一个大小为 n 的整数数组，找出其中所有出现超过 <code>⌊ n/3 ⌋</code> 次的元素。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    vector&lt;int&gt; majorityElement(vector&lt;int&gt;&amp; nums) &#123;
        int n &#x3D; nums.size();
        vector&lt;int&gt; ans;
        unordered_map&lt;int, int&gt; cnt;

        for (auto &amp; v : nums) &#123;
            cnt[v]++;
        &#125;

        for (auto &amp; v : cnt) &#123;
            if (v.second &gt; n &#x2F;3) &#123;
                ans.push_back(v.first);
            &#125;
        &#125;

        return ans;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="1870-准时到达的列车最小时速"><a href="#1870-准时到达的列车最小时速" class="headerlink" title="1870. 准时到达的列车最小时速"></a>1870. 准时到达的列车最小时速</h3><p>给你一个浮点数 hour ，表示你到达办公室可用的总通勤时间。要到达办公室，你必须按给定次序乘坐 n 趟列车。另给你一个长度为 n 的整数数组 dist ，其中 <code>dist[i]</code> 表示第 i 趟列车的行驶距离（单位是千米）。</p>
<p>每趟列车均只能在整点发车，所以你可能需要在两趟列车之间等待一段时间。</p>
<ul>
<li>例如，第 1 趟列车需要 1.5 小时，那你必须再等待 0.5 小时，搭乘在第 2 小时发车的第 2 趟列车。</li>
</ul>
<p>返回能满足你准时到达办公室所要求全部列车的 最小正整数 时速（单位：千米每小时），如果无法准时到达，则返回 -1 。</p>
<p>生成的测试用例保证答案不超过 107 ，且 hour 的 小数点后最多存在两位数字 。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int minSpeedOnTime(vector&lt;int&gt;&amp; dist, double hour) &#123;
        int n &#x3D; dist.size();
        &#x2F;&#x2F; 将 hour 乘 100 以转为整数
        long long hr &#x3D; llround(hour * 100);
        &#x2F;&#x2F; 时间必须要大于路程段数减 1
        if (hr &lt;&#x3D; (n - 1) * 100)&#123;
            return -1;
        &#125;
        &#x2F;&#x2F; 二分
        int l &#x3D; 1;
        int r &#x3D; 1e7;
        while (l &lt; r)&#123;
            int mid &#x3D; l + (r - l) &#x2F; 2;
            &#x2F;&#x2F; 判断当前时速是否满足时限
            long long t &#x3D; 0;
            for (int i &#x3D; 0; i &lt; n - 1; ++i)&#123;
                t +&#x3D; (dist[i] - 1) &#x2F; mid + 1;
            &#125;
            t *&#x3D; mid;
            t +&#x3D; dist[n-1];
            if (t * 100 &lt;&#x3D; hr * mid)&#123;   &#x2F;&#x2F; 通分以转化为整数比较
                r &#x3D; mid;
            &#125;
            else&#123;
                l &#x3D; mid + 1;
            &#125;
        &#125;
        return l;   &#x2F;&#x2F; 满足条件的最小时速
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="1864-构成交替字符串需要的最小交换次数"><a href="#1864-构成交替字符串需要的最小交换次数" class="headerlink" title="1864. 构成交替字符串需要的最小交换次数"></a>1864. 构成交替字符串需要的最小交换次数</h3><p>问题地址：<a href="https://leetcode.cn/problems/minimum-number-of-swaps-to-make-the-binary-string-alternating/">https://leetcode.cn/problems/minimum-number-of-swaps-to-make-the-binary-string-alternating/</a></p>
<p>给你一个二进制字符串 s ，现需要将其转化为一个 交替字符串 。请你计算并返回转化所需的 最小 字符交换次数，如果无法完成转化，返回 -1 。</p>
<p>交替字符串 是指：相邻字符之间不存在相等情况的字符串。例如，字符串 “010” 和 “1010” 属于交替字符串，但 “0100” 不是。</p>
<p>任意两个字符都可以进行交换，不必相邻 。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int minSwaps(string s) &#123;
        int s0n0 &#x3D; 0, s0n1 &#x3D; 0;
        int s1n0 &#x3D; 0, s1n1 &#x3D; 0;

        for (int c &#x3D; 0; c &lt; s.size(); c++) &#123;
            if (c % 2 &#x3D;&#x3D; 0) &#123;
                if (s[c] !&#x3D; &#39;0&#39;) s0n0++;
                else s1n1++;
            &#125; else &#123;
                if (s[c] !&#x3D; &#39;1&#39;) s0n1++;
                else s1n0++;
            &#125;
        &#125;

        if (s0n0 !&#x3D; s0n1 &amp;&amp; s1n0 !&#x3D; s1n1) return -1;
        if (s0n0 &#x3D;&#x3D; s0n1 &amp;&amp; s1n0 !&#x3D; s1n1) return s0n0;
        if (s0n0 !&#x3D; s0n1 &amp;&amp; s1n0 &#x3D;&#x3D; s1n1) return s1n0;
        return min(s0n0, s1n0);
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a>3. 无重复字符的最长子串</h3><p>问题地址：<a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">https://leetcode.cn/problems/longest-substring-without-repeating-characters/</a></p>
<p>给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int lengthOfLongestSubstring(string s) &#123;
        unordered_set&lt;char&gt; occ;
        int n &#x3D; s.size();
        int rk &#x3D; -1, ans &#x3D; 0;
        for (int i &#x3D; 0; i &lt; n; ++i) &#123;
            if (i !&#x3D; 0) &#123;
                occ.erase(s[i - 1]);
            &#125;
            while (rk + 1 &lt; n &amp;&amp; !occ.count(s[rk + 1])) &#123;
                occ.insert(s[rk + 1]);
                ++rk;
            &#125;
            ans &#x3D; max(ans, rk - i + 1);
        &#125;
        return ans;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5. 最长回文子串"></a>5. 最长回文子串</h3><p>问题地址：<a href="https://leetcode.cn/problems/longest-palindromic-substring/">https://leetcode.cn/problems/longest-palindromic-substring/</a></p>
<p>给你一个字符串 s，找到 s 中最长的回文子串。</p>
<p>如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    string longestPalindrome(string s) &#123;
        int start &#x3D; 0, end &#x3D; 0;
        for (int i &#x3D; 0; i &lt; s.size(); ++i) &#123;
            auto [left1, right1] &#x3D; expandAroundCenter(s, i, i);
            auto [left2, right2] &#x3D; expandAroundCenter(s, i, i + 1);
            if (right1 - left1 &gt; end - start) &#123;
                start &#x3D; left1;
                end &#x3D; right1;
            &#125;
            if (right2 - left2 &gt; end - start) &#123;
                start &#x3D; left2;
                end &#x3D; right2;
            &#125;
        &#125;
        return s.substr(start, end - start + 1);
    &#125;
    pair&lt;int, int&gt; expandAroundCenter(const string&amp; s, int left, int right) &#123;
        while (left &gt;&#x3D; 0 &amp;&amp; right &lt; s.size() &amp;&amp; s[left] &#x3D;&#x3D; s[right]) &#123;
            --left;
            ++right;
        &#125;
        return &#123;left + 1, right - 1&#125;;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="6-N-字形变换"><a href="#6-N-字形变换" class="headerlink" title="6. N 字形变换"></a>6. N 字形变换</h3><p>问题地址：<a href="https://leetcode.cn/problems/zigzag-conversion/">https://leetcode.cn/problems/zigzag-conversion/</a></p>
<p>将一个给定字符串 s 根据给定的行数 <code>numRows</code> ，以从上往下、从左到右进行 Z 字形排列。</p>
<p>比如输入字符串为 “PAYPALISHIRING” 行数为 3 时，排列如下：</p>
<pre class="line-numbers language-none"><code class="language-none">P   A   H   N
A P L S I I G
Y   I   R<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：”PAHNAPLSIIGYIR”。</p>
<p>请你实现这个将字符串进行指定行数变换的函数：</p>
<pre class="line-numbers language-none"><code class="language-none">string convert(string s, int numRows);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    string convert(string s, int numRows) &#123;
        int n &#x3D; s.length(), r &#x3D; numRows;
        if (r &#x3D;&#x3D; 1 || r &gt;&#x3D; n) &#123;
            return s;
        &#125;
        vector&lt;string&gt; mat(r);
        for (int i &#x3D; 0, x &#x3D; 0, t &#x3D; r * 2 - 2; i &lt; n; ++i) &#123;
            mat[x] +&#x3D; s[i];
            i % t &lt; r - 1 ? ++x : --x;
        &#125;
        string ans;
        for (auto &amp;row : mat) &#123;
            ans +&#x3D; row;
        &#125;
        return ans;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="7-整数反转"><a href="#7-整数反转" class="headerlink" title="7. 整数反转"></a>7. 整数反转</h3><p>问题地址：<a href="https://leetcode.cn/problems/reverse-integer/">https://leetcode.cn/problems/reverse-integer/</a></p>
<p>给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。</p>
<p>如果反转后整数超过 32 位的有符号整数的范围 <code>[−231,  231 − 1]</code> ，就返回 0。</p>
<p>假设环境不允许存储 64 位整数（有符号或无符号）。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int reverse(int x) &#123;
        int rev &#x3D; 0;
        while (x !&#x3D; 0) &#123;
            if (rev &lt; INT_MIN &#x2F; 10 || rev &gt; INT_MAX &#x2F; 10) &#123;
                return 0;
            &#125;
            int digit &#x3D; x % 10;
            x &#x2F;&#x3D; 10;
            rev &#x3D; rev * 10 + digit;
        &#125;
        return rev;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="8-字符串转换整数-atoi"><a href="#8-字符串转换整数-atoi" class="headerlink" title="8. 字符串转换整数 (atoi)"></a>8. 字符串转换整数 (atoi)</h3><p>问题地址：<a href="https://leetcode.cn/problems/string-to-integer-atoi/">https://leetcode.cn/problems/string-to-integer-atoi/</a></p>
<p>请你来实现一个 myAtoi(string s) 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C&#x2F;C++ 中的 atoi 函数）。</p>
<p>函数 myAtoi(string s) 的算法如下：</p>
<ol>
<li>读入字符串并丢弃无用的前导空格</li>
<li>检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。</li>
<li>读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。</li>
<li>将前面步骤读入的这些数字转换为整数（即，”123” -&gt; 123， “0032” -&gt; 32）。如果没有读入数字，则整数为 0 。必要时更改符号（从步骤 2 开始）。</li>
<li>如果整数数超过 32 位有符号整数范围 [−231,  231 − 1] ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 −231 的整数应该被固定为 −231 ，大于 231 − 1 的整数应该被固定为 231 − 1 。</li>
<li>返回整数作为最终结果。</li>
</ol>
<p>注意：</p>
<ul>
<li>本题中的空白字符只包括空格字符 ‘ ‘ 。</li>
<li>除前导空格或数字后的其余字符串外，请勿忽略 任何其他字符。</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int myAtoi(string s) &#123;
        if (s.empty()) return 0;
        int index &#x3D; 0, n &#x3D; s.size(), sign &#x3D; 1, res &#x3D; 0;
        while (index &lt; n &amp;&amp; s[index] &#x3D;&#x3D; &#39; &#39;) &#123;
            ++index;
        &#125;
        if (index &lt; n &amp;&amp; (s[index] &#x3D;&#x3D; &#39;+&#39; || s[index] &#x3D;&#x3D; &#39;-&#39;)) &#123;
            sign &#x3D; s[index++] &#x3D;&#x3D; &#39;+&#39; ? 1 : -1;
        &#125;
        while (index &lt; n &amp;&amp; isdigit(s[index])) &#123;
            int digit &#x3D; s[index] - &#39;0&#39;;
            if (res &gt; (INT_MAX - digit) &#x2F; 10) &#123;
                return sign &#x3D;&#x3D; 1 ? INT_MAX : INT_MIN;
            &#125;
            res &#x3D; res * 10 + digit;
            ++index;
        &#125;
        return res * sign;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11. 盛最多水的容器"></a>11. 盛最多水的容器</h3><p>问题地址：<a href="https://leetcode.cn/problems/container-with-most-water/">https://leetcode.cn/problems/container-with-most-water/</a></p>
<p>给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。</p>
<p>找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p>
<p>返回容器可以储存的最大水量。</p>
<p>说明：你不能倾斜容器。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int maxArea(vector&lt;int&gt;&amp; height) &#123;
        int i &#x3D; 0, j &#x3D; height.size() - 1, res &#x3D; 0;
        while (i &lt; j) &#123;
            res &#x3D; height[i] &lt; height[j] ?
                max(res, (j - i) * height[i++]):
                max(res, (j - i) * height[j--]);
        &#125;
        return res;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="12-整数转罗马数字"><a href="#12-整数转罗马数字" class="headerlink" title="12. 整数转罗马数字"></a>12. 整数转罗马数字</h3><p>问题地址：<a href="https://leetcode.cn/problems/integer-to-roman/">https://leetcode.cn/problems/integer-to-roman/</a></p>
<p>罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。</p>
<pre class="line-numbers language-none"><code class="language-none">字符          数值
I             1
V             5
X             10
L             50
C             100
D             500
M             1000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</p>
<p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p>
<ul>
<li>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。</li>
<li>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 </li>
<li>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。</li>
</ul>
<p>给你一个整数，将其转为罗马数字。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">const pair&lt;int, string&gt; valueSymbols[] &#x3D; &#123;
    &#123;1000, &quot;M&quot;&#125;,
    &#123;900,  &quot;CM&quot;&#125;,
    &#123;500,  &quot;D&quot;&#125;,
    &#123;400,  &quot;CD&quot;&#125;,
    &#123;100,  &quot;C&quot;&#125;,
    &#123;90,   &quot;XC&quot;&#125;,
    &#123;50,   &quot;L&quot;&#125;,
    &#123;40,   &quot;XL&quot;&#125;,
    &#123;10,   &quot;X&quot;&#125;,
    &#123;9,    &quot;IX&quot;&#125;,
    &#123;5,    &quot;V&quot;&#125;,
    &#123;4,    &quot;IV&quot;&#125;,
    &#123;1,    &quot;I&quot;&#125;,
&#125;;

class Solution &#123;
public:
    string intToRoman(int num) &#123;
        string roman;
        for (const auto &amp;[value, symbol] : valueSymbols) &#123;
            while (num &gt;&#x3D; value) &#123;
                num -&#x3D; value;
                roman +&#x3D; symbol;
            &#125;
            if (num &#x3D;&#x3D; 0) &#123;
                break;
            &#125;
        &#125;
        return roman;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a>15. 三数之和</h3><p>问题地址：<a href="https://leetcode.cn/problems/3sum/">https://leetcode.cn/problems/3sum/</a></p>
<p>给你一个整数数组 nums ，判断是否存在三元组 <code>[nums[i], nums[j], nums[k]]</code> 满足 <code>i != j</code>、<code>i != k</code> 且 <code>j != k</code> ，同时还满足 <code>nums[i] + nums[j] + nums[k] == 0</code> 。请</p>
<p>你返回所有和为 0 且不重复的三元组。</p>
<p>注意：答案中不可以包含重复的三元组。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123;
        int size &#x3D; nums.size();
        if (size &lt; 3) return &#123;&#125;;
        vector&lt;vector&lt;int&gt;&gt; res;
        sort(nums.begin(), nums.end());
        for (int i &#x3D; 0; i &lt; size; i++)
        &#123;
            if (nums[i] &gt; 0) return res;
            if (i &gt; 0 &amp;&amp; nums[i] &#x3D;&#x3D; nums[i - 1]) continue;
            int left &#x3D; i + 1;
            int right &#x3D; size - 1;
            while (left &lt; right) &#123;
                if (nums[left] + nums[right] + nums[i] &gt; 0) &#123;
                    right--;
                &#125; else if (nums[left] + nums[right] + nums[i] &lt; 0) &#123;
                    left++;
                &#125; else &#123;
                    res.push_back(vector&lt;int&gt;&#123;nums[i], nums[left], nums[right]&#125;);
                    left++;
                    right--;
                    while (left &lt; right &amp;&amp; nums[left] &#x3D;&#x3D; nums[left - 1]) left++;
                    while (left &lt; right &amp;&amp; nums[right] &#x3D;&#x3D; nums[right + 1]) right--;
                &#125;
            &#125;
        &#125;
        return res;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="16-最接近的三数之和"><a href="#16-最接近的三数之和" class="headerlink" title="16. 最接近的三数之和"></a>16. 最接近的三数之和</h3><p>问题地址：<a href="https://leetcode.cn/problems/3sum-closest/">https://leetcode.cn/problems/3sum-closest/</a></p>
<p>给你一个长度为 n 的整数数组 nums 和 一个目标值 target。请你从 nums 中选出三个整数，使它们的和与 target 最接近。</p>
<p>返回这三个数的和。</p>
<p>假定每组输入只存在恰好一个解。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) &#123;
        sort(nums.begin(), nums.end());
        int n &#x3D; nums.size();
        int best &#x3D; 1e7;

        auto update &#x3D; [&amp;](int cur) &#123;
            if (abs(cur - target) &lt; abs(best - target)) &#123;
                best &#x3D; cur;
            &#125;
        &#125;;

        for (int i &#x3D; 0; i &lt; n; ++i) &#123;
            if (i &gt; 0 &amp;&amp; nums[i] &#x3D;&#x3D; nums[i - 1]) &#123;
                continue;
            &#125;
            int j &#x3D; i + 1, k &#x3D; n - 1;
            while (j &lt; k) &#123;
                int sum &#x3D; nums[i] + nums[j] + nums[k];
                if (sum &#x3D;&#x3D; target) &#123;
                    return target;
                &#125;
                update(sum);
                if (sum &gt; target) &#123;
                    int k0 &#x3D; k - 1;
                    while (j &lt; k0 &amp;&amp; nums[k0] &#x3D;&#x3D; nums[k]) &#123;
                        --k0;
                    &#125;
                    k &#x3D; k0;
                &#125; else &#123;
                    int j0 &#x3D; j + 1;
                    while (j0 &lt; k &amp;&amp; nums[j0] &#x3D;&#x3D; nums[j]) &#123;
                        ++j0;
                    &#125;
                    j &#x3D; j0;
                &#125;
            &#125;
        &#125;

        return best;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17. 电话号码的字母组合"></a>17. 电话号码的字母组合</h3><p>问题地址：<a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">https://leetcode.cn/problems/letter-combinations-of-a-phone-number/</a></p>
<p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。</p>
<p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    vector&lt;string&gt; letterCombinations(string digits) &#123;
        vector&lt;string&gt; combinations;
        if (digits.empty()) &#123;
            return combinations;
        &#125;
        unordered_map&lt;char, string&gt; phoneMap&#123;
            &#123;&#39;2&#39;, &quot;abc&quot;&#125;,
            &#123;&#39;3&#39;, &quot;def&quot;&#125;,
            &#123;&#39;4&#39;, &quot;ghi&quot;&#125;,
            &#123;&#39;5&#39;, &quot;jkl&quot;&#125;,
            &#123;&#39;6&#39;, &quot;mno&quot;&#125;,
            &#123;&#39;7&#39;, &quot;pqrs&quot;&#125;,
            &#123;&#39;8&#39;, &quot;tuv&quot;&#125;,
            &#123;&#39;9&#39;, &quot;wxyz&quot;&#125;
        &#125;;
        string combination;
        backtrack(combinations, phoneMap, digits, 0, combination);
        return combinations;
    &#125;

    void backtrack(vector&lt;string&gt;&amp; combinations,
            const unordered_map&lt;char, string&gt;&amp; phoneMap,
            const string&amp; digits,
            int index,
            string&amp; combination) &#123;
        if (index &#x3D;&#x3D; digits.length()) &#123;
            combinations.push_back(combination);
        &#125; else &#123;
            char digit &#x3D; digits[index];
            const string&amp; letters &#x3D; phoneMap.at(digit);
            for (const char&amp; letter : letters) &#123;
                combination.push_back(letter);
                backtrack(combinations, phoneMap, digits, index + 1, combination);
                combination.pop_back();
            &#125;
        &#125;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="18-四数之和"><a href="#18-四数之和" class="headerlink" title="18. 四数之和"></a>18. 四数之和</h3><p>问题地址：<a href="https://leetcode.cn/problems/4sum/">https://leetcode.cn/problems/4sum/</a></p>
<p>给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复）：</p>
<p>0 &lt;&#x3D; a, b, c, d &lt; n<br>a、b、c 和 d 互不相同<br>nums[a] + nums[b] + nums[c] + nums[d] &#x3D;&#x3D; target<br>你可以按 任意顺序 返回答案 。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) &#123;
        vector&lt;vector&lt;int&gt;&gt; quadruplets;
        if (nums.size() &lt; 4) &#123;
            return quadruplets;
        &#125;
        sort(nums.begin(), nums.end());
        int length &#x3D; nums.size();
        for (int i &#x3D; 0; i &lt; length - 3; i++) &#123;
            if (i &gt; 0 &amp;&amp; nums[i] &#x3D;&#x3D; nums[i - 1]) &#123;
                continue;
            &#125;
            if ((long) nums[i] + nums[i + 1] + nums[i + 2] + nums[i + 3] &gt; target) &#123;
                break;
            &#125;
            if ((long) nums[i] + nums[length - 3] + nums[length - 2] + nums[length - 1] &lt; target) &#123;
                continue;
            &#125;
            for (int j &#x3D; i + 1; j &lt; length - 2; j++) &#123;
                if (j &gt; i + 1 &amp;&amp; nums[j] &#x3D;&#x3D; nums[j - 1]) &#123;
                    continue;
                &#125;
                if ((long) nums[i] + nums[j] + nums[j + 1] + nums[j + 2] &gt;target) &#123;
                    break;
                &#125;
                if ((long) nums[i] + nums[j] + nums[length - 2] + nums[length - 1] &lt; target) &#123;
                    continue;
                &#125;
                int left &#x3D; j + 1, right &#x3D; length - 1;
                while (left &lt; right) &#123;
                    long sum &#x3D; (long) nums[i] + nums[j] + nums[left] + nums[right];
                    if (sum &#x3D;&#x3D; target) &#123;
                        quadruplets.push_back(&#123;nums[i], nums[j], nums[left], nums[right]&#125;);
                        while (left &lt; right &amp;&amp; nums[left] &#x3D;&#x3D; nums[left + 1]) &#123;
                            left++;
                        &#125;
                        left++;
                        while (left &lt; right &amp;&amp; nums[right] &#x3D;&#x3D; nums[right - 1]) &#123;
                            right--;
                        &#125;
                        right--;
                    &#125; else if (sum &lt; target) &#123;
                        left++;
                    &#125; else &#123;
                        right--;
                    &#125;
                &#125;
            &#125;
        &#125;
        return quadruplets;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="19-删除链表的倒数第-N-个结点"><a href="#19-删除链表的倒数第-N-个结点" class="headerlink" title="19. 删除链表的倒数第 N 个结点"></a>19. 删除链表的倒数第 N 个结点</h3><p>问题地址：<a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">https://leetcode.cn/problems/remove-nth-node-from-end-of-list/</a></p>
<p>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;**
 * Definition for singly-linked list.
 * struct ListNode &#123;
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) &#123;&#125;
 *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;
 *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;
 * &#125;;
 *&#x2F;
class Solution &#123;
public:
    int getLength(ListNode * head) &#123;
        int length &#x3D; 0;
        while (head) &#123;
            ++length;
            head &#x3D; head-&gt;next;
        &#125;
        return length;
    &#125;
    ListNode* removeNthFromEnd(ListNode* head, int n) &#123;
        ListNode * dummy &#x3D; new ListNode(0, head);
        int length &#x3D; getLength(head);
        ListNode * cur &#x3D; dummy;
        for (int i &#x3D; 1; i &lt; length - n + 1; ++i) &#123;
            cur &#x3D; cur-&gt;next;
        &#125;
        cur-&gt;next &#x3D; cur-&gt;next-&gt;next;
        ListNode * ans &#x3D; dummy-&gt;next;
        delete dummy;
        return ans;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22. 括号生成"></a>22. 括号生成</h3><p>问题地址：<a href="https://leetcode.cn/problems/generate-parentheses/">https://leetcode.cn/problems/generate-parentheses/</a></p>
<p>数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    vector&lt;string&gt; generateParenthesis(int n) &#123;
        vector&lt;string&gt; result;
        string current;
        backtrack(result, current, 0, 0, n);
        return result;
    &#125;
    void backtrack(vector&lt;string&gt;&amp; ans, string&amp; cur, int open, int close, int n) &#123;
        if (cur.size() &#x3D;&#x3D; n * 2) &#123;
            ans.push_back(cur);
            return;
        &#125;
        if (open &lt; n) &#123;
            cur.push_back(&#39;(&#39;);
            backtrack(ans, cur, open + 1, close, n);
            cur.pop_back();
        &#125;
        if (close &lt; open) &#123;
            cur.push_back(&#39;)&#39;);
            backtrack(ans, cur, open, close + 1, n);
            cur.pop_back();
        &#125;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24. 两两交换链表中的节点"></a>24. 两两交换链表中的节点</h3><p>问题地址：<a href="https://leetcode.cn/problems/swap-nodes-in-pairs/">https://leetcode.cn/problems/swap-nodes-in-pairs/</a></p>
<p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    ListNode* swapPairs(ListNode* head) &#123;
        ListNode* dummyHead &#x3D; new ListNode(0);
        dummyHead-&gt;next &#x3D; head;
        ListNode* temp &#x3D; dummyHead;
        while (temp-&gt;next !&#x3D; nullptr &amp;&amp; temp-&gt;next-&gt;next !&#x3D; nullptr) &#123;
            ListNode* node1 &#x3D; temp-&gt;next;
            ListNode* node2 &#x3D; temp-&gt;next-&gt;next;
            temp-&gt;next &#x3D; node2;
            node1-&gt;next &#x3D; node2-&gt;next;
            node2-&gt;next &#x3D; node1;
            temp &#x3D; node1;
        &#125;
        return dummyHead-&gt;next;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="204-计数质数"><a href="#204-计数质数" class="headerlink" title="204. 计数质数"></a>204. 计数质数</h3><p>问题地址：<a href="https://leetcode.cn/problems/count-primes/">https://leetcode.cn/problems/count-primes/</a></p>
<p>给定整数 n ，返回 所有小于非负整数 n 的质数的数量 。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int countPrimes(int n) &#123;
        vector&lt;int&gt; isPrime(n, 1);
        int ans &#x3D; 0;
        for (int i &#x3D; 2; i &lt; n; ++i) &#123;
            if (isPrime[i]) &#123;
                ans +&#x3D; 1;
                if ((long long)i * i &lt; n) &#123;
                    for (int j &#x3D; i * i; j &lt; n; j +&#x3D; i) &#123;
                        isPrime[j] &#x3D; 0;
                    &#125;
                &#125;
            &#125;
        &#125;
        return ans;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="2761-和等于目标值的质数对"><a href="#2761-和等于目标值的质数对" class="headerlink" title="2761. 和等于目标值的质数对"></a>2761. 和等于目标值的质数对</h3><p>问题地址：<a href="https://leetcode.cn/problems/prime-pairs-with-target-sum/">https://leetcode.cn/problems/prime-pairs-with-target-sum/</a></p>
<p>给你一个整数 n 。如果两个整数 x 和 y 满足下述条件，则认为二者形成一个质数对：</p>
<ul>
<li>1 &lt;&#x3D; x &lt;&#x3D; y &lt;&#x3D; n</li>
<li>x + y &#x3D;&#x3D; n</li>
<li>x 和 y 都是质数</li>
</ul>
<p>请你以二维有序列表的形式返回符合题目要求的所有 <code>[xi, yi]</code> ，列表需要按 xi 的 非递减顺序 排序。如果不存在符合要求的质数对，则返回一个空数组。</p>
<p>注意：质数是大于 1 的自然数，并且只有两个因子，即它本身和 1 。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    vector&lt;vector&lt;int&gt;&gt; findPrimePairs(int n) &#123;
        vector&lt;bool&gt; isPrime(n, true);
        for (int i &#x3D; 2; i &lt; n; i++) &#123;
            if (isPrime[i]) &#123;
                for (int j &#x3D; i; j &lt; n; j +&#x3D; i) &#123;
                    if (j !&#x3D; i) isPrime[j] &#x3D; false;
                &#125;
            &#125;
        &#125;
        vector&lt;vector&lt;int&gt;&gt; ret;
        for (int i &#x3D; 2; i &lt;&#x3D; n -i; i++) &#123;
            if (isPrime[i] &amp;&amp; isPrime[n - i]) &#123;
                ret.push_back(&#123;i, n - i&#125;);
            &#125;
        &#125;
        return ret;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="2762-不间断子数组"><a href="#2762-不间断子数组" class="headerlink" title="2762. 不间断子数组"></a>2762. 不间断子数组</h3><p>问题地址：<a href="https://leetcode.cn/problems/continuous-subarrays/">https://leetcode.cn/problems/continuous-subarrays/</a></p>
<p>给你一个下标从 0 开始的整数数组 nums 。nums 的一个子数组如果满足以下条件，那么它是 不间断 的：</p>
<ul>
<li>i，i + 1 ，…，j  表示子数组中的下标。对于所有满足 i &lt;&#x3D; $i_1$, $i_2$ &lt;&#x3D; j 的下标对，都有 0 &lt;&#x3D; |nums[$i_1$] - nums[$i_2$]| &lt;&#x3D; 2 。</li>
</ul>
<p>请你返回 不间断 子数组的总数目。</p>
<p>子数组是一个数组中一段连续 非空 的元素序列。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    long long continuousSubarrays(vector&lt;int&gt;&amp; nums) &#123;
        long long ans &#x3D; 0;
        multiset&lt;int&gt; s;
        int left &#x3D; 0, n &#x3D; nums.size();
        for (int right &#x3D; 0; right &lt; n; right++) &#123;
            s.insert(nums[right]);
            while (*s.rbegin() - *s.begin() &gt; 2) &#123;
                s.erase(s.find(nums[left++]));
            &#125;
            ans +&#x3D; right - left + 1;
        &#125;
        return ans;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2. 两数相加"></a>2. 两数相加</h3><p>问题地址：<a href="https://leetcode.cn/problems/add-two-numbers/">https://leetcode.cn/problems/add-two-numbers/</a></p>
<p>给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。</p>
<p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p>
<p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;**
 * Definition for singly-linked list.
 * struct ListNode &#123;
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) &#123;&#125;
 *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;
 *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;
 * &#125;;
 *&#x2F;
class Solution &#123;
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123;
        ListNode * head &#x3D; nullptr, * tail &#x3D; nullptr;
        int carry &#x3D; 0;
        while (l1 || l2) &#123;
            int n1 &#x3D; l1 ? l1-&gt;val : 0;
            int n2 &#x3D; l2 ? l2-&gt;val : 0;
            int sum &#x3D; n1 + n2 + carry;
            if (!head) &#123;
                head &#x3D; tail &#x3D; new ListNode(sum % 10);
            &#125; else &#123;
                tail-&gt;next &#x3D; new ListNode(sum % 10);
                tail &#x3D; tail-&gt;next;
            &#125;
            carry &#x3D; sum &#x2F; 10;
            if (l1) &#123;
                l1 &#x3D; l1-&gt;next;
            &#125;
            if (l2) &#123;
                l2 &#x3D; l2-&gt;next;
            &#125;
        &#125;
        if (carry &gt; 0) &#123;
            tail-&gt;next &#x3D; new ListNode(carry);
        &#125;
        return head;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="445-两数相加-II"><a href="#445-两数相加-II" class="headerlink" title="445. 两数相加 II"></a>445. 两数相加 II</h3><p>问题地址：<a href="https://leetcode.cn/problems/add-two-numbers-ii/">https://leetcode.cn/problems/add-two-numbers-ii/</a></p>
<p>给你两个 非空 链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。</p>
<p>你可以假设除了数字 0 之外，这两个数字都不会以零开头。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;**
 * Definition for singly-linked list.
 * struct ListNode &#123;
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) &#123;&#125;
 *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;
 *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;
 * &#125;;
 *&#x2F;
class Solution &#123;
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123;
        stack&lt;int&gt; s1, s2;
        while (l1) &#123;
            s1.push(l1-&gt;val);
            l1 &#x3D; l1-&gt;next;
        &#125;
        while (l2) &#123;
            s2.push(l2-&gt;val);
            l2 &#x3D; l2-&gt;next;
        &#125;
        int carry &#x3D; 0;
        ListNode * ans &#x3D; nullptr;
        while (!s1.empty() or !s2.empty() or carry !&#x3D; 0) &#123;
            int a &#x3D; s1.empty() ? 0 : s1.top();
            int b &#x3D; s2.empty() ? 0 : s2.top();
            if (!s1.empty()) s1.pop();
            if (!s2.empty()) s2.pop();
            int cur &#x3D; a + b + carry;
            carry &#x3D; cur &#x2F; 10;
            cur %&#x3D; 10;
            auto curnode &#x3D; new ListNode(cur);
            curnode-&gt;next &#x3D; ans;
            ans &#x3D; curnode;
        &#125;
        return ans;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="2679-矩阵中的和"><a href="#2679-矩阵中的和" class="headerlink" title="2679. 矩阵中的和"></a>2679. 矩阵中的和</h3><p>问题地址：<a href="https://leetcode.cn/problems/sum-in-a-matrix/">https://leetcode.cn/problems/sum-in-a-matrix/</a></p>
<p>给你一个下标从 0 开始的二维整数数组 nums 。一开始你的分数为 0 。你需要执行以下操作直到矩阵变为空：</p>
<ul>
<li>矩阵中每一行选取最大的一个数，并删除它。如果一行中有多个最大的数，选择任意一个并删除。</li>
<li>在步骤 1 删除的所有数字中找到最大的一个数字，将它添加到你的 分数 中。</li>
</ul>
<p>请你返回最后的 分数 。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int matrixSum(vector&lt;vector&lt;int&gt;&gt;&amp; nums) &#123;
        int res &#x3D; 0;
        int m &#x3D; nums.size();
        int n &#x3D; nums[0].size();
        for (int i &#x3D; 0; i &lt; m; i++) &#123;
            sort(nums[i].begin(), nums[i].end());
        &#125;
        for (int j &#x3D; 0; j &lt; n; j++) &#123;
            int maxVal &#x3D; 0;
            for (int i &#x3D; 0; i &lt; m; i++) &#123;
                maxVal &#x3D; max(maxVal, nums[i][j]);
            &#125;
            res +&#x3D; maxVal;
        &#125;
        return res;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="29-两数相除"><a href="#29-两数相除" class="headerlink" title="29. 两数相除"></a>29. 两数相除</h3><p>问题地址：<a href="https://leetcode.cn/problems/divide-two-integers/">https://leetcode.cn/problems/divide-two-integers/</a></p>
<p>给你两个整数，被除数 dividend 和除数 divisor。将两数相除，要求 不使用 乘法、除法和取余运算。</p>
<p>整数除法应该向零截断，也就是截去（truncate）其小数部分。例如，8.345 将被截断为 8 ，-2.7335 将被截断至 -2 。</p>
<p>返回被除数 dividend 除以除数 divisor 得到的 商 。</p>
<p>注意：假设我们的环境只能存储 32 位 有符号整数，其数值范围是 [−231,  231 − 1] 。本题中，如果商 严格大于 231 − 1 ，则返回 231 − 1 ；如果商 严格小于 -231 ，则返回 -231 。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int divide(int dividend, int divisor) &#123;
        if (dividend &#x3D;&#x3D; 0) return 0;
        if (divisor &#x3D;&#x3D; 1) return dividend;
        if (divisor &#x3D;&#x3D; -1) &#123;
            if (dividend &gt; INT_MIN) return -dividend;
            return INT_MAX;
        &#125;
        long a &#x3D; dividend;
        long b &#x3D; divisor;
        int sign &#x3D; 1;
        if ((a &gt; 0 &amp;&amp; b &lt; 0) || (a &lt; 0 &amp;&amp; b &gt; 0)) &#123;
            sign &#x3D; -1;
        &#125;
        a &#x3D; a &gt; 0 ? a : -a;
        b &#x3D; b &gt; 0 ? b : -b;
        long res &#x3D; div(a, b);
        if (sign &gt; 0) return res &gt; INT_MAX ? INT_MAX : res;
        return -res;
    &#125;
    int div(long a, long b) &#123;
        if (a &lt; b) return 0;
        long count &#x3D; 1;
        long tb &#x3D; b;
        while ((tb + tb) &lt;&#x3D; a) &#123;
            count &#x3D; count + count;
            tb &#x3D; tb + tb;
        &#125;
        return count + div(a - tb, b);
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="2178-拆分成最多数目的正偶数之和"><a href="#2178-拆分成最多数目的正偶数之和" class="headerlink" title="2178. 拆分成最多数目的正偶数之和"></a>2178. 拆分成最多数目的正偶数之和</h3><p>问题地址：<a href="https://leetcode.cn/problems/maximum-split-of-positive-even-integers/">https://leetcode.cn/problems/maximum-split-of-positive-even-integers/</a></p>
<p>给你一个整数 finalSum 。请你将它拆分成若干个 互不相同 的正偶数之和，且拆分出来的正偶数数目 最多 。</p>
<ul>
<li>比方说，给你 finalSum &#x3D; 12 ，那么这些拆分是 符合要求 的（互不相同的正偶数且和为 finalSum）：(2 + 10) ，(2 + 4 + 6) 和 (4 + 8) 。它们中，(2 + 4 + 6) 包含最多数目的整数。注意 finalSum 不能拆分成 (2 + 2 + 4 + 4) ，因为拆分出来的整数必须互不相同。</li>
</ul>
<p>请你返回一个整数数组，表示将整数拆分成 最多 数目的正偶数数组。如果没有办法将 finalSum 进行拆分，请你返回一个 空 数组。你可以按 任意 顺序返回这些整数。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    vector&lt;long long&gt; maximumEvenSplit(long long finalSum) &#123;
        vector&lt;long long&gt; res;
        if (finalSum % 2 &gt; 0) &#123;
            return res;
        &#125;
        for (int i &#x3D; 2; i &lt;&#x3D; finalSum; i +&#x3D; 2) &#123;
            res.push_back(i);
            finalSum -&#x3D; i;
        &#125;
        res.back() +&#x3D; finalSum;
        return res;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="31-下一个排列"><a href="#31-下一个排列" class="headerlink" title="31. 下一个排列"></a>31. 下一个排列</h3><p>问题地址：<a href="https://leetcode.cn/problems/next-permutation/">https://leetcode.cn/problems/next-permutation/</a></p>
<p>整数数组的一个 排列  就是将其所有成员以序列或线性顺序排列。</p>
<ul>
<li>例如，arr &#x3D; [1,2,3] ，以下这些都可以视作 arr 的排列：[1,2,3]、[1,3,2]、[3,1,2]、[2,3,1] 。</li>
</ul>
<p>整数数组的 下一个排列 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 下一个排列 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。</p>
<ul>
<li>例如，arr &#x3D; [1,2,3] 的下一个排列是 [1,3,2] 。</li>
<li>类似地，arr &#x3D; [2,3,1] 的下一个排列是 [3,1,2] 。</li>
<li>而 arr &#x3D; [3,2,1] 的下一个排列是 [1,2,3] ，因为 [3,2,1] 不存在一个字典序更大的排列。</li>
</ul>
<p>给你一个整数数组 nums ，找出 nums 的下一个排列。</p>
<p>必须 原地 修改，只允许使用额外常数空间。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    void nextPermutation(vector&lt;int&gt;&amp; nums) &#123;
        int i &#x3D; nums.size() - 2;
        while (i &gt;&#x3D; 0 &amp;&amp; nums[i] &gt;&#x3D; nums[i + 1]) &#123;
            i--;
        &#125;
        if (i &gt;&#x3D; 0) &#123;
            int j &#x3D; nums.size() - 1;
            while (j &gt;&#x3D; 0 &amp;&amp; nums[i] &gt;&#x3D; nums[j]) &#123;
                j--;
            &#125;
            swap(nums[i], nums[j]);
        &#125;
        reverse(nums.begin() + i + 1, nums.end());
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="33-搜索旋转排序数组"><a href="#33-搜索旋转排序数组" class="headerlink" title="33. 搜索旋转排序数组"></a>33. 搜索旋转排序数组</h3><p>问题地址：<a href="https://leetcode.cn/problems/search-in-rotated-sorted-array/">https://leetcode.cn/problems/search-in-rotated-sorted-array/</a></p>
<p>整数数组 nums 按升序排列，数组中的值 互不相同 。</p>
<p>在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;&#x3D; k &lt; nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], …, nums[n-1], nums[0], nums[1], …, nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。</p>
<p>给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。</p>
<p>你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int search(vector&lt;int&gt;&amp; nums, int target) &#123;
        int n &#x3D; nums.size();
        if (!n) &#123;
            return -1;
        &#125;
        if (n &#x3D;&#x3D; 1) &#123;
            return nums[0] &#x3D;&#x3D; target ? 0 : -1;
        &#125;
        int l &#x3D; 0, r &#x3D; n - 1;
        while (l &lt;&#x3D; r) &#123;
            int mid &#x3D; (l + r) &#x2F; 2;
            if (nums[mid] &#x3D;&#x3D; target) return mid;
            if (nums[0] &lt;&#x3D; nums[mid]) &#123;
                if (nums[0] &lt;&#x3D; target &amp;&amp; target &lt; nums[mid]) &#123;
                    r &#x3D; mid - 1;
                &#125; else &#123;
                    l &#x3D; mid + 1;
                &#125;
            &#125; else &#123;
                if (nums[mid] &lt; target &amp;&amp; target &lt;&#x3D; nums[n - 1]) &#123;
                    l &#x3D; mid + 1;
                &#125; else &#123;
                    r &#x3D; mid - 1;
                &#125;
            &#125;
        &#125;
        return -1;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="979-在二叉树中分配硬币"><a href="#979-在二叉树中分配硬币" class="headerlink" title="979. 在二叉树中分配硬币"></a>979. 在二叉树中分配硬币</h3><p>问题地址：<a href="https://leetcode.cn/problems/distribute-coins-in-binary-tree/">https://leetcode.cn/problems/distribute-coins-in-binary-tree/</a></p>
<p>给你一个有 n 个结点的二叉树的根结点 root ，其中树中每个结点 node 都对应有 node.val 枚硬币。整棵树上一共有 n 枚硬币。</p>
<p>在一次移动中，我们可以选择两个相邻的结点，然后将一枚硬币从其中一个结点移动到另一个结点。移动可以是从父结点到子结点，或者从子结点移动到父结点。</p>
<p>返回使每个结点上 只有 一枚硬币所需的 最少 移动次数。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;**
 * Definition for a binary tree node.
 * struct TreeNode &#123;
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;
 * &#125;;
 *&#x2F;
class Solution &#123;
public:
    int distributeCoins(TreeNode* root) &#123;
        int move &#x3D; 0;

        function&lt;int(const TreeNode *)&gt; dfs &#x3D; [&amp;](const TreeNode * root) -&gt; int &#123;
            int moveleft &#x3D; 0;
            int moveright &#x3D; 0;
            if (root &#x3D;&#x3D; nullptr) &#123;
                return 0;
            &#125;
            if (root-&gt;left) &#123;
                moveleft &#x3D; dfs(root-&gt;left);
            &#125;
            if (root-&gt;right) &#123;
                moveright &#x3D; dfs(root-&gt;right);
            &#125;
            move +&#x3D; abs(moveleft) + abs(moveright);
            return moveleft + moveright + root-&gt;val - 1;
        &#125;;

        dfs(root);
        return move;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="36-有效的数独"><a href="#36-有效的数独" class="headerlink" title="36. 有效的数独"></a>36. 有效的数独</h3><p>问题地址：<a href="https://leetcode.cn/problems/valid-sudoku/">https://leetcode.cn/problems/valid-sudoku/</a></p>
<p>请你判断一个 9 x 9 的数独是否有效。只需要 根据以下规则 ，验证已经填入的数字是否有效即可。</p>
<ol>
<li>数字 1-9 在每一行只能出现一次。</li>
<li>数字 1-9 在每一列只能出现一次。</li>
<li>数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）</li>
</ol>
<p> </p>
<p>注意：</p>
<ul>
<li>一个有效的数独（部分已被填充）不一定是可解的。</li>
<li>只需要根据以上规则，验证已经填入的数字是否有效即可。</li>
<li>空白格用 ‘.’ 表示。</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    bool isValidSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123;
        int rows[9][9];
        int columns[9][9];
        int subboxes[3][3][9];
        
        memset(rows,0,sizeof(rows));
        memset(columns,0,sizeof(columns));
        memset(subboxes,0,sizeof(subboxes));
        for (int i &#x3D; 0; i &lt; 9; i++) &#123;
            for (int j &#x3D; 0; j &lt; 9; j++) &#123;
                char c &#x3D; board[i][j];
                if (c !&#x3D; &#39;.&#39;) &#123;
                    int index &#x3D; c - &#39;0&#39; - 1;
                    rows[i][index]++;
                    columns[j][index]++;
                    subboxes[i &#x2F; 3][j &#x2F; 3][index]++;
                    if (rows[i][index] &gt; 1 || columns[j][index] &gt; 1 || subboxes[i &#x2F; 3][j &#x2F; 3][index] &gt; 1) &#123;
                        return false;
                    &#125;
                &#125;
            &#125;
        &#125;
        return true;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34. 在排序数组中查找元素的第一个和最后一个位置"></a>34. 在排序数组中查找元素的第一个和最后一个位置</h3><p>问题地址：<a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/</a></p>
<p>给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。</p>
<p>如果数组中不存在目标值 target，返回 [-1, -1]。</p>
<p>你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123; 
public:
    int binarySearch(vector&lt;int&gt;&amp; nums, int target, bool lower) &#123;
        int left &#x3D; 0, right &#x3D; (int)nums.size() - 1, ans &#x3D; (int)nums.size();
        while (left &lt;&#x3D; right) &#123;
            int mid &#x3D; (left + right) &#x2F; 2;
            if (nums[mid] &gt; target || (lower &amp;&amp; nums[mid] &gt;&#x3D; target)) &#123;
                right &#x3D; mid - 1;
                ans &#x3D; mid;
            &#125; else &#123;
                left &#x3D; mid + 1;
            &#125;
        &#125;
        return ans;
    &#125;

    vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123;
        int leftIdx &#x3D; binarySearch(nums, target, true);
        int rightIdx &#x3D; binarySearch(nums, target, false) - 1;
        if (leftIdx &lt;&#x3D; rightIdx &amp;&amp; rightIdx &lt; nums.size() &amp;&amp; nums[leftIdx] &#x3D;&#x3D; target &amp;&amp; nums[rightIdx] &#x3D;&#x3D; target) &#123;
            return vector&lt;int&gt;&#123;leftIdx, rightIdx&#125;;
        &#125; 
        return vector&lt;int&gt;&#123;-1, -1&#125;;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="38-外观数列"><a href="#38-外观数列" class="headerlink" title="38. 外观数列"></a>38. 外观数列</h3><p>问题地址：<a href="https://leetcode.cn/problems/count-and-say/">https://leetcode.cn/problems/count-and-say/</a></p>
<p>给定一个正整数 n ，输出外观数列的第 n 项。</p>
<p>「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。</p>
<p>你可以将其视作是由递归公式定义的数字字符串序列：</p>
<ul>
<li>countAndSay(1) &#x3D; “1”</li>
<li>countAndSay(n) 是对 countAndSay(n-1) 的描述，然后转换成另一个数字字符串。</li>
</ul>
<p>前五项如下：</p>
<pre class="line-numbers language-none"><code class="language-none">1.     1
2.     11
3.     21
4.     1211
5.     111221
第一项是数字 1 
描述前一项，这个数是 1 即 “ 一 个 1 ”，记作 &quot;11&quot;
描述前一项，这个数是 11 即 “ 二 个 1 ” ，记作 &quot;21&quot;
描述前一项，这个数是 21 即 “ 一 个 2 + 一 个 1 ” ，记作 &quot;1211&quot;
描述前一项，这个数是 1211 即 “ 一 个 1 + 一 个 2 + 二 个 1 ” ，记作 &quot;111221&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>要 描述 一个数字字符串，首先要将字符串分割为 最小 数量的组，每个组都由连续的最多 相同字符 组成。然后对于每个组，先描述字符的数量，然后描述字符，形成一个描述组。要将描述转换为数字字符串，先将每组中的字符数量用数字替换，再将所有描述组连接起来。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    string countAndSay(int n) &#123;
        string prev &#x3D; &quot;1&quot;;
        for (int i &#x3D; 2; i &lt;&#x3D; n; ++i) &#123;
            string curr &#x3D; &quot;&quot;;
            int start &#x3D; 0;
            int pos &#x3D; 0;
            while (pos &lt; prev.size()) &#123;
                while (pos &lt; prev.size() &amp;&amp; prev[pos] &#x3D;&#x3D; prev[start]) &#123;
                    pos++;
                &#125;
                curr +&#x3D; to_string(pos - start) + prev[start];
                start &#x3D; pos;
            &#125;
            prev &#x3D; curr;
        &#125;
        return prev;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="80-删除有序数组中的重复项-II"><a href="#80-删除有序数组中的重复项-II" class="headerlink" title="80. 删除有序数组中的重复项 II"></a>80. 删除有序数组中的重复项 II</h3><p>问题地址：<a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii/">https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii/</a></p>
<p>给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使得出现次数超过两次的元素只出现两次 ，返回删除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123;
        int n &#x3D; nums.size();
        if (n &lt;&#x3D; 2) &#123;
            return n;
        &#125;
        int slow &#x3D; 2, fast &#x3D; 2;
        while (fast &lt; n) &#123;
            if (nums[slow - 2] !&#x3D; nums[fast]) &#123;
                nums[slow] &#x3D; nums[fast];
                ++slow;
            &#125;
            ++fast;
        &#125;
        return slow;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="189-轮转数组"><a href="#189-轮转数组" class="headerlink" title="189. 轮转数组"></a>189. 轮转数组</h3><p>问题地址：<a href="https://leetcode.cn/problems/rotate-array/">https://leetcode.cn/problems/rotate-array/</a></p>
<p>给定一个整数数组 nums，将数组中的元素向右轮转 k 个位置，其中 k 是非负数。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    void rotate(vector&lt;int&gt;&amp; nums, int k) &#123;
        int n &#x3D; nums.size();
        vector&lt;int&gt; newArr(n);
        for (int i &#x3D; 0; i &lt; n; ++i) &#123;
            newArr[(i + k) % n] &#x3D; nums[i];
        &#125;
        nums.assign(newArr.begin(), newArr.end());
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="122-买卖股票的最佳时机-II"><a href="#122-买卖股票的最佳时机-II" class="headerlink" title="122. 买卖股票的最佳时机 II"></a>122. 买卖股票的最佳时机 II</h3><p>问题地址：<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/</a></p>
<p>给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。</p>
<p>在每一天，你可以决定是否购买和&#x2F;或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。</p>
<p>返回 你能获得的 最大 利润 。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;
        int ans &#x3D; 0;
        int n &#x3D; prices.size();
        for (int i &#x3D; 1; i &lt; n; ++i) &#123;
            ans +&#x3D; max(0, prices[i] - prices[i - 1]);
        &#125;
        return ans;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="55-跳跃游戏"><a href="#55-跳跃游戏" class="headerlink" title="55. 跳跃游戏"></a>55. 跳跃游戏</h3><p>问题地址：<a href="https://leetcode.cn/problems/jump-game/">https://leetcode.cn/problems/jump-game/</a></p>
<p>给你一个非负整数数组 nums ，你最初位于数组的 第一个下标 。数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>
<p>判断你是否能够到达最后一个下标，如果可以，返回 true ；否则，返回 false 。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    bool canJump(vector&lt;int&gt;&amp; nums) &#123;
        int n &#x3D; nums.size();
        int rightmost &#x3D; 0;
        for (int i &#x3D; 0; i &lt; n; ++i) &#123;
            if (i &lt;&#x3D; rightmost) &#123;
                rightmost &#x3D; max(rightmost, i + nums[i]);
                if (rightmost &gt;&#x3D; n - 1) &#123;
                    return true;
                &#125;
            &#125;
        &#125;
        return false;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="45-跳跃游戏-II"><a href="#45-跳跃游戏-II" class="headerlink" title="45. 跳跃游戏 II"></a>45. 跳跃游戏 II</h3><p>问题地址：<a href="https://leetcode.cn/problems/jump-game-ii/">https://leetcode.cn/problems/jump-game-ii/</a></p>
<p>给定一个长度为 n 的 0 索引整数数组 nums。初始位置为 nums[0]。</p>
<p>每个元素 nums[i] 表示从索引 i 向前跳转的最大长度。换句话说，如果你在 nums[i] 处，你可以跳转到任意 nums[i + j] 处:</p>
<ul>
<li>0 &lt;&#x3D; j &lt;&#x3D; nums[i] </li>
<li>i + j &lt; n</li>
</ul>
<p>返回到达 nums[n - 1] 的最小跳跃次数。生成的测试用例可以到达 nums[n - 1]。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int jump(vector&lt;int&gt;&amp; nums) &#123;
        int maxPos &#x3D; 0, n &#x3D; nums.size(), end &#x3D; 0, step &#x3D; 0;
        for (int i &#x3D; 0; i &lt; n - 1; ++i) &#123;
            if (maxPos &gt;&#x3D; i) &#123;
                maxPos &#x3D; max(maxPos, i + nums[i]);
                if (i &#x3D;&#x3D; end) &#123;
                    end &#x3D; maxPos;
                    ++step;
                &#125;
            &#125;
        &#125;
        return step;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="274-H-指数"><a href="#274-H-指数" class="headerlink" title="274. H 指数"></a>274. H 指数</h3><p>问题地址：<a href="https://leetcode.cn/problems/h-index/">https://leetcode.cn/problems/h-index/</a></p>
<p>给你一个整数数组 citations ，其中 citations[i] 表示研究者的第 i 篇论文被引用的次数。计算并返回该研究者的 h 指数。</p>
<p>根据维基百科上 h 指数的定义：h 代表“高引用次数” ，一名科研人员的 h 指数 是指他（她）至少发表了 h 篇论文，并且每篇论文 至少 被引用 h 次。如果 h 有多种可能的值，h 指数 是其中最大的那个。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int hIndex(vector&lt;int&gt;&amp; citations) &#123;
        sort(citations.begin(), citations.end());
        int h &#x3D; 0, i &#x3D; citations.size() - 1;
        while (i &gt;&#x3D; 0 &amp;&amp; citations[i] &gt; h) &#123;
            h++;
            i--;
        &#125;
        return h;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="380-O-1-时间插入、删除和获取随机元素"><a href="#380-O-1-时间插入、删除和获取随机元素" class="headerlink" title="380. O(1) 时间插入、删除和获取随机元素"></a>380. O(1) 时间插入、删除和获取随机元素</h3><p>问题地址：<a href="https://leetcode.cn/problems/insert-delete-getrandom-o1/">https://leetcode.cn/problems/insert-delete-getrandom-o1/</a></p>
<p>实现RandomizedSet 类：</p>
<ul>
<li>RandomizedSet() 初始化 RandomizedSet 对象</li>
<li>bool insert(int val) 当元素 val 不存在时，向集合中插入该项，并返回 true ；否则，返回 false 。</li>
<li>bool remove(int val) 当元素 val 存在时，从集合中移除该项，并返回 true ；否则，返回 false 。</li>
<li>int getRandom() 随机返回现有集合中的一项（测试用例保证调用此方法时集合中至少存在一个元素）。每个元素应该有 相同的概率 被返回。</li>
</ul>
<p>你必须实现类的所有函数，并满足每个函数的 平均 时间复杂度为 O(1) 。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class RandomizedSet &#123;
private:
    vector&lt;int&gt; nums;
    unordered_map&lt;int, int&gt; indices;
public:
    RandomizedSet() &#123;
        srand((unsigned)time(nullptr));
    &#125;
    
    bool insert(int val) &#123;
        if (indices.count(val)) &#123;
            return false;
        &#125;
        int index &#x3D; nums.size();
        nums.emplace_back(val);
        indices[val] &#x3D; index;
        return true;
    &#125;
    
    bool remove(int val) &#123;
        if (!indices.count(val)) &#123;
            return false;
        &#125;
        int index &#x3D; indices[val];
        int last &#x3D; nums.back();
        nums[index] &#x3D; last;
        indices[last] &#x3D; index;
        nums.pop_back();
        indices.erase(val);
        return true;
    &#125;
    
    int getRandom() &#123;
        int randomIndex &#x3D; rand() % nums.size();
        return nums[randomIndex];
    &#125;
&#125;;

&#x2F;**
 * Your RandomizedSet object will be instantiated and called as such:
 * RandomizedSet* obj &#x3D; new RandomizedSet();
 * bool param_1 &#x3D; obj-&gt;insert(val);
 * bool param_2 &#x3D; obj-&gt;remove(val);
 * int param_3 &#x3D; obj-&gt;getRandom();
 *&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="238-除自身以外数组的乘积"><a href="#238-除自身以外数组的乘积" class="headerlink" title="238. 除自身以外数组的乘积"></a>238. 除自身以外数组的乘积</h3><p>问题地址：<a href="https://leetcode.cn/problems/product-of-array-except-self/">https://leetcode.cn/problems/product-of-array-except-self/</a></p>
<p>给你一个整数数组 nums，返回 数组 answer ，其中 answer[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积 。</p>
<p>题目数据 保证 数组 nums之中任意元素的全部前缀元素和后缀的乘积都在  32 位 整数范围内。</p>
<p>请 不要使用除法，且在 O(n) 时间复杂度内完成此题。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    vector&lt;int&gt; productExceptSelf(vector&lt;int&gt;&amp; nums) &#123;
        int length &#x3D; nums.size();
        vector&lt;int&gt; L(length, 0), R(length, 0);
        vector&lt;int&gt; answer(length);
        L[0] &#x3D; 1;
        for (int i &#x3D; 1; i &lt; length; i++) &#123;
            L[i] &#x3D; nums[i - 1] * L[i - 1];
        &#125;
        R[length - 1] &#x3D; 1;
        for (int i &#x3D; length - 2; i &gt;&#x3D; 0; i--) &#123;
            R[i] &#x3D; nums[i + 1] * R[i + 1];
        &#125;
        for (int i &#x3D; 0; i &lt; length; i++) &#123;
            answer[i] &#x3D; L[i] * R[i];
        &#125;
        return answer;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="134-加油站"><a href="#134-加油站" class="headerlink" title="134. 加油站"></a>134. 加油站</h3><p>问题地址：<a href="https://leetcode.cn/problems/gas-station/">https://leetcode.cn/problems/gas-station/</a></p>
<p>在一条环路上有 n 个加油站，其中第 i 个加油站有汽油 gas[i] 升。</p>
<p>你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。</p>
<p>给定两个整数数组 gas 和 cost ，如果你可以按顺序绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1 。如果存在解，则 保证 它是 唯一 的。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int canCompleteCircuit(vector&lt;int&gt;&amp; gas, vector&lt;int&gt;&amp; cost) &#123;
        int n &#x3D; gas.size();
        int i &#x3D; 0;
        while (i &lt; n) &#123;
            int sumOfGas &#x3D; 0, sumOfCost &#x3D; 0;
            int cnt &#x3D; 0;
            while (cnt &lt; n) &#123;
                int j &#x3D; (i + cnt) % n;
                sumOfGas +&#x3D; gas[j];
                sumOfCost +&#x3D; cost[j];
                if (sumOfCost &gt; sumOfGas) &#123;
                    break;
                &#125;
                cnt++;
            &#125;
            if (cnt &#x3D;&#x3D; n) &#123;
                return i;
            &#125; else &#123;
                i &#x3D; i + cnt + 1;
            &#125;
        &#125;
        return -1;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="151-反转字符串中的单词"><a href="#151-反转字符串中的单词" class="headerlink" title="151. 反转字符串中的单词"></a>151. 反转字符串中的单词</h3><p>问题地址：<a href="https://leetcode.cn/problems/reverse-words-in-a-string/">https://leetcode.cn/problems/reverse-words-in-a-string/</a></p>
<p>给你一个字符串 s ，请你反转字符串中 单词 的顺序。</p>
<p>单词 是由非空格字符组成的字符串。s 中使用至少一个空格将字符串中的 单词 分隔开。</p>
<p>返回 单词 顺序颠倒且 单词 之间用单个空格连接的结果字符串。</p>
<p>注意：输入字符串 s中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    string reverseWords(string s) &#123;
        reverse(s.begin(), s.end());
        int n &#x3D; s.size();
        int idx &#x3D; 0;
        for (int start &#x3D; 0; start &lt; n; ++start) &#123;
            if (s[start] !&#x3D; &#39; &#39;) &#123;
                if (idx !&#x3D; 0) s[idx++] &#x3D; &#39; &#39;;
                int end &#x3D; start;
                while (end &lt; n &amp;&amp; s[end] !&#x3D; &#39; &#39;) s[idx++] &#x3D; s[end++];
                reverse(s.begin() + idx - (end - start), s.begin() + idx);
                start &#x3D; end;
            &#125;
        &#125;
        s.erase(s.begin() + idx, s.end());
        return s;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="53-最大子数组和"><a href="#53-最大子数组和" class="headerlink" title="53. 最大子数组和"></a>53. 最大子数组和</h3><p>问题地址：<a href="https://leetcode.cn/problems/maximum-subarray/">https://leetcode.cn/problems/maximum-subarray/</a></p>
<p>给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p>子数组 是数组中的一个连续部分。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;
        int pre &#x3D; 0, maxAns &#x3D; nums[0];
        for (const auto &amp;x : nums) &#123;
            pre &#x3D; max(pre + x, x);
            maxAns &#x3D; max(maxAns, pre);
        &#125;
        return maxAns;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="167-两数之和-II-输入有序数组"><a href="#167-两数之和-II-输入有序数组" class="headerlink" title="167. 两数之和 II - 输入有序数组"></a>167. 两数之和 II - 输入有序数组</h3><p>问题地址：<a href="https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/">https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/</a></p>
<p>给你一个下标从 1 开始的整数数组 numbers ，该数组已按 非递减顺序排列  ，请你从数组中找出满足相加之和等于目标数 target 的两个数。如果设这两个数分别是 numbers[index1] 和 numbers[index2] ，则 1 &lt;&#x3D; index1 &lt; index2 &lt;&#x3D; numbers.length 。</p>
<p>以长度为 2 的整数数组 [index1, index2] 的形式返回这两个整数的下标 index1 和 index2。</p>
<p>你可以假设每个输入 只对应唯一的答案 ，而且你 不可以 重复使用相同的元素。</p>
<p>你所设计的解决方案必须只使用常量级的额外空间。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) &#123;
        for (int i &#x3D; 0; i &lt; numbers.size(); ++i) &#123;
            int low &#x3D; i + 1, high &#x3D; numbers.size() - 1;
            while (low &lt;&#x3D; high) &#123;
                int mid &#x3D; (high - low) &#x2F; 2 + low;
                if (numbers[mid] &#x3D;&#x3D; target - numbers[i]) &#123;
                    return &#123;i + 1, mid + 1&#125;;
                &#125; else if (numbers[mid] &gt; target - numbers[i]) &#123;
                    high &#x3D; mid - 1;
                &#125; else &#123;
                    low &#x3D; mid + 1;
                &#125;
            &#125;
        &#125;
        return &#123;-1, -1&#125;;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209. 长度最小的子数组"></a>209. 长度最小的子数组</h3><p>问题地址：<a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">https://leetcode.cn/problems/minimum-size-subarray-sum/</a></p>
<p>给定一个含有 n 个正整数的数组和一个正整数 target 。</p>
<p>找出该数组中满足其总和大于等于 target 的长度最小的 连续子数组 [numsl, numsl+1, …, numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int minSubArrayLen(int target, vector&lt;int&gt;&amp; nums) &#123;
        int n &#x3D; nums.size();
        if (n &#x3D;&#x3D; 0) &#123;
            return 0;
        &#125;
        int ans &#x3D; INT_MAX;
        int start &#x3D; 0, end &#x3D; 0;
        int sum &#x3D; 0;
        while (end &lt; n) &#123;
            sum +&#x3D; nums[end];
            while (sum &gt;&#x3D; target) &#123;
                ans &#x3D; min(ans, end - start + 1);
                sum -&#x3D; nums[start];
                start++;
            &#125;
            end++;
        &#125;
        return ans &#x3D;&#x3D; INT_MAX ? 0 : ans;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="54-螺旋矩阵"><a href="#54-螺旋矩阵" class="headerlink" title="54. 螺旋矩阵"></a>54. 螺旋矩阵</h3><p>问题地址：<a href="https://leetcode.cn/problems/spiral-matrix/">https://leetcode.cn/problems/spiral-matrix/</a></p>
<p>给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;
        if (matrix.size() &#x3D;&#x3D; 0 || matrix[0].size() &#x3D;&#x3D; 0) &#123;
            return &#123;&#125;;
        &#125;
        int rows &#x3D; matrix.size(), columns &#x3D; matrix[0].size();
        vector&lt;int&gt; order;
        int left &#x3D; 0, right &#x3D; columns - 1, top &#x3D; 0, bottom &#x3D; rows - 1;
        while (left &lt;&#x3D; right &amp;&amp; top &lt;&#x3D; bottom) &#123;
            for (int column &#x3D; left; column &lt;&#x3D; right; column++) &#123;
                order.push_back(matrix[top][column]);
            &#125;
            for (int row &#x3D; top + 1; row &lt;&#x3D; bottom; row++) &#123;
                order.push_back(matrix[row][right]);
            &#125;
            if (left &lt; right &amp;&amp; top &lt; bottom) &#123;
                for (int column &#x3D; right - 1; column &gt; left; column--) &#123;
                    order.push_back(matrix[bottom][column]);
                &#125;
                for (int row &#x3D; bottom; row &gt; top; row--) &#123;
                    order.push_back(matrix[row][left]);
                &#125;
            &#125;
            left++;
            right--;
            top++;
            bottom--;
        &#125;
        return order;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="48-旋转图像"><a href="#48-旋转图像" class="headerlink" title="48. 旋转图像"></a>48. 旋转图像</h3><p>问题地址：<a href="https://leetcode.cn/problems/rotate-image/">https://leetcode.cn/problems/rotate-image/</a></p>
<p>给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。</p>
<p>你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;
        int n &#x3D; matrix.size();
        for (int i &#x3D; 0; i &lt; n &#x2F; 2; ++i) &#123;
            for (int j &#x3D; 0; j &lt; (n + 1) &#x2F; 2; ++j) &#123;
                int temp &#x3D; matrix[i][j];
                matrix[i][j] &#x3D; matrix[n - j - 1][i];
                matrix[n - j - 1][i] &#x3D; matrix[n - i - 1][n - j - 1];
                matrix[n - i - 1][n - j - 1] &#x3D; matrix[j][n - i - 1];
                matrix[j][n - i - 1] &#x3D; temp;
            &#125;
        &#125;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="73-矩阵置零"><a href="#73-矩阵置零" class="headerlink" title="73. 矩阵置零"></a>73. 矩阵置零</h3><p>问题地址：<a href="https://leetcode.cn/problems/set-matrix-zeroes/">https://leetcode.cn/problems/set-matrix-zeroes/</a></p>
<p>给定一个 m x n 的矩阵，如果一个元素为 0 ，则将其所在行和列的所有元素都设为 0 。请使用 原地 算法。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    void setZeroes(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;
        int m &#x3D; matrix.size();
        int n &#x3D; matrix[0].size();
        vector&lt;int&gt; row(m), col(n);
        for (int i &#x3D; 0; i &lt; m; i++) &#123;
            for (int j &#x3D; 0; j &lt; n; j++) &#123;
                if (!matrix[i][j]) &#123;
                    row[i] &#x3D; col[j] &#x3D; true;
                &#125;
            &#125;
        &#125;
        for (int i &#x3D; 0; i &lt; m; i++) &#123;
            for (int j &#x3D; 0; j &lt; n; j++) &#123;
                if (row[i] || col[j]) &#123;
                    matrix[i][j] &#x3D; 0;
                &#125;
            &#125;
        &#125;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="289-生命游戏"><a href="#289-生命游戏" class="headerlink" title="289. 生命游戏"></a>289. 生命游戏</h3><p>问题地址：<a href="https://leetcode.cn/problems/game-of-life/">https://leetcode.cn/problems/game-of-life/</a></p>
<p>根据 百度百科 ， 生命游戏 ，简称为 生命 ，是英国数学家约翰·何顿·康威在 1970 年发明的细胞自动机。</p>
<p>给定一个包含 m × n 个格子的面板，每一个格子都可以看成是一个细胞。每个细胞都具有一个初始状态： 1 即为 活细胞 （live），或 0 即为 死细胞 （dead）。每个细胞与其八个相邻位置（水平，垂直，对角线）的细胞都遵循以下四条生存定律：</p>
<ol>
<li>如果活细胞周围八个位置的活细胞数少于两个，则该位置活细胞死亡；</li>
<li>如果活细胞周围八个位置有两个或三个活细胞，则该位置活细胞仍然存活；</li>
<li>如果活细胞周围八个位置有超过三个活细胞，则该位置活细胞死亡；</li>
<li>如果死细胞周围正好有三个活细胞，则该位置死细胞复活；</li>
</ol>
<p>下一个状态是通过将上述规则同时应用于当前状态下的每个细胞所形成的，其中细胞的出生和死亡是同时发生的。给你 m x n 网格面板 board 的当前状态，返回下一个状态。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    void gameOfLife(vector&lt;vector&lt;int&gt;&gt;&amp; board) &#123;
        int neighbors[3] &#x3D; &#123;0, 1, -1&#125;;
        int rows &#x3D; board.size();
        int cols &#x3D; board[0].size();

        vector&lt;vector&lt;int&gt;&gt; copyBoard(rows, vector&lt;int&gt;(cols, 0));

        for (int row &#x3D; 0; row &lt; rows; row++) &#123;
            for (int col &#x3D; 0; col &lt; cols; col++) &#123;
                copyBoard[row][col] &#x3D; board[row][col];
            &#125;
        &#125;

        for (int row &#x3D; 0; row &lt; rows; row++) &#123;
            for (int col &#x3D; 0; col &lt; cols; col++) &#123;
                int liveNeighbors &#x3D; 0;
                for (int i &#x3D; 0; i &lt; 3; i++) &#123;
                    for (int j &#x3D; 0; j &lt; 3; j++) &#123;
                        if (!(neighbors[i] &#x3D;&#x3D; 0 &amp;&amp; neighbors[j] &#x3D;&#x3D; 0)) &#123;
                            int r &#x3D; (row + neighbors[i]);
                            int c &#x3D; (col + neighbors[j]);

                            if ((r &lt; rows &amp;&amp; r &gt;&#x3D; 0) &amp;&amp; (c &lt; cols &amp;&amp; c &gt;&#x3D;0) &amp;&amp; (copyBoard[r][c] &#x3D;&#x3D; 1)) &#123;
                                liveNeighbors +&#x3D; 1;
                            &#125;
                        &#125;
                    &#125;
                &#125;

                if ((copyBoard[row][col] &#x3D;&#x3D; 1) &amp;&amp; (liveNeighbors &lt; 2 || liveNeighbors &gt; 3)) &#123;
                    board[row][col] &#x3D; 0;
                &#125;
                if (copyBoard[row][col] &#x3D;&#x3D; 0 &amp;&amp; liveNeighbors &#x3D;&#x3D; 3) &#123;
                    board[row][col] &#x3D; 1;
                &#125;
            &#125;
        &#125;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="128-最长连续序列"><a href="#128-最长连续序列" class="headerlink" title="128. 最长连续序列"></a>128. 最长连续序列</h3><p>问题地址：<a href="https://leetcode.cn/problems/longest-consecutive-sequence/">https://leetcode.cn/problems/longest-consecutive-sequence/</a></p>
<p>给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</p>
<p>请你设计并实现时间复杂度为 O(n) 的算法解决此问题。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int longestConsecutive(vector&lt;int&gt;&amp; nums) &#123;
        unordered_set&lt;int&gt; num_set;
        for (const int&amp; num : nums) &#123;
            num_set.insert(num);
        &#125;
        int longestStreak &#x3D; 0;
        for (const int&amp; num : num_set) &#123;
            if (!num_set.count(num - 1)) &#123;
                int currentNum &#x3D; num;
                int currentStreak &#x3D; 1;

                while (num_set.count(currentNum + 1)) &#123;
                    currentNum +&#x3D; 1;
                    currentStreak +&#x3D; 1;
                &#125;

                longestStreak &#x3D; max(longestStreak, currentStreak);
            &#125;
        &#125;
        return longestStreak;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="49-字母异位词分组"><a href="#49-字母异位词分组" class="headerlink" title="49. 字母异位词分组"></a>49. 字母异位词分组</h3><p>问题地址：<a href="https://leetcode.cn/problems/group-anagrams/">https://leetcode.cn/problems/group-anagrams/</a></p>
<p>给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。</p>
<p>字母异位词 是由重新排列源单词的所有字母得到的一个新单词。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) &#123;
        unordered_map&lt;string, vector&lt;string&gt;&gt; mp;
        for (string&amp; str : strs) &#123;
            string key &#x3D; str;
            sort(key.begin(), key.end());
            mp[key].emplace_back(str);
        &#125;
        vector&lt;vector&lt;string&gt;&gt; ans;
        for (auto it &#x3D; mp.begin(); it !&#x3D; mp.end(); ++it) &#123;
            ans.emplace_back(it-&gt;second);
        &#125;
        return ans;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56. 合并区间"></a>56. 合并区间</h3><p>问题地址：<a href="https://leetcode.cn/problems/merge-intervals/">https://leetcode.cn/problems/merge-intervals/</a></p>
<p>以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] &#x3D; [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    vector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123;
        if (intervals.size() &#x3D;&#x3D; 0) &#123;
            return &#123;&#125;;
        &#125;
        sort(intervals.begin(), intervals.end());
        vector&lt;vector&lt;int&gt;&gt; merged;
        for (int i &#x3D; 0; i &lt; intervals.size(); ++i) &#123;
            int L &#x3D; intervals[i][0], R &#x3D; intervals[i][1];
            if (!merged.size() || merged.back()[1] &lt; L) &#123;
                merged.push_back(&#123;L, R&#125;);
            &#125; else &#123;
                merged.back()[1] &#x3D; max(merged.back()[1], R);
            &#125;
        &#125;
        return merged;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="57-插入区间"><a href="#57-插入区间" class="headerlink" title="57. 插入区间"></a>57. 插入区间</h3><p>问题地址：<a href="https://leetcode.cn/problems/insert-interval/">https://leetcode.cn/problems/insert-interval/</a></p>
<p>给你一个 无重叠的 ，按照区间起始端点排序的区间列表。</p>
<p>在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    vector&lt;vector&lt;int&gt;&gt; insert(vector&lt;vector&lt;int&gt;&gt;&amp; intervals, vector&lt;int&gt;&amp; newInterval) &#123;
        int left &#x3D; newInterval[0];
        int right &#x3D; newInterval[1];
        bool placed &#x3D; false;
        vector&lt;vector&lt;int&gt;&gt; ans;
        for (const auto&amp; interval : intervals) &#123;
            if (interval[0] &gt; right) &#123;
                if (!placed) &#123;
                    ans.push_back(&#123;left, right&#125;);
                    placed &#x3D; true;
                &#125;
                ans.push_back(interval);
            &#125;
            else if (interval[1] &lt; left) &#123;
                ans.push_back(interval);
            &#125; else &#123;
                left &#x3D; min(left,interval[0]);
                right &#x3D; max(right, interval[1]);
            &#125;
        &#125;
        if (!placed) &#123;
            ans.push_back(&#123;left, right&#125;);
        &#125;
        return ans;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="452-用最少数量的箭引爆气球"><a href="#452-用最少数量的箭引爆气球" class="headerlink" title="452. 用最少数量的箭引爆气球"></a>452. 用最少数量的箭引爆气球</h3><p>问题地址：<a href="https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/">https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/</a></p>
<p>有一些球形气球贴在一堵用 XY 平面表示的墙面上。墙面上的气球记录在整数数组 points ，其中points[i] &#x3D; [xstart, xend] 表示水平直径在 xstart 和 xend之间的气球。你不知道气球的确切 y 坐标。</p>
<p>一支弓箭可以沿着 x 轴从不同点 完全垂直 地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足  xstart ≤ x ≤ xend，则该气球会被 引爆 。可以射出的弓箭的数量 没有限制 。 弓箭一旦被射出之后，可以无限地前进。</p>
<p>给你一个数组 points ，返回引爆所有气球所必须射出的 最小 弓箭数 。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int findMinArrowShots(vector&lt;vector&lt;int&gt;&gt;&amp; points) &#123;
        if (points.empty()) &#123;
            return 0;
        &#125;
        sort(points.begin(), points.end(), [](const vector&lt;int&gt;&amp; u, const vector&lt;int&gt;&amp; v) &#123;
            return u[1] &lt; v[1];
        &#125;);
        int pos &#x3D; points[0][1];
        int ans &#x3D; 1;
        for (const vector&lt;int&gt;&amp; balloon : points) &#123;
            if (balloon[0] &gt; pos) &#123;
                pos &#x3D; balloon[1];
                ++ans;
            &#125;
        &#125;
        return ans;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="71-简化路径"><a href="#71-简化路径" class="headerlink" title="71. 简化路径"></a>71. 简化路径</h3><p>问题地址：<a href="https://leetcode.cn/problems/simplify-path/">https://leetcode.cn/problems/simplify-path/</a></p>
<p>给你一个字符串 path ，表示指向某一文件或目录的 Unix 风格 绝对路径 （以 ‘&#x2F;‘ 开头），请你将其转化为更加简洁的规范路径。</p>
<p>在 Unix 风格的文件系统中，一个点（.）表示当前目录本身；此外，两个点 （..） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。任意多个连续的斜杠（即，’&#x2F;&#x2F;‘）都被视为单个斜杠 ‘&#x2F;‘ 。 对于此问题，任何其他格式的点（例如，’…’）均被视为文件&#x2F;目录名称。</p>
<p>请注意，返回的 规范路径 必须遵循下述格式：</p>
<ul>
<li>始终以斜杠 ‘&#x2F;‘ 开头。</li>
<li>两个目录名之间必须只有一个斜杠 ‘&#x2F;‘ 。</li>
<li>最后一个目录名（如果存在）不能 以 ‘&#x2F;‘ 结尾。</li>
<li>此外，路径仅包含从根目录到目标文件或目录的路径上的目录（即，不含 ‘.’ 或 ‘..’）。</li>
</ul>
<p>返回简化后得到的 规范路径 。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    string simplifyPath(string path) &#123;
        auto split &#x3D; [](const string&amp; s, char delim) -&gt; vector&lt;string&gt; &#123;
            vector&lt;string&gt; ans;
            string cur;
            for (char ch : s) &#123;
                if (ch &#x3D;&#x3D; delim) &#123;
                    ans.push_back(move(cur));
                    cur.clear();
                &#125; else &#123;
                    cur +&#x3D; ch;
                &#125;
            &#125;
            ans.push_back(move(cur));
            return ans;
        &#125;;
        vector&lt;string&gt; names &#x3D; split(path, &#39;&#x2F;&#39;);
        vector&lt;string&gt; stack;
        for (string&amp; name : names) &#123;
            if (name &#x3D;&#x3D; &quot;..&quot;) &#123;
                if (!stack.empty()) &#123;
                    stack.pop_back();
                &#125;
            &#125; else if (!name.empty() &amp;&amp; name !&#x3D; &quot;.&quot;) &#123;
                stack.push_back(move(name));
            &#125;
        &#125;
        string ans;
        if (stack.empty()) &#123;
            ans &#x3D; &quot;&#x2F;&quot;;
        &#125; else &#123;
            for (string&amp; name : stack) &#123;
                ans +&#x3D; &quot;&#x2F;&quot; + move(name);
            &#125;
        &#125;
        return ans;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="155-最小栈"><a href="#155-最小栈" class="headerlink" title="155. 最小栈"></a>155. 最小栈</h3><p>问题地址：<a href="https://leetcode.cn/problems/min-stack/">https://leetcode.cn/problems/min-stack/</a></p>
<p>设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。</p>
<p>实现 MinStack 类:</p>
<ul>
<li>MinStack() 初始化堆栈对象。</li>
<li>void push(int val) 将元素val推入堆栈。</li>
<li>void pop() 删除堆栈顶部的元素。</li>
<li>int top() 获取堆栈顶部的元素。</li>
<li>int getMin() 获取堆栈中的最小元素。</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class MinStack &#123;
    stack&lt;int&gt; x_stack;
    stack&lt;int&gt; min_stack;
public:
    MinStack() &#123;
        min_stack.push(INT_MAX);
    &#125;
    
    void push(int val) &#123;
        x_stack.push(val);
        min_stack.push(min(min_stack.top(), val));
    &#125;
    
    void pop() &#123;
        x_stack.pop();
        min_stack.pop();
    &#125;
    
    int top() &#123;
        return x_stack.top();
    &#125;
    
    int getMin() &#123;
        return min_stack.top();
    &#125;
&#125;;

&#x2F;**
 * Your MinStack object will be instantiated and called as such:
 * MinStack* obj &#x3D; new MinStack();
 * obj-&gt;push(val);
 * obj-&gt;pop();
 * int param_3 &#x3D; obj-&gt;top();
 * int param_4 &#x3D; obj-&gt;getMin();
 *&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="150-逆波兰表达式求值"><a href="#150-逆波兰表达式求值" class="headerlink" title="150. 逆波兰表达式求值"></a>150. 逆波兰表达式求值</h3><p>问题地址：<a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/">https://leetcode.cn/problems/evaluate-reverse-polish-notation/</a></p>
<p>给你一个字符串数组 tokens ，表示一个根据 逆波兰表示法 表示的算术表达式。</p>
<p>请你计算该表达式。返回一个表示表达式值的整数。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int evalRPN(vector&lt;string&gt;&amp; tokens) &#123;
        stack&lt;int&gt; stk;
        int n &#x3D; tokens.size();
        for (int i &#x3D; 0; i &lt; n; i++) &#123;
            string&amp; token &#x3D; tokens[i];
            if (isNumber(token)) &#123;
                stk.push(atoi(token.c_str()));
            &#125; else &#123;
                int num2 &#x3D; stk.top();
                stk.pop();
                int num1 &#x3D; stk.top();
                stk.pop();
                switch (token[0]) &#123;
                    case &#39;+&#39;:
                        stk.push(num1 + num2);
                        break;
                    case &#39;-&#39;:
                        stk.push(num1 - num2);
                        break;
                    case &#39;*&#39;:
                        stk.push(num1 * num2);
                        break;
                    case &#39;&#x2F;&#39;:
                        stk.push(num1 &#x2F; num2);
                        break;
                &#125;
            &#125;
        &#125;
        return stk.top();
    &#125;

    bool isNumber(string&amp; token) &#123;
        return !(token &#x3D;&#x3D; &quot;+&quot; || token &#x3D;&#x3D; &quot;-&quot; || token &#x3D;&#x3D; &quot;*&quot; || token &#x3D;&#x3D; &quot;&#x2F;&quot;);
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="138-随机链表的复制"><a href="#138-随机链表的复制" class="headerlink" title="138. 随机链表的复制"></a>138. 随机链表的复制</h3><p>问题地址：<a href="https://leetcode.cn/problems/copy-list-with-random-pointer/">https://leetcode.cn/problems/copy-list-with-random-pointer/</a></p>
<p>给你一个长度为 n 的链表，每个节点包含一个额外增加的随机指针 random ，该指针可以指向链表中的任何节点或空节点。</p>
<p>构造这个链表的 深拷贝。 深拷贝应该正好由 n 个 全新 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 next 指针和 random 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。复制链表中的指针都不应指向原链表中的节点 。</p>
<p>例如，如果原链表中有 X 和 Y 两个节点，其中 X.random –&gt; Y 。那么在复制链表中对应的两个节点 x 和 y ，同样有 x.random –&gt; y 。</p>
<p>返回复制链表的头节点。</p>
<p>用一个由 n 个节点组成的链表来表示输入&#x2F;输出中的链表。每个节点用一个 [val, random_index] 表示：</p>
<ul>
<li>val：一个表示 Node.val 的整数。</li>
<li>random_index：随机指针指向的节点索引（范围从 0 到 n-1）；如果不指向任何节点，则为  null 。</li>
</ul>
<p>你的代码 只 接受原链表的头节点 head 作为传入参数。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;*
&#x2F;&#x2F; Definition for a Node.
class Node &#123;
public:
    int val;
    Node* next;
    Node* random;
    
    Node(int _val) &#123;
        val &#x3D; _val;
        next &#x3D; NULL;
        random &#x3D; NULL;
    &#125;
&#125;;
*&#x2F;

class Solution &#123;
public:
    unordered_map&lt;Node*, Node*&gt; cachedNode;
    Node* copyRandomList(Node* head) &#123;
        if (head &#x3D;&#x3D; nullptr) &#123;
            return nullptr;
        &#125;
        if (!cachedNode.count(head)) &#123;
            Node* headNew &#x3D; new Node(head-&gt;val);
            cachedNode[head] &#x3D; headNew;
            headNew-&gt;next &#x3D; copyRandomList(head-&gt;next);
            headNew-&gt;random &#x3D; copyRandomList(head-&gt;random);
        &#125;
        return cachedNode[head];
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="221-最大正方形"><a href="#221-最大正方形" class="headerlink" title="221. 最大正方形"></a>221. 最大正方形</h3><p>问题地址：<a href="https://leetcode.cn/problems/maximal-square/">https://leetcode.cn/problems/maximal-square/</a></p>
<p>在一个由 ‘0’ 和 ‘1’ 组成的二维矩阵内，找到只包含 ‘1’ 的最大正方形，并返回其面积。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int maximalSquare(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) &#123;
        if (matrix.size() &#x3D;&#x3D; 0 || matrix[0].size() &#x3D;&#x3D; 0) &#123;
            return 0;
        &#125;
        int maxSide &#x3D; 0;
        int rows &#x3D; matrix.size(), columns &#x3D; matrix[0].size();
        vector&lt;vector&lt;int&gt;&gt; dp(rows, vector&lt;int&gt;(columns));
        for (int i &#x3D; 0; i &lt; rows; i++) &#123;
            for (int j &#x3D; 0; j &lt; columns; j++) &#123;
                if (matrix[i][j] &#x3D;&#x3D; &#39;1&#39;) &#123;
                    if (i &#x3D;&#x3D; 0 || j &#x3D;&#x3D; 0) &#123;
                        dp[i][j] &#x3D; 1;
                    &#125; else &#123;
                        dp[i][j] &#x3D; min(min(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1]) + 1;
                    &#125;
                    maxSide &#x3D; max(maxSide, dp[i][j]);
                &#125;
            &#125;
        &#125;
        int maxSquare &#x3D; maxSide * maxSide;
        return maxSquare;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="92-反转链表-II"><a href="#92-反转链表-II" class="headerlink" title="92. 反转链表 II"></a>92. 反转链表 II</h3><p>问题地址：<a href="https://leetcode.cn/problems/reverse-linked-list-ii/">https://leetcode.cn/problems/reverse-linked-list-ii/</a></p>
<p>给你单链表的头指针 head 和两个整数 left 和 right ，其中 left &lt;&#x3D; right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;**
 * Definition for singly-linked list.
 * struct ListNode &#123;
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) &#123;&#125;
 *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;
 *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;
 * &#125;;
 *&#x2F;
class Solution &#123;
public:
    ListNode* reverseBetween(ListNode* head, int left, int right) &#123;
        ListNode *dummyNode &#x3D; new ListNode(-1);
        dummyNode-&gt;next &#x3D; head;

        ListNode * pre &#x3D; dummyNode;
        for (int i &#x3D; 0; i &lt; left - 1; i++) &#123;
            pre &#x3D; pre-&gt;next;
        &#125;
        ListNode *rightNode &#x3D; pre;
        for (int i &#x3D; 0; i &lt; right - left + 1; i++) &#123;
            rightNode &#x3D; rightNode-&gt;next;
        &#125;
        ListNode *leftNode &#x3D; pre-&gt;next;
        ListNode *curr &#x3D; rightNode-&gt;next;

        pre-&gt;next &#x3D; nullptr;
        rightNode-&gt;next &#x3D; nullptr;

        reverseLinkedList(leftNode);

        pre-&gt;next &#x3D; rightNode;
        leftNode-&gt;next &#x3D; curr;
        return dummyNode-&gt;next;
    &#125;

    void reverseLinkedList(ListNode *head) &#123;
        ListNode *pre &#x3D; nullptr;
        ListNode *cur &#x3D; head;

        while (cur !&#x3D; nullptr) &#123;
            ListNode *next &#x3D; cur-&gt;next;
            cur-&gt;next &#x3D; pre;
            pre &#x3D; cur;
            cur &#x3D; next;
        &#125;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="82-删除排序链表中的重复元素-II"><a href="#82-删除排序链表中的重复元素-II" class="headerlink" title="82. 删除排序链表中的重复元素 II"></a>82. 删除排序链表中的重复元素 II</h3><p>问题地址：<a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/">https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/</a></p>
<p>给定一个已排序的链表的头 head ， 删除原始链表中所有重复数字的节点，只留下不同的数字 。返回 已排序的链表 。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;**
 * Definition for singly-linked list.
 * struct ListNode &#123;
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) &#123;&#125;
 *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;
 *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;
 * &#125;;
 *&#x2F;
class Solution &#123;
public:
    ListNode* deleteDuplicates(ListNode* head) &#123;
        if (!head) &#123;
            return head;
        &#125;
        ListNode* dummy &#x3D; new ListNode(0, head);
        ListNode* cur &#x3D; dummy;
        while (cur-&gt;next &amp;&amp; cur-&gt;next-&gt;next) &#123;
            if (cur-&gt;next-&gt;val &#x3D;&#x3D; cur-&gt;next-&gt;next-&gt;val) &#123;
                int x &#x3D; cur-&gt;next-&gt;val;
                while (cur-&gt;next &amp;&amp; cur-&gt;next-&gt;val &#x3D;&#x3D; x) &#123;
                    cur-&gt;next &#x3D; cur-&gt;next-&gt;next;
                &#125;
            &#125; else &#123;
                cur &#x3D; cur-&gt;next;
            &#125;
        &#125;
        return dummy-&gt;next;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="61-旋转链表"><a href="#61-旋转链表" class="headerlink" title="61. 旋转链表"></a>61. 旋转链表</h3><p>问题地址：<a href="https://leetcode.cn/problems/rotate-list/">https://leetcode.cn/problems/rotate-list/</a></p>
<p>给你一个链表的头节点 head ，旋转链表，将链表每个节点向右移动 k 个位置。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;**
 * Definition for singly-linked list.
 * struct ListNode &#123;
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) &#123;&#125;
 *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;
 *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;
 * &#125;;
 *&#x2F;
class Solution &#123;
public:
    ListNode* rotateRight(ListNode* head, int k) &#123;
        if (k &#x3D;&#x3D; 0 || head &#x3D;&#x3D; nullptr || head-&gt;next &#x3D;&#x3D; nullptr) &#123;
            return head;
        &#125;
        int n &#x3D; 1;
        ListNode* iter &#x3D; head;
        while (iter-&gt;next !&#x3D; nullptr) &#123;
            iter &#x3D; iter-&gt;next;
            n++;
        &#125;
        int add &#x3D; n - k % n;
        if (add &#x3D;&#x3D; n) &#123;
            return head;
        &#125;
        iter-&gt;next &#x3D; head;
        while (add--) &#123;
            iter &#x3D; iter-&gt;next;
        &#125;
        ListNode* ret &#x3D; iter-&gt;next;
        iter-&gt;next &#x3D; nullptr;
        return ret;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="146-LRU-缓存"><a href="#146-LRU-缓存" class="headerlink" title="146. LRU 缓存"></a>146. LRU 缓存</h3><p>问题地址：<a href="https://leetcode.cn/problems/lru-cache/">https://leetcode.cn/problems/lru-cache/</a></p>
<p>请你设计并实现一个满足  LRU (最近最少使用) 缓存 约束的数据结构。</p>
<p>实现 LRUCache 类：</p>
<ul>
<li>LRUCache(int capacity) 以 正整数 作为容量 capacity 初始化 LRU 缓存</li>
<li>int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。</li>
<li>void put(int key, int value) 如果关键字 key 已经存在，则变更其数据值 value ；如果不存在，则向缓存中插入该组 key-value 。如果插入操作导致关键字数量超过 capacity ，则应该 逐出 最久未使用的关键字。</li>
</ul>
<p>函数 get 和 put 必须以 O(1) 的平均时间复杂度运行。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct DLinkedNode &#123;
    int key, value;
    DLinkedNode* prev;
    DLinkedNode* next;
    DLinkedNode(): key(0), value(0), prev(nullptr), next(nullptr) &#123;&#125;
    DLinkedNode(int _key, int _value): key(_key), value(_value), prev(nullptr), next(nullptr) &#123;&#125;
&#125;;

class LRUCache &#123;
private:
    unordered_map&lt;int, DLinkedNode*&gt; cache;
    DLinkedNode* head;
    DLinkedNode* tail;
    int size;
    int capacity;
public:
    LRUCache(int _capacity): capacity(_capacity), size(0) &#123;
        head &#x3D; new DLinkedNode();
        tail &#x3D; new DLinkedNode();
        head-&gt;next &#x3D; tail;
        tail-&gt;prev &#x3D; head;
    &#125;
    
    int get(int key) &#123;
        if (!cache.count(key)) &#123;
            return -1;
        &#125;
        DLinkedNode* node &#x3D; cache[key];
        moveToHead(node);
        return node-&gt;value;
    &#125;
    
    void put(int key, int value) &#123;
        if (!cache.count(key)) &#123;
            DLinkedNode* node &#x3D; new DLinkedNode(key, value);
            cache[key] &#x3D; node;
            addToHead(node);
            ++size;
            if (size &gt; capacity) &#123;
                DLinkedNode* removed &#x3D; removeTail();
                cache.erase(removed-&gt;key);
                delete removed;
                --size;
            &#125;
        &#125; else &#123;
            DLinkedNode* node &#x3D; cache[key];
            node-&gt;value &#x3D; value;
            moveToHead(node);
        &#125;
    &#125;

    void addToHead(DLinkedNode* node) &#123;
        node-&gt;prev &#x3D; head;
        node-&gt;next &#x3D; head-&gt;next;
        head-&gt;next-&gt;prev &#x3D; node;
        head-&gt;next &#x3D; node;
    &#125;

    void removeNode(DLinkedNode* node) &#123;
        node-&gt;prev-&gt;next &#x3D; node-&gt;next;
        node-&gt;next-&gt;prev &#x3D; node-&gt;prev;
    &#125;
    void moveToHead(DLinkedNode* node) &#123;
        removeNode(node);
        addToHead(node);
    &#125;
    DLinkedNode* removeTail() &#123;
        DLinkedNode* node &#x3D; tail-&gt;prev;
        removeNode(node);
        return node;
    &#125;
&#125;;

&#x2F;**
 * Your LRUCache object will be instantiated and called as such:
 * LRUCache* obj &#x3D; new LRUCache(capacity);
 * int param_1 &#x3D; obj-&gt;get(key);
 * obj-&gt;put(key,value);
 *&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树"></a>105. 从前序与中序遍历序列构造二叉树</h3><p>问题地址：<a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/</a></p>
<p>给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;**
 * Definition for a binary tree node.
 * struct TreeNode &#123;
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;
 * &#125;;
 *&#x2F;
class Solution &#123;
private:
    unordered_map&lt;int, int&gt; index;
public:
    TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) &#123;
        int n &#x3D; preorder.size();
        for (int i &#x3D; 0; i &lt; n; ++i) &#123;
            index[inorder[i]] &#x3D; i;
        &#125;
        return build_tree(preorder, inorder, 0, n - 1, 0, n - 1);
    &#125;
    TreeNode* build_tree(const vector&lt;int&gt;&amp; preorder, const vector&lt;int&gt;&amp; inorder,
        int preorder_left, int preorder_right, int inorder_left, int inorder_right) &#123;
        if (preorder_left &gt; preorder_right) &#123;
            return nullptr;
        &#125;
        int preorder_root &#x3D; preorder_left;
        int inorder_root &#x3D; index[preorder[preorder_root]];
        TreeNode* root &#x3D; new TreeNode(preorder[preorder_root]);
        int size_left_subtree &#x3D; inorder_root - inorder_left;
        root-&gt;left &#x3D; build_tree(preorder, inorder, preorder_left + 1, preorder_left + size_left_subtree,
            inorder_left, inorder_root - 1);
        root-&gt;right &#x3D; build_tree(preorder, inorder, preorder_left + size_left_subtree + 1, preorder_right,
            inorder_root + 1, inorder_right);
        return root;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="106-从中序与后序遍历序列构造二叉树"><a href="#106-从中序与后序遍历序列构造二叉树" class="headerlink" title="106. 从中序与后序遍历序列构造二叉树"></a>106. 从中序与后序遍历序列构造二叉树</h3><p>问题地址：<a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/</a></p>
<p>给定两个整数数组 inorder 和 postorder ，其中 inorder 是二叉树的中序遍历， postorder 是同一棵树的后序遍历，请你构造并返回这颗 二叉树 。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;**
 * Definition for a binary tree node.
 * struct TreeNode &#123;
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;
 * &#125;;
 *&#x2F;
class Solution &#123;
private:
    int post_idx;
    unordered_map&lt;int, int&gt; idx_map;
public:
    TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) &#123;
        post_idx &#x3D; (int)postorder.size() - 1;
        int idx &#x3D; 0;
        for (auto&amp; val : inorder) &#123;
            idx_map[val] &#x3D; idx++;
        &#125;
        return helper(0, (int)inorder.size() - 1, inorder, postorder);
    &#125;
    TreeNode* helper(int int_left, int in_right, vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) &#123;
        if (int_left &gt; in_right) &#123;
            return nullptr;
        &#125;
        int root_val &#x3D; postorder[post_idx];
        TreeNode* root &#x3D; new TreeNode(root_val);
        int index &#x3D; idx_map[root_val];
        post_idx--;
        root-&gt;right &#x3D; helper(index + 1, in_right, inorder, postorder);
        root-&gt;left &#x3D; helper(int_left, index - 1, inorder, postorder);
        return root;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="117-填充每个节点的下一个右侧节点指针-II"><a href="#117-填充每个节点的下一个右侧节点指针-II" class="headerlink" title="117. 填充每个节点的下一个右侧节点指针 II"></a>117. 填充每个节点的下一个右侧节点指针 II</h3><p>问题地址：<a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/">https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/</a></p>
<p>给定一个二叉树：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct Node &#123;
  int val;
  Node *left;
  Node *right;
  Node *next;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL 。</p>
<p>初始状态下，所有 next 指针都被设置为 NULL 。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;*
&#x2F;&#x2F; Definition for a Node.
class Node &#123;
public:
    int val;
    Node* left;
    Node* right;
    Node* next;

    Node() : val(0), left(NULL), right(NULL), next(NULL) &#123;&#125;

    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) &#123;&#125;

    Node(int _val, Node* _left, Node* _right, Node* _next)
        : val(_val), left(_left), right(_right), next(_next) &#123;&#125;
&#125;;
*&#x2F;

class Solution &#123;
public:
    Node* connect(Node* root) &#123;
        if (!root) return root;
        queue&lt;Node*&gt; q;
        q.push(root);
        Node* last;
        Node* node;
        int size;
        while (!q.empty()) &#123;
            size &#x3D; q.size();
            last &#x3D; nullptr;
            while (size-- &gt; 0) &#123;
                node &#x3D; q.front();
                q.pop();
                if (last) last-&gt;next &#x3D; node;
                if (node-&gt;left) q.push(node-&gt;left);
                if (node-&gt;right) q.push(node-&gt;right);
                last &#x3D; node;
            &#125;
        &#125;
        return root;  
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="114-二叉树展开为链表"><a href="#114-二叉树展开为链表" class="headerlink" title="114. 二叉树展开为链表"></a>114. 二叉树展开为链表</h3><p>问题地址：<a href="https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/">https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/</a></p>
<p>给你二叉树的根结点 root ，请你将它展开为一个单链表：</p>
<ul>
<li>展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。</li>
<li>展开后的单链表应该与二叉树 先序遍历 顺序相同。</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;**
 * Definition for a binary tree node.
 * struct TreeNode &#123;
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;
 * &#125;;
 *&#x2F;
class Solution &#123;
public:
    void flatten(TreeNode* root) &#123;
        vector&lt;TreeNode*&gt; l;
        preorder(root, l);
        int n &#x3D; l.size();
        for (int i &#x3D; 1; i &lt; n; i++) &#123;
            TreeNode *prev &#x3D; l[i-1], *curr &#x3D; l[i];
            prev-&gt;left &#x3D; nullptr;
            prev-&gt;right &#x3D; curr;
        &#125;
    &#125;
    void preorder(TreeNode* root, vector&lt;TreeNode*&gt; &amp;l) &#123;
        if (root !&#x3D; nullptr) &#123;
            l.push_back(root);
            preorder(root-&gt;left, l);
            preorder(root-&gt;right, l);
        &#125;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="129-求根节点到叶节点数字之和"><a href="#129-求根节点到叶节点数字之和" class="headerlink" title="129. 求根节点到叶节点数字之和"></a>129. 求根节点到叶节点数字之和</h3><p>问题地址：<a href="https://leetcode.cn/problems/sum-root-to-leaf-numbers/">https://leetcode.cn/problems/sum-root-to-leaf-numbers/</a></p>
<p>给你一个二叉树的根节点 root ，树中每个节点都存放有一个 0 到 9 之间的数字。<br>每条从根节点到叶节点的路径都代表一个数字：</p>
<ul>
<li>例如，从根节点到叶节点的路径 1 -&gt; 2 -&gt; 3 表示数字 123 。</li>
</ul>
<p>计算从根节点到叶节点生成的 所有数字之和 。</p>
<p>叶节点 是指没有子节点的节点。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;**
 * Definition for a binary tree node.
 * struct TreeNode &#123;
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;
 * &#125;;
 *&#x2F;
class Solution &#123;
public:
    int sumNumbers(TreeNode* root) &#123;
        return dfs(root, 0);
    &#125;
    int dfs(TreeNode* root, int preSum) &#123;
        if (root &#x3D;&#x3D; nullptr) &#123;
            return 0;
        &#125;
        int sum &#x3D; preSum * 10 + root-&gt;val;
        if (root-&gt;left &#x3D;&#x3D; nullptr &amp;&amp; root-&gt;right &#x3D;&#x3D; nullptr) &#123;
            return sum;
        &#125; else &#123;
            return dfs(root-&gt;left, sum) + dfs(root-&gt;right, sum);
        &#125;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="173-二叉搜索树迭代器"><a href="#173-二叉搜索树迭代器" class="headerlink" title="173. 二叉搜索树迭代器"></a>173. 二叉搜索树迭代器</h3><p>问题地址：<a href="https://leetcode.cn/problems/binary-search-tree-iterator/">https://leetcode.cn/problems/binary-search-tree-iterator/</a></p>
<p>实现一个二叉搜索树迭代器类BSTIterator ，表示一个按中序遍历二叉搜索树（BST）的迭代器：</p>
<ul>
<li>BSTIterator(TreeNode root) 初始化 BSTIterator 类的一个对象。BST 的根节点 root 会作为构造函数的一部分给出。指针应初始化为一个不存在于 BST 中的数字，且该数字小于 BST 中的任何元素。</li>
<li>boolean hasNext() 如果向指针右侧遍历存在数字，则返回 true ；否则返回 false 。</li>
<li>int next()将指针向右移动，然后返回指针处的数字。</li>
</ul>
<p>注意，指针初始化为一个不存在于 BST 中的数字，所以对 next() 的首次调用将返回 BST 中的最小元素。</p>
<p>你可以假设 next() 调用总是有效的，也就是说，当调用 next() 时，BST 的中序遍历中至少存在一个下一个数字。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;**
 * Definition for a binary tree node.
 * struct TreeNode &#123;
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;
 * &#125;;
 *&#x2F;
class BSTIterator &#123;
private:
    void inorder(TreeNode* root, vector&lt;int&gt;&amp; res) &#123;
        if (!root) &#123;
            return;
        &#125;
        inorder(root-&gt;left, res);
        res.push_back(root-&gt;val);
        inorder(root-&gt;right, res);
    &#125;
    vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;
        vector&lt;int&gt; res;
        inorder(root, res);
        return res;
    &#125;
    vector&lt;int&gt; arr;
    int idx;
public:
    BSTIterator(TreeNode* root): idx(0), arr(inorderTraversal(root)) &#123;&#125;
    
    int next() &#123;
        return arr[idx++];
    &#125;
    
    bool hasNext() &#123;
        return (idx &lt; arr.size());
    &#125;
&#125;;

&#x2F;**
 * Your BSTIterator object will be instantiated and called as such:
 * BSTIterator* obj &#x3D; new BSTIterator(root);
 * int param_1 &#x3D; obj-&gt;next();
 * bool param_2 &#x3D; obj-&gt;hasNext();
 *&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236. 二叉树的最近公共祖先"></a>236. 二叉树的最近公共祖先</h3><p>问题地址：<a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/</a></p>
<p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;**
 * Definition for a binary tree node.
 * struct TreeNode &#123;
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;
 * &#125;;
 *&#x2F;
class Solution &#123;
private:
    TreeNode* ans;
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;
        dfs(root, p, q);
        return ans;
    &#125;
    bool dfs(TreeNode* root, TreeNode* p, TreeNode* q) &#123;
        if (root &#x3D;&#x3D; nullptr) return false;
        bool lson &#x3D; dfs(root-&gt;left, p, q);
        bool rson &#x3D; dfs(root-&gt;right, p, q);
        if ((lson &amp;&amp; rson) || ((root-&gt;val &#x3D;&#x3D; p-&gt;val || root-&gt; val &#x3D;&#x3D; q-&gt;val) &amp;&amp; (lson || rson))) &#123;
            ans &#x3D; root;
        &#125;
        return lson || rson || root-&gt;val &#x3D;&#x3D; p-&gt;val || root-&gt;val &#x3D;&#x3D; q-&gt;val;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="199-二叉树的右视图"><a href="#199-二叉树的右视图" class="headerlink" title="199. 二叉树的右视图"></a>199. 二叉树的右视图</h3><p>问题地址：<a href="https://leetcode.cn/problems/binary-tree-right-side-view/">https://leetcode.cn/problems/binary-tree-right-side-view/</a></p>
<p>给定一个二叉树的 根节点 root，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;**
 * Definition for a binary tree node.
 * struct TreeNode &#123;
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;
 * &#125;;
 *&#x2F;
class Solution &#123;
public:
    vector&lt;int&gt; rightSideView(TreeNode* root) &#123;
        vector&lt;int&gt; ans;
        queue&lt;TreeNode*&gt; q;
        if (root) q.push(root);
        while (!q.empty()) &#123;
            int n &#x3D; q.size();
            while (n--) &#123;
                if (q.front()-&gt;left) q.push(q.front()-&gt;left);
                if (q.front()-&gt;right) q.push(q.front()-&gt;right);
                if (n &#x3D;&#x3D; 0) ans.push_back(q.front()-&gt;val);
                q.pop();
            &#125;
        &#125;
        return ans;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102. 二叉树的层序遍历"></a>102. 二叉树的层序遍历</h3><p>问题地址：<a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">https://leetcode.cn/problems/binary-tree-level-order-traversal/</a></p>
<p>给你二叉树的根节点 root ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;**
 * Definition for a binary tree node.
 * struct TreeNode &#123;
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;
 * &#125;;
 *&#x2F;
class Solution &#123;
public:
    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123;
        vector&lt;vector&lt;int&gt;&gt; ret;
        if (!root) &#123;
            return ret;
        &#125;
        queue&lt;TreeNode*&gt; q;
        q.push(root);
        while (!q.empty()) &#123;
            auto n &#x3D; q.size();
            ret.push_back(vector&lt;int&gt;());
            while (n--) &#123;
                auto node &#x3D; q.front(); q.pop();
                ret.back().push_back(node-&gt;val);
                if (node-&gt;left) q.push(node-&gt;left);
                if (node-&gt;right) q.push(node-&gt;right);
            &#125;
        &#125;
        return ret;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="103-二叉树的锯齿形层序遍历"><a href="#103-二叉树的锯齿形层序遍历" class="headerlink" title="103. 二叉树的锯齿形层序遍历"></a>103. 二叉树的锯齿形层序遍历</h3><p>问题地址：<a href="https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/">https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/</a></p>
<p>给你二叉树的根节点 root ，返回其节点值的 锯齿形层序遍历 。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;**
 * Definition for a binary tree node.
 * struct TreeNode &#123;
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;
 * &#125;;
 *&#x2F;
class Solution &#123;
public:
    vector&lt;vector&lt;int&gt;&gt; zigzagLevelOrder(TreeNode* root) &#123;
        vector&lt;vector&lt;int&gt;&gt; ans;
        if (!root) &#123;
            return ans;
        &#125;
        queue&lt;TreeNode*&gt; q;
        q.push(root);
        bool left &#x3D; true;
        while (!q.empty()) &#123;
            deque&lt;int&gt; list;
            int n &#x3D; q.size();
            while (n--) &#123;
                auto node &#x3D; q.front();
                q.pop();
                if (left) &#123;
                    list.push_back(node-&gt;val);
                &#125; else &#123;
                    list.push_front(node-&gt;val);
                &#125;
                if (node-&gt;left) &#123;
                    q.push(node-&gt;left);
                &#125;
                if (node-&gt;right) &#123;
                    q.push(node-&gt;right);
                &#125;
            &#125;
            ans.emplace_back(vector&lt;int&gt;&#123;list.begin(), list.end()&#125;);
            left &#x3D; !left;
        &#125;
        return ans;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="230-二叉搜索树中第K小的元素"><a href="#230-二叉搜索树中第K小的元素" class="headerlink" title="230. 二叉搜索树中第K小的元素"></a>230. 二叉搜索树中第K小的元素</h3><p>问题地址：<a href="https://leetcode.cn/problems/kth-smallest-element-in-a-bst/">https://leetcode.cn/problems/kth-smallest-element-in-a-bst/</a></p>
<p>给定一个二叉搜索树的根节点 root ，和一个整数 k ，请你设计一个算法查找其中第 k 个最小元素（从 1 开始计数）。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;**
 * Definition for a binary tree node.
 * struct TreeNode &#123;
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;
 * &#125;;
 *&#x2F;
class Solution &#123;
private:
    vector&lt;int&gt; ans;
public:
    int kthSmallest(TreeNode* root, int k) &#123;
        dfs(root);
        return ans[k - 1];
    &#125;
    void dfs(TreeNode* root) &#123;
        if (root &#x3D;&#x3D; nullptr) return;
        dfs(root-&gt;left);
        ans.push_back(root-&gt;val);
        dfs(root-&gt;right);
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98. 验证二叉搜索树"></a>98. 验证二叉搜索树</h3><p>问题地址：<a href="https://leetcode.cn/problems/validate-binary-search-tree/">https://leetcode.cn/problems/validate-binary-search-tree/</a></p>
<p>给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。</p>
<p>有效 二叉搜索树定义如下：</p>
<ul>
<li>节点的左子树只包含 小于 当前节点的数。</li>
<li>节点的右子树只包含 大于 当前节点的数。</li>
<li>所有左子树和右子树自身必须也是二叉搜索树。</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;**
 * Definition for a binary tree node.
 * struct TreeNode &#123;
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;
 * &#125;;
 *&#x2F;
class Solution &#123;
public:
    bool isValidBST(TreeNode* root) &#123;
        return helper(root, LONG_MIN, LONG_MAX);
    &#125;
    bool helper(TreeNode* root, long long lower, long long upper) &#123;
        if (root &#x3D;&#x3D; nullptr) return true;
        if (root-&gt;val &lt;&#x3D; lower || root-&gt;val &gt;&#x3D; upper) &#123;
            return false;
        &#125;
        return helper(root-&gt;left, lower, root-&gt;val) &amp;&amp; helper(root-&gt;right, root-&gt;val, upper);
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title="200. 岛屿数量"></a>200. 岛屿数量</h3><p>问题地址：<a href="https://leetcode.cn/problems/number-of-islands/">https://leetcode.cn/problems/number-of-islands/</a></p>
<p>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。</p>
<p>岛屿总是被水包围，并且每座岛屿只能由水平方向和&#x2F;或竖直方向上相邻的陆地连接形成。</p>
<p>此外，你可以假设该网格的四条边均被水包围。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
private:
    int r, c;
    void dfs(vector&lt;vector&lt;char&gt;&gt;&amp; grid, int i, int j) &#123;
        grid[i][j] &#x3D; &#39;0&#39;;
        if (i - 1 &gt;&#x3D; 0 &amp;&amp; grid[i-1][j] &#x3D;&#x3D; &#39;1&#39;) dfs(grid, i - 1, j);
        if (i + 1 &lt; r &amp;&amp; grid[i+1][j] &#x3D;&#x3D; &#39;1&#39;) dfs(grid, i + 1, j);
        if (j - 1 &gt;&#x3D; 0 &amp;&amp; grid[i][j-1] &#x3D;&#x3D; &#39;1&#39;) dfs(grid, i, j - 1);
        if (j + 1 &lt; c &amp;&amp; grid[i][j+1] &#x3D;&#x3D; &#39;1&#39;) dfs(grid, i, j + 1);
    &#125;

public:
    int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) &#123;
        r &#x3D; grid.size();
        if (!r) return 0;
        c &#x3D; grid[0].size();

        int num &#x3D; 0;
        for (int i &#x3D; 0; i &lt; r; ++i) &#123;
            for (int j &#x3D; 0; j &lt; c; ++j) &#123;
                if (grid[i][j] &#x3D;&#x3D; &#39;1&#39;) &#123;
                    ++num;
                    dfs(grid, i, j);
                &#125;
            &#125;
        &#125;

        return num;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="130-被围绕的区域"><a href="#130-被围绕的区域" class="headerlink" title="130. 被围绕的区域"></a>130. 被围绕的区域</h3><p>问题地址：<a href="https://leetcode.cn/problems/surrounded-regions/">https://leetcode.cn/problems/surrounded-regions/</a></p>
<p>给你一个 m x n 的矩阵 board ，由若干字符 ‘X’ 和 ‘O’ ，找到所有被 ‘X’ 围绕的区域，并将这些区域里所有的 ‘O’ 用 ‘X’ 填充。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int n, m;

    void dfs(vector&lt;vector&lt;char&gt;&gt;&amp; board, int x, int y) &#123;
        if (x &lt; 0 || x &gt;&#x3D; n || y &lt; 0 || y &gt;&#x3D; m || board[x][y] !&#x3D; &#39;O&#39;) &#123;
            return;
        &#125;
        board[x][y] &#x3D; &#39;A&#39;;
        dfs(board, x + 1, y);
        dfs(board, x - 1, y);
        dfs(board, x, y + 1);
        dfs(board, x, y - 1);
    &#125;

    void solve(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123;
        n &#x3D; board.size();
        if (n &#x3D;&#x3D; 0) &#123;
            return;
        &#125;
        m &#x3D; board[0].size();
        for (int i &#x3D; 0; i &lt; n; i++) &#123;
            dfs(board, i, 0);
            dfs(board, i, m - 1);
        &#125;
        for (int i &#x3D; 1; i &lt; m - 1; i++) &#123;
            dfs(board, 0, i);
            dfs(board, n - 1, i);
        &#125;
        for (int i &#x3D; 0; i &lt; n; i++) &#123;
            for (int j &#x3D; 0; j &lt; m; j++) &#123;
                if (board[i][j] &#x3D;&#x3D; &#39;A&#39;) &#123;
                    board[i][j] &#x3D; &#39;O&#39;;
                &#125; else if (board[i][j] &#x3D;&#x3D; &#39;O&#39;) &#123;
                    board[i][j] &#x3D; &#39;X&#39;;
                &#125;
            &#125;
        &#125;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="133-克隆图"><a href="#133-克隆图" class="headerlink" title="133. 克隆图"></a>133. 克隆图</h3><p>问题地址：<a href="https://leetcode.cn/problems/clone-graph/">https://leetcode.cn/problems/clone-graph/</a></p>
<p>给你无向 连通 图中一个节点的引用，请你返回该图的 深拷贝（克隆）。</p>
<p>图中的每个节点都包含它的值 val（int） 和其邻居的列表（list[Node]）。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Node &#123;
    public int val;
    public List&lt;Node&gt; neighbors;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;*
&#x2F;&#x2F; Definition for a Node.
class Node &#123;
public:
    int val;
    vector&lt;Node*&gt; neighbors;
    Node() &#123;
        val &#x3D; 0;
        neighbors &#x3D; vector&lt;Node*&gt;();
    &#125;
    Node(int _val) &#123;
        val &#x3D; _val;
        neighbors &#x3D; vector&lt;Node*&gt;();
    &#125;
    Node(int _val, vector&lt;Node*&gt; _neighbors) &#123;
        val &#x3D; _val;
        neighbors &#x3D; _neighbors;
    &#125;
&#125;;
*&#x2F;

class Solution &#123;
private:
    unordered_map&lt;Node*, Node*&gt; visited;
public:
    Node* cloneGraph(Node* node) &#123;
        if (node &#x3D;&#x3D; nullptr) &#123;
            return node;
        &#125;
        if (visited.find(node) !&#x3D; visited.end()) &#123;
            return visited[node];
        &#125;
        Node* clone &#x3D; new Node(node-&gt;val);
        visited[node] &#x3D; clone;
        for (auto&amp; neighbor : node-&gt;neighbors) &#123;
            clone-&gt;neighbors.emplace_back(cloneGraph(neighbor));
        &#125;
        return clone;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="148-排序链表"><a href="#148-排序链表" class="headerlink" title="148. 排序链表"></a>148. 排序链表</h3><p>问题地址：<a href="https://leetcode.cn/problems/sort-list/">https://leetcode.cn/problems/sort-list/</a></p>
<p>给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;**
 * Definition for singly-linked list.
 * struct ListNode &#123;
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) &#123;&#125;
 *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;
 *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;
 * &#125;;
 *&#x2F;
class Solution &#123;
public:
    ListNode* sortList(ListNode* head) &#123;
        return sortList(head, nullptr);
    &#125;
    ListNode* sortList(ListNode* head, ListNode* tail) &#123;
        if (head &#x3D;&#x3D; nullptr) &#123;
            return head;
        &#125;
        if (head-&gt;next &#x3D;&#x3D; tail) &#123;
            head-&gt;next &#x3D; nullptr;
            return head;
        &#125;
        ListNode* slow &#x3D; head, *fast &#x3D; head;
        while (fast !&#x3D; tail) &#123;
            slow &#x3D; slow-&gt;next;
            fast &#x3D; fast-&gt;next;
            if (fast !&#x3D; tail) &#123;
                fast &#x3D; fast-&gt;next;
            &#125;
        &#125;
        ListNode* mid &#x3D; slow;
        return merge(sortList(head, mid), sortList(mid, tail));
    &#125;
    ListNode* merge(ListNode* head1, ListNode* head2) &#123;
        ListNode* dummyHead &#x3D; new ListNode(0);
        ListNode* temp &#x3D; dummyHead, *temp1 &#x3D; head1, *temp2 &#x3D; head2;
        while (temp1 !&#x3D; nullptr &amp;&amp; temp2 !&#x3D; nullptr) &#123;
            if (temp1-&gt;val &lt;&#x3D; temp2-&gt;val) &#123;
                temp-&gt;next &#x3D; temp1;
                temp1 &#x3D; temp1-&gt;next;
            &#125; else &#123;
                temp-&gt;next &#x3D; temp2;
                temp2 &#x3D; temp2-&gt;next;
            &#125;
            temp &#x3D; temp-&gt;next;
        &#125;
        if (temp1 !&#x3D; nullptr) &#123;
            temp-&gt;next &#x3D; temp1;
        &#125; else if (temp2 !&#x3D; nullptr) &#123;
            temp-&gt;next &#x3D; temp2;
        &#125;
        return dummyHead-&gt;next;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="74-搜索二维矩阵"><a href="#74-搜索二维矩阵" class="headerlink" title="74. 搜索二维矩阵"></a>74. 搜索二维矩阵</h3><p>问题地址：<a href="https://leetcode.cn/problems/search-a-2d-matrix/">https://leetcode.cn/problems/search-a-2d-matrix/</a></p>
<p>给你一个满足下述两条属性的 m x n 整数矩阵：</p>
<ul>
<li>每行中的整数从左到右按非严格递增顺序排列。</li>
<li>每行的第一个整数大于前一行的最后一个整数。</li>
</ul>
<p>给你一个整数 target ，如果 target 在矩阵中，返回 true ；否则，返回 false 。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123;
        auto row &#x3D; upper_bound(matrix.begin(), matrix.end(), target, [](const int target, const vector&lt;int&gt; &amp;matrix) &#123;
            return target &lt; matrix[0];
        &#125;);
        if (row &#x3D;&#x3D; matrix.begin()) &#123;
            return false;
        &#125;
        --row;
        return binary_search(row-&gt;begin(), row-&gt;end(), target);
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="162-寻找峰值"><a href="#162-寻找峰值" class="headerlink" title="162. 寻找峰值"></a>162. 寻找峰值</h3><p>问题地址：<a href="https://leetcode.cn/problems/find-peak-element/">https://leetcode.cn/problems/find-peak-element/</a></p>
<p>峰值元素是指其值严格大于左右相邻值的元素。</p>
<p>给你一个整数数组 nums，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 任何一个峰值 所在位置即可。</p>
<p>你可以假设 nums[-1] &#x3D; nums[n] &#x3D; -∞ 。</p>
<p>你必须实现时间复杂度为 O(log n) 的算法来解决此问题。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int findPeakElement(vector&lt;int&gt;&amp; nums) &#123;
        return max_element(nums.begin(), nums.end()) - nums.begin();
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="399-除法求值"><a href="#399-除法求值" class="headerlink" title="399. 除法求值"></a>399. 除法求值</h3><p>问题地址：<a href="https://leetcode.cn/problems/evaluate-division/">https://leetcode.cn/problems/evaluate-division/</a></p>
<p>给你一个变量对数组 equations 和一个实数值数组 values 作为已知条件，其中 equations[i] &#x3D; [Ai, Bi] 和 values[i] 共同表示等式 Ai &#x2F; Bi &#x3D; values[i] 。每个 Ai 或 Bi 是一个表示单个变量的字符串。</p>
<p>另有一些以数组 queries 表示的问题，其中 queries[j] &#x3D; [Cj, Dj] 表示第 j 个问题，请你根据已知条件找出 Cj &#x2F; Dj &#x3D; ? 的结果作为答案。</p>
<p>返回 所有问题的答案 。如果存在某个无法确定的答案，则用 -1.0 替代这个答案。如果问题中出现了给定的已知条件中没有出现的字符串，也需要用 -1.0 替代这个答案。</p>
<p>注意：输入总是有效的。你可以假设除法运算中不会出现除数为 0 的情况，且不存在任何矛盾的结果。</p>
<p>注意：未在等式列表中出现的变量是未定义的，因此无法确定它们的答案。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    vector&lt;double&gt; calcEquation(vector&lt;vector&lt;string&gt;&gt;&amp; equations, vector&lt;double&gt;&amp; values, vector&lt;vector&lt;string&gt;&gt;&amp; queries) &#123;
        int nvars &#x3D; 0;
        unordered_map&lt;string, int&gt; variables;

        int n &#x3D; equations.size();
        for (int i &#x3D; 0; i &lt; n; i++) &#123;
            if (variables.find(equations[i][0]) &#x3D;&#x3D; variables.end()) &#123;
                variables[equations[i][0]] &#x3D; nvars++;
            &#125;
            if (variables.find(equations[i][1]) &#x3D;&#x3D; variables.end()) &#123;
                variables[equations[i][1]] &#x3D; nvars++;
            &#125;
        &#125;

        &#x2F;&#x2F; 对于每个点，存储其直接连接到的所有点及对应的权值
        vector&lt;vector&lt;pair&lt;int, double&gt;&gt;&gt; edges(nvars);
        for (int i &#x3D; 0; i &lt; n; i++) &#123;
            int va &#x3D; variables[equations[i][0]], vb &#x3D; variables[equations[i][1]];
            edges[va].push_back(make_pair(vb, values[i]));
            edges[vb].push_back(make_pair(va, 1.0 &#x2F; values[i]));
        &#125;

        vector&lt;double&gt; ret;
        for (const auto&amp; q: queries) &#123;
            double result &#x3D; -1.0;
            if (variables.find(q[0]) !&#x3D; variables.end() &amp;&amp; variables.find(q[1]) !&#x3D; variables.end()) &#123;
                int ia &#x3D; variables[q[0]], ib &#x3D; variables[q[1]];
                if (ia &#x3D;&#x3D; ib) &#123;
                    result &#x3D; 1.0;
                &#125; else &#123;
                    queue&lt;int&gt; points;
                    points.push(ia);
                    vector&lt;double&gt; ratios(nvars, -1.0);
                    ratios[ia] &#x3D; 1.0;

                    while (!points.empty() &amp;&amp; ratios[ib] &lt; 0) &#123;
                        int x &#x3D; points.front();
                        points.pop();

                        for (const auto [y, val]: edges[x]) &#123;
                            if (ratios[y] &lt; 0) &#123;
                                ratios[y] &#x3D; ratios[x] * val;
                                points.push(y);
                            &#125;
                        &#125;
                    &#125;
                    result &#x3D; ratios[ib];
                &#125;
            &#125;
            ret.push_back(result);
        &#125;
        return ret;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="207-课程表"><a href="#207-课程表" class="headerlink" title="207. 课程表"></a>207. 课程表</h3><p>问题地址：<a href="https://leetcode.cn/problems/course-schedule/">https://leetcode.cn/problems/course-schedule/</a></p>
<p>你这个学期必须选修 numCourses 门课程，记为 0 到 numCourses - 1 。</p>
<p>在选修某些课程之前需要一些先修课程。 先修课程按数组 prerequisites 给出，其中 prerequisites[i] &#x3D; [ai, bi] ，表示如果要学习课程 ai 则 必须 先学习课程  bi 。</p>
<ul>
<li>例如，先修课程对 [0, 1] 表示：想要学习课程 0 ，你需要先完成课程 1 。</li>
</ul>
<p>请你判断是否可能完成所有课程的学习？如果可以，返回 true ；否则，返回 false 。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
private:
    vector&lt;vector&lt;int&gt;&gt; edges;
    vector&lt;int&gt; visited;
    bool valid &#x3D; true;
public:
    bool canFinish(int numCourses, vector&lt;vector&lt;int&gt;&gt;&amp; prerequisites) &#123;
        edges.resize(numCourses);
        visited.resize(numCourses);
        for (const auto&amp; info : prerequisites) &#123;
            edges[info[1]].push_back(info[0]);
        &#125;
        for (int i&#x3D;0; i &lt; numCourses &amp;&amp; valid; ++i) &#123;
            if (!visited[i]) &#123;
                dfs(i);
            &#125;
        &#125;
        return valid;
    &#125;
    void dfs(int u) &#123;
        visited[u] &#x3D; 1;
        for (int v : edges[u]) &#123;
            if (visited[v] &#x3D;&#x3D; 0) &#123;
                dfs(v);
                if (!valid) &#123;
                    return;
                &#125;
            &#125; else if (visited[v] &#x3D;&#x3D; 1) &#123;
                valid &#x3D; false;
                return;
            &#125;
        &#125;
        visited[u] &#x3D; 2;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="210-课程表-II"><a href="#210-课程表-II" class="headerlink" title="210. 课程表 II"></a>210. 课程表 II</h3><p>问题地址：<a href="https://leetcode.cn/problems/course-schedule-ii/">https://leetcode.cn/problems/course-schedule-ii/</a></p>
<p>现在你总共有 numCourses 门课需要选，记为 0 到 numCourses - 1。给你一个数组 prerequisites ，其中 prerequisites[i] &#x3D; [ai, bi] ，表示在选修课程 ai 前 必须 先选修 bi 。</p>
<ul>
<li>例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示：[0,1] 。</li>
</ul>
<p>返回你为了学完所有课程所安排的学习顺序。可能会有多个正确的顺序，你只要返回 任意一种 就可以了。如果不可能完成所有课程，返回 一个空数组 。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
private:
    vector&lt;vector&lt;int&gt;&gt; edges;
    vector&lt;int&gt; visited;
    vector&lt;int&gt; result;
    bool valid &#x3D; true;
public:
    vector&lt;int&gt; findOrder(int numCourses, vector&lt;vector&lt;int&gt;&gt;&amp; prerequisites) &#123;
        edges.resize(numCourses);
        visited.resize(numCourses);
        for (const auto&amp; info : prerequisites) &#123;
            edges[info[1]].push_back(info[0]);
        &#125;
        for (int i &#x3D; 0; i &lt; numCourses &amp;&amp; valid; ++i) &#123;
            if (!visited[i]) &#123;
                dfs(i);
            &#125;
        &#125;
        if (!valid) &#123;
            return &#123;&#125;;
        &#125;
        reverse(result.begin(), result.end());
        return result;
    &#125;
    void dfs(int u) &#123;
        visited[u] &#x3D; 1;
        for (int v : edges[u]) &#123;
            if (visited[v] &#x3D;&#x3D; 0) &#123;
                dfs(v);
                if (!valid) &#123;
                    return;
                &#125;
            &#125; else if (visited[v] &#x3D;&#x3D; 1) &#123;
                valid &#x3D; false;
                return;
            &#125;
        &#125;
        visited[u] &#x3D; 2;
        result.push_back(u);
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="77-组合"><a href="#77-组合" class="headerlink" title="77. 组合"></a>77. 组合</h3><p>问题地址：<a href="https://leetcode.cn/problems/combinations/">https://leetcode.cn/problems/combinations/</a></p>
<p>给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。</p>
<p>你可以按 任何顺序 返回答案。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) &#123;
        vector&lt;vector&lt;int&gt;&gt; ans;
        vector&lt;int&gt; path;
        function&lt;void(int)&gt; dfs &#x3D; [&amp;](int i) &#123;
            int d &#x3D; k - path.size();
            if (d &#x3D;&#x3D; 0) &#123;
                ans.emplace_back(path);
                return;
            &#125;
            for (int j &#x3D; i; j &gt;&#x3D; d; --j) &#123;
                path.push_back(j);
                dfs(j-1);
                path.pop_back();
            &#125;
        &#125;;
        dfs(n);
        return ans;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="373-查找和最小的-K-对数字"><a href="#373-查找和最小的-K-对数字" class="headerlink" title="373. 查找和最小的 K 对数字"></a>373. 查找和最小的 K 对数字</h3><p>问题地址：<a href="https://leetcode.cn/problems/find-k-pairs-with-smallest-sums/">https://leetcode.cn/problems/find-k-pairs-with-smallest-sums/</a></p>
<p>给定两个以 非递减顺序排列 的整数数组 nums1 和 nums2 , 以及一个整数 k 。</p>
<p>定义一对值 (u,v)，其中第一个元素来自 nums1，第二个元素来自 nums2 。</p>
<p>请找到和最小的 k 个数对 (u1,v1),  (u2,v2)  …  (uk,vk) 。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    vector&lt;vector&lt;int&gt;&gt; kSmallestPairs(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2, int k) &#123;
        auto cmp &#x3D; [&amp;nums1, &amp;nums2](const pair&lt;int, int&gt; &amp; a, const pair&lt;int, int&gt; &amp; b) &#123;
            return nums1[a.first] + nums2[a.second] &gt; nums1[b.first] + nums2[b.second];
        &#125;;

        int m &#x3D; nums1.size();
        int n &#x3D; nums2.size();
        vector&lt;vector&lt;int&gt;&gt; ans;   
        priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, decltype(cmp)&gt; pq(cmp);
        for (int i &#x3D; 0; i &lt; min(k, m); i++) &#123;
            pq.emplace(i, 0);
        &#125;
        while (k-- &gt; 0 &amp;&amp; !pq.empty()) &#123;
            auto [x, y] &#x3D; pq.top(); 
            pq.pop();
            ans.emplace_back(initializer_list&lt;int&gt;&#123;nums1[x], nums2[y]&#125;);
            if (y + 1 &lt; n) &#123;
                pq.emplace(x, y + 1);
            &#125;
        &#125;

        return ans;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="909-蛇梯棋"><a href="#909-蛇梯棋" class="headerlink" title="909. 蛇梯棋"></a>909. 蛇梯棋</h3><p>问题地址：<a href="https://leetcode.cn/problems/snakes-and-ladders/">https://leetcode.cn/problems/snakes-and-ladders/</a></p>
<p>给你一个大小为 n x n 的整数矩阵 board ，方格按从 1 到 n2 编号，编号遵循 转行交替方式 ，从左下角开始 （即，从 board[n - 1][0] 开始）每一行交替方向。</p>
<p>玩家从棋盘上的方格 1 （总是在最后一行、第一列）开始出发。</p>
<p>每一回合，玩家需要从当前方格 curr 开始出发，按下述要求前进：</p>
<ul>
<li>选定目标方格 next ，目标方格的编号符合范围 [curr + 1, min(curr + 6, n2)] 。<ul>
<li>该选择模拟了掷 六面体骰子 的情景，无论棋盘大小如何，玩家最多只能有 6 个目的地。</li>
</ul>
</li>
<li>传送玩家：如果目标方格 next 处存在蛇或梯子，那么玩家会传送到蛇或梯子的目的地。否则，玩家传送到目标方格 next 。 </li>
<li>当玩家到达编号 n2 的方格时，游戏结束。</li>
</ul>
<p>r 行 c 列的棋盘，按前述方法编号，棋盘格中可能存在 “蛇” 或 “梯子”；如果 board[r][c] !&#x3D; -1，那个蛇或梯子的目的地将会是 board[r][c]。编号为 1 和 n2 的方格上没有蛇或梯子。</p>
<p>注意，玩家在每回合的前进过程中最多只能爬过蛇或梯子一次：就算目的地是另一条蛇或梯子的起点，玩家也 不能 继续移动。</p>
<ul>
<li>举个例子，假设棋盘是 [[-1,4],[-1,3]] ，第一次移动，玩家的目标方格是 2 。那么这个玩家将会顺着梯子到达方格 3 ，但 不能 顺着方格 3 上的梯子前往方格 4 。</li>
</ul>
<p>返回达到编号为 n2 的方格所需的最少移动次数，如果不可能，则返回 -1。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int snakesAndLadders(vector&lt;vector&lt;int&gt;&gt;&amp; board) &#123;
        int n &#x3D; board.size();
        vector&lt;int&gt; vis(n*n+1);
        queue&lt;pair&lt;int,int&gt;&gt; q;
        q.emplace(1,0);
        while (!q.empty()) &#123;
            auto p &#x3D; q.front();
            q.pop();
            for (int i&#x3D;1; i&lt;&#x3D;6; ++i) &#123;
                int nxt &#x3D; p.first + i;
                if (nxt &gt; n*n) &#123;
                    break;
                &#125;
                auto rc &#x3D; id2rc(nxt, n);
                if (board[rc.first][rc.second] &gt; 0) &#123;
                    nxt &#x3D; board[rc.first][rc.second];
                &#125;
                if (nxt &#x3D;&#x3D; n*n) &#123;
                    return p.second + 1;
                &#125;
                if (!vis[nxt]) &#123;
                    vis[nxt] &#x3D; true;
                    q.emplace(nxt, p.second + 1);
                &#125;
            &#125;
        &#125;
        return -1;
    &#125;
    pair&lt;int, int&gt; id2rc(int id, int n) &#123;
        int r &#x3D; (id - 1) &#x2F; n, c &#x3D; (id - 1) % n;
        if (r % 2 &#x3D;&#x3D; 1) &#123;
            c &#x3D; n - 1 - c;
        &#125;
        return &#123;n - 1 - r, c&#125;;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="433-最小基因变化"><a href="#433-最小基因变化" class="headerlink" title="433. 最小基因变化"></a>433. 最小基因变化</h3><p>问题地址：<a href="https://leetcode.cn/problems/minimum-genetic-mutation/">https://leetcode.cn/problems/minimum-genetic-mutation/</a></p>
<p>基因序列可以表示为一条由 8 个字符组成的字符串，其中每个字符都是 ‘A’、’C’、’G’ 和 ‘T’ 之一。</p>
<p>假设我们需要调查从基因序列 start 变为 end 所发生的基因变化。一次基因变化就意味着这个基因序列中的一个字符发生了变化。</p>
<ul>
<li>例如，”AACCGGTT” –&gt; “AACCGGTA” 就是一次基因变化。</li>
</ul>
<p>另有一个基因库 bank 记录了所有有效的基因变化，只有基因库中的基因才是有效的基因序列。（变化后的基因必须位于基因库 bank 中）</p>
<p>给你两个基因序列 start 和 end ，以及一个基因库 bank ，请你找出并返回能够使 start 变化为 end 所需的最少变化次数。如果无法完成此基因变化，返回 -1 。</p>
<p>注意：起始基因序列 start 默认是有效的，但是它并不一定会出现在基因库中。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int minMutation(string start, string end, vector&lt;string&gt;&amp; bank) &#123;
        unordered_set&lt;string&gt; cnt;
        unordered_set&lt;string&gt; visited;
        char keys[4] &#x3D; &#123;&#39;A&#39;, &#39;C&#39;, &#39;G&#39;, &#39;T&#39;&#125;;
        for (auto&amp; w : bank) &#123;
            cnt.emplace(w);
        &#125;
        if (start &#x3D;&#x3D; end) &#123;
            return 0;
        &#125;
        if (!cnt.count(end)) &#123;
            return -1;
        &#125;
        queue&lt;string&gt; qu;
        qu.emplace(start);
        visited.emplace(start);
        int step &#x3D; 1;
        while (!qu.empty()) &#123;
            int sz &#x3D; qu.size();
            for (int i&#x3D;0; i&lt;sz; i++) &#123;
                string curr &#x3D; qu.front();
                qu.pop();
                for (int j&#x3D;0; j&lt;8; j++) &#123;
                    for (int k&#x3D;0; k&lt;4; k++) &#123;
                        if (keys[k] !&#x3D; curr[j]) &#123;
                            string next &#x3D; curr;
                            next[j] &#x3D; keys[k];
                            if (!visited.count(next) &amp;&amp; cnt.count(next)) &#123;
                                if (next &#x3D;&#x3D; end) &#123;
                                    return step;
                                &#125;
                                qu.emplace(next);
                                visited.emplace(next);
                            &#125;
                        &#125;
                    &#125;
                &#125;
            &#125;
            step++;
        &#125;
        return -1;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="208-实现-Trie-前缀树"><a href="#208-实现-Trie-前缀树" class="headerlink" title="208. 实现 Trie (前缀树)"></a>208. 实现 Trie (前缀树)</h3><p>问题地址：<a href="https://leetcode.cn/problems/implement-trie-prefix-tree/">https://leetcode.cn/problems/implement-trie-prefix-tree/</a></p>
<p>Trie（发音类似 “try”）或者说 前缀树 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。</p>
<p>请你实现 Trie 类：</p>
<ul>
<li>Trie() 初始化前缀树对象。</li>
<li>void insert(String word) 向前缀树中插入字符串 word 。</li>
<li>boolean search(String word) 如果字符串 word 在前缀树中，返回 true（即，在检索之前已经插入）；否则，返回 false 。</li>
<li>boolean startsWith(String prefix) 如果之前已经插入的字符串 word 的前缀之一为 prefix ，返回 true ；否则，返回 false 。</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Trie &#123;
private:
    vector&lt;Trie*&gt; children;
    bool isEnd;

    Trie* searchPrefix(string prefix) &#123;
        Trie* node &#x3D; this;
        for (char ch : prefix) &#123;
            ch -&#x3D; &#39;a&#39;;
            if (node-&gt;children[ch] &#x3D;&#x3D; nullptr) &#123;
                return nullptr;
            &#125;
            node &#x3D; node-&gt;children[ch];
        &#125;
        return node;
    &#125;
public:
    Trie() : children(26), isEnd(false) &#123;&#125;
    
    void insert(string word) &#123;
        Trie* node &#x3D; this;
        for (char ch : word) &#123;
            ch -&#x3D; &#39;a&#39;;
            if (node-&gt;children[ch] &#x3D;&#x3D; nullptr) &#123;
                node-&gt;children[ch] &#x3D; new Trie();
            &#125;
            node &#x3D; node-&gt;children[ch];
        &#125;
        node-&gt;isEnd &#x3D; true;
    &#125;
    
    bool search(string word) &#123;
        Trie* node &#x3D; this-&gt;searchPrefix(word);
        return node !&#x3D; nullptr &amp;&amp; node-&gt;isEnd;
    &#125;
    
    bool startsWith(string prefix) &#123;
        return this-&gt;searchPrefix(prefix) !&#x3D; nullptr;
    &#125;
&#125;;

&#x2F;**
 * Your Trie object will be instantiated and called as such:
 * Trie* obj &#x3D; new Trie();
 * obj-&gt;insert(word);
 * bool param_2 &#x3D; obj-&gt;search(word);
 * bool param_3 &#x3D; obj-&gt;startsWith(prefix);
 *&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="211-添加与搜索单词-数据结构设计"><a href="#211-添加与搜索单词-数据结构设计" class="headerlink" title="211. 添加与搜索单词 - 数据结构设计"></a>211. 添加与搜索单词 - 数据结构设计</h3><p>问题地址：<a href="https://leetcode.cn/problems/design-add-and-search-words-data-structure/">https://leetcode.cn/problems/design-add-and-search-words-data-structure/</a></p>
<p>请你设计一个数据结构，支持 添加新单词 和 查找字符串是否与任何先前添加的字符串匹配 。</p>
<p>实现词典类 WordDictionary ：</p>
<ul>
<li>WordDictionary() 初始化词典对象</li>
<li>void addWord(word) 将 word 添加到数据结构中，之后可以对它进行匹配</li>
<li>bool search(word) 如果数据结构中存在字符串与 word 匹配，则返回 true ；否则，返回  false 。word 中可能包含一些 ‘.’ ，每个 . 都可以表示任何一个字母。</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct TrieNode &#123;
    vector&lt;TrieNode *&gt; child;
    bool isEnd;
    TrieNode() &#123;
        this-&gt;child &#x3D; vector&lt;TrieNode *&gt;(26, nullptr);
        this-&gt;isEnd &#x3D; false;
    &#125;
&#125;;
void insert(TrieNode* root, const string&amp; word) &#123;
    TrieNode* node &#x3D; root;
    for (auto c : word) &#123;
        if (node-&gt;child[c - &#39;a&#39;] &#x3D;&#x3D; nullptr) &#123;
            node-&gt;child[c - &#39;a&#39;] &#x3D; new TrieNode();
        &#125;
        node &#x3D; node-&gt;child[c - &#39;a&#39;];
    &#125;
    node-&gt;isEnd &#x3D; true;
&#125;
class WordDictionary &#123;
private:
    TrieNode* trie;
public:
    WordDictionary() &#123;
        trie &#x3D; new TrieNode();
    &#125;
    
    void addWord(string word) &#123;
        insert(trie, word);
    &#125;
    
    bool search(string word) &#123;
        return dfs(word, 0, trie);
    &#125;

    bool dfs(const string&amp; word, int index, TrieNode* node) &#123;
        if (index &#x3D;&#x3D; word.size()) &#123;
            return node-&gt;isEnd;
        &#125;
        char ch &#x3D; word[index];
        if (ch &gt;&#x3D; &#39;a&#39; &amp;&amp; ch &lt;&#x3D; &#39;z&#39;) &#123;
            TrieNode* child &#x3D; node-&gt;child[ch - &#39;a&#39;];
            if (child !&#x3D; nullptr &amp;&amp; dfs(word, index+1, child)) &#123;
                return true;
            &#125;
        &#125; else if (ch &#x3D;&#x3D; &#39;.&#39;) &#123;
            for (int i&#x3D;0; i&lt;26; i++) &#123;
                TrieNode* child &#x3D; node-&gt;child[i];
                if (child !&#x3D; nullptr &amp;&amp; dfs(word, index+1, child)) &#123;
                    return true;
                &#125;
            &#125;
        &#125;
        return false;
    &#125;
&#125;;

&#x2F;**
 * Your WordDictionary object will be instantiated and called as such:
 * WordDictionary* obj &#x3D; new WordDictionary();
 * obj-&gt;addWord(word);
 * bool param_2 &#x3D; obj-&gt;search(word);
 *&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a>46. 全排列</h3><p>问题地址：<a href="https://leetcode.cn/problems/permutations/">https://leetcode.cn/problems/permutations/</a></p>
<p>给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123;
        vector&lt;vector&lt;int&gt;&gt; res;
        backtrack(res, nums, 0, nums.size());
        return res;
    &#125;
    void backtrack(vector&lt;vector&lt;int&gt;&gt;&amp; res, vector&lt;int&gt;&amp; output, int first, int len) &#123;
        if (first &#x3D;&#x3D; len) &#123;
            res.emplace_back(output);
            return;
        &#125;
        for (int i&#x3D;first; i&lt;len; ++i) &#123;
            swap(output[i], output[first]);
            backtrack(res, output, first+1, len);
            swap(output[i], output[first]);
        &#125;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39. 组合总和"></a>39. 组合总和</h3><p>问题地址：<a href="https://leetcode.cn/problems/combination-sum/">https://leetcode.cn/problems/combination-sum/</a></p>
<p>给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。</p>
<p>candidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。 </p>
<p>对于给定的输入，保证和为 target 的不同组合数少于 150 个。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) &#123;
        vector&lt;vector&lt;int&gt;&gt; ans;
        vector&lt;int&gt; combine;
        dfs(candidates, target, ans, combine, 0);
        return ans;   
    &#125;
    void dfs(vector&lt;int&gt;&amp; candidates, int target, vector&lt;vector&lt;int&gt;&gt;&amp; ans,
        vector&lt;int&gt;&amp; combine, int idx) &#123;
        if (idx &#x3D;&#x3D; candidates.size()) &#123;
            return;
        &#125;
        if (target &#x3D;&#x3D; 0) &#123;
            ans.emplace_back(combine);
            return;
        &#125;
        dfs(candidates, target, ans, combine, idx+1);
        if (target - candidates[idx] &gt;&#x3D; 0) &#123;
            combine.emplace_back(candidates[idx]);
            dfs(candidates, target-candidates[idx], ans, combine, idx);
            combine.pop_back();
        &#125;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="79-单词搜索"><a href="#79-单词搜索" class="headerlink" title="79. 单词搜索"></a>79. 单词搜索</h3><p>问题地址：<a href="https://leetcode.cn/problems/word-search/">https://leetcode.cn/problems/word-search/</a></p>
<p>给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。</p>
<p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
private:
    int rows, cols;
    bool dfs(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word, int i, int j, int k) &#123;
        if (i &gt;&#x3D; rows || i &lt; 0 || j &gt;&#x3D; cols || j &lt; 0 || board[i][j] !&#x3D; word[k]) return false;
        if (k &#x3D;&#x3D; word.size() - 1) return true;
        board[i][j] &#x3D; &#39;\0&#39;;
        bool res &#x3D; dfs(board, word, i+1, j, k+1) || dfs(board, word, i-1, j, k+1) ||
            dfs(board, word, i, j+1, k+1) || dfs(board, word, i, j-1, k+1);
        board[i][j] &#x3D; word[k];
        return res;
    &#125;
public:
    bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) &#123;
        rows &#x3D; board.size();
        cols &#x3D; board[0].size();
        for (int i &#x3D; 0; i &lt; rows; i++) &#123;
            for (int j &#x3D; 0; j &lt; cols; j++) &#123;
                if (dfs(board, word, i, j, 0)) return true;
            &#125;
        &#125;
        return false;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="427-建立四叉树"><a href="#427-建立四叉树" class="headerlink" title="427. 建立四叉树"></a>427. 建立四叉树</h3><p>问题地址：<a href="https://leetcode.cn/problems/construct-quad-tree/">https://leetcode.cn/problems/construct-quad-tree/</a></p>
<p>给你一个 n * n 矩阵 grid ，矩阵由若干 0 和 1 组成。请你用四叉树表示该矩阵 grid 。</p>
<p>你需要返回能表示矩阵 grid 的 四叉树 的根结点。</p>
<p>四叉树数据结构中，每个内部节点只有四个子节点。此外，每个节点都有两个属性：</p>
<ul>
<li>val：储存叶子结点所代表的区域的值。1 对应 True，0 对应 False。注意，当 isLeaf 为 False 时，你可以把 True 或者 False 赋值给节点，两种值都会被判题机制 接受 。</li>
<li>isLeaf: 当这个节点是一个叶子结点时为 True，如果它有 4 个子节点则为 False 。</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Node &#123;
    public boolean val;
    public boolean isLeaf;
    public Node topLeft;
    public Node topRight;
    public Node bottomLeft;
    public Node bottomRight;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>我们可以按以下步骤为二维区域构建四叉树：</p>
<ol>
<li>如果当前网格的值相同（即，全为 0 或者全为 1），将 isLeaf 设为 True ，将 val 设为网格相应的值，并将四个子节点都设为 Null 然后停止。</li>
<li>如果当前网格的值不同，将 isLeaf 设为 False， 将 val 设为任意值，然后如下图所示，将当前网格划分为四个子网格。</li>
<li>使用适当的子网格递归每个子节点。</li>
</ol>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;*
&#x2F;&#x2F; Definition for a QuadTree node.
class Node &#123;
public:
    bool val;
    bool isLeaf;
    Node* topLeft;
    Node* topRight;
    Node* bottomLeft;
    Node* bottomRight;
    
    Node() &#123;
        val &#x3D; false;
        isLeaf &#x3D; false;
        topLeft &#x3D; NULL;
        topRight &#x3D; NULL;
        bottomLeft &#x3D; NULL;
        bottomRight &#x3D; NULL;
    &#125;
    
    Node(bool _val, bool _isLeaf) &#123;
        val &#x3D; _val;
        isLeaf &#x3D; _isLeaf;
        topLeft &#x3D; NULL;
        topRight &#x3D; NULL;
        bottomLeft &#x3D; NULL;
        bottomRight &#x3D; NULL;
    &#125;
    
    Node(bool _val, bool _isLeaf, Node* _topLeft, Node* _topRight, Node* _bottomLeft, Node* _bottomRight) &#123;
        val &#x3D; _val;
        isLeaf &#x3D; _isLeaf;
        topLeft &#x3D; _topLeft;
        topRight &#x3D; _topRight;
        bottomLeft &#x3D; _bottomLeft;
        bottomRight &#x3D; _bottomRight;
    &#125;
&#125;;
*&#x2F;

class Solution &#123;
public:
    Node* construct(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;
        function&lt;Node*(int, int, int, int)&gt; dfs &#x3D; [&amp;](int r0, int c0, int r1, int c1) &#123;
            for (int i&#x3D;r0; i&lt;r1; ++i) &#123;
                for (int j&#x3D;c0; j&lt;c1; ++j) &#123;
                    if (grid[i][j] !&#x3D; grid[r0][c0]) &#123;
                        return new Node(
                            true,
                            false,
                            dfs(r0, c0, (r0+r1)&#x2F;2, (c0+c1)&#x2F;2),
                            dfs(r0, (c0+c1)&#x2F;2, (r0+r1)&#x2F;2, c1),
                            dfs((r0+r1)&#x2F;2, c0, r1, (c0+c1)&#x2F;2),
                            dfs((r0+r1)&#x2F;2, (c0+c1)&#x2F;2, r1, c1)
                        );
                    &#125;
                &#125;
            &#125;
            return new Node(grid[r0][c0], true);
        &#125;;
        return dfs(0,0,grid.size(),grid[0].size());
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="918-环形子数组的最大和"><a href="#918-环形子数组的最大和" class="headerlink" title="918. 环形子数组的最大和"></a>918. 环形子数组的最大和</h3><p>问题地址：<a href="https://leetcode.cn/problems/maximum-sum-circular-subarray/">https://leetcode.cn/problems/maximum-sum-circular-subarray/</a></p>
<p>给定一个长度为 n 的环形整数数组 nums ，返回 nums 的非空 子数组 的最大可能和 。</p>
<p>环形数组 意味着数组的末端将会与开头相连呈环状。形式上， nums[i] 的下一个元素是 nums[(i + 1) % n] ， nums[i] 的前一个元素是 nums[(i - 1 + n) % n] 。</p>
<p>子数组 最多只能包含固定缓冲区 nums 中的每个元素一次。形式上，对于子数组 nums[i], nums[i + 1], …, nums[j] ，不存在 i &lt;&#x3D; k1, k2 &lt;&#x3D; j 其中 k1 % n &#x3D;&#x3D; k2 % n 。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int maxSubarraySumCircular(vector&lt;int&gt;&amp; nums) &#123;
        int n &#x3D; nums.size();
        int preMax &#x3D; nums[0], maxRes &#x3D; nums[0];
        int preMin &#x3D; nums[0], minRes &#x3D; nums[0];
        int sum &#x3D; nums[0];
        for (int i &#x3D; 1; i &lt; n; i++) &#123;
            preMax &#x3D; max(preMax + nums[i], nums[i]);
            maxRes &#x3D; max(maxRes, preMax);
            preMin &#x3D; min(preMin + nums[i], nums[i]);
            minRes &#x3D; min(minRes, preMin);
            sum +&#x3D; nums[i];
        &#125;
        if (maxRes &lt; 0) &#123;
            return maxRes;
        &#125; else &#123;
            return max(maxRes, sum - minRes);
        &#125;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="153-寻找旋转排序数组中的最小值"><a href="#153-寻找旋转排序数组中的最小值" class="headerlink" title="153. 寻找旋转排序数组中的最小值"></a>153. 寻找旋转排序数组中的最小值</h3><p>问题地址：<a href="https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/">https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/</a></p>
<p>已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums &#x3D; [0,1,2,4,5,6,7] 在变化后可能得到：</p>
<ul>
<li>若旋转 4 次，则可以得到 [4,5,6,7,0,1,2]</li>
<li>若旋转 7 次，则可以得到 [0,1,2,4,5,6,7]</li>
</ul>
<p>注意，数组 [a[0], a[1], a[2], …, a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], …, a[n-2]] 。</p>
<p>给你一个元素值 互不相同 的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。</p>
<p>你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int findMin(vector&lt;int&gt;&amp; nums) &#123;
        int low &#x3D; 0;
        int high &#x3D; nums.size() - 1;
        while (low &lt; high) &#123;
            int privot &#x3D; low + (high - low) &#x2F; 2;
            if (nums[privot] &lt; nums[high]) &#123;
                high &#x3D; privot;
            &#125; else &#123;
                low &#x3D; privot + 1;
            &#125;
        &#125;
        return nums[low];
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="137-只出现一次的数字-II"><a href="#137-只出现一次的数字-II" class="headerlink" title="137. 只出现一次的数字 II"></a>137. 只出现一次的数字 II</h3><p>问题地址：<a href="https://leetcode.cn/problems/single-number-ii/">https://leetcode.cn/problems/single-number-ii/</a></p>
<p>给你一个整数数组 nums ，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次 。请你找出并返回那个只出现了一次的元素。</p>
<p>你必须设计并实现线性时间复杂度的算法且使用常数级空间来解决此问题。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int singleNumber(vector&lt;int&gt;&amp; nums) &#123;
        unordered_map&lt;int, int&gt; freq;
        for(int num : nums) &#123;
            ++freq[num];
        &#125;
        int ans &#x3D; 0;
        for (auto [num, occ] : freq) &#123;
            if (occ &#x3D;&#x3D; 1) &#123;
                ans &#x3D; num;
                break;
            &#125;
        &#125;
        return ans;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="201-数字范围按位与"><a href="#201-数字范围按位与" class="headerlink" title="201. 数字范围按位与"></a>201. 数字范围按位与</h3><p>问题地址：<a href="https://leetcode.cn/problems/bitwise-and-of-numbers-range/">https://leetcode.cn/problems/bitwise-and-of-numbers-range/</a></p>
<p>给你两个整数 left 和 right ，表示区间 [left, right] ，返回此区间内所有数字 按位与 的结果（包含 left 、right 端点）。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int rangeBitwiseAnd(int left, int right) &#123;
        int shift &#x3D; 0;
        while (left &lt; right) &#123;
            left &gt;&gt;&#x3D; 1;
            right &gt;&gt;&#x3D; 1;
            ++shift;
        &#125;
        return left &lt;&lt; shift;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="172-阶乘后的零"><a href="#172-阶乘后的零" class="headerlink" title="172. 阶乘后的零"></a>172. 阶乘后的零</h3><p>问题地址：<a href="https://leetcode.cn/problems/factorial-trailing-zeroes/">https://leetcode.cn/problems/factorial-trailing-zeroes/</a></p>
<p>给定一个整数 n ，返回 n! 结果中尾随零的数量。</p>
<p>提示 n! &#x3D; n * (n - 1) * (n - 2) * … * 3 * 2 * 1</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int trailingZeroes(int n) &#123;
        int ans &#x3D; 0;
        for (int i &#x3D; 5; i &lt;&#x3D; n; i +&#x3D; 5) &#123;
            for (int x &#x3D; i; x % 5 &#x3D;&#x3D; 0; x &#x2F;&#x3D; 5) &#123;
                ++ans;
            &#125;
        &#125;
        return ans;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="322-零钱兑换"><a href="#322-零钱兑换" class="headerlink" title="322. 零钱兑换"></a>322. 零钱兑换</h3><p>问题地址：<a href="https://leetcode.cn/problems/coin-change/">https://leetcode.cn/problems/coin-change/</a></p>
<p>给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。</p>
<p>计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。</p>
<p>你可以认为每种硬币的数量是无限的。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int coinChange(vector&lt;int&gt;&amp; coins, int amount) &#123;
        int Max &#x3D; amount + 1;
        vector&lt;int&gt; dp(amount + 1, Max);
        dp[0] &#x3D; 0;
        for (int i &#x3D; 1; i &lt;&#x3D; amount; ++i) &#123;
            for (int j &#x3D; 0; j &lt; coins.size(); ++j) &#123;
                if (coins[j] &lt;&#x3D; i) &#123;
                    dp[i] &#x3D; min(dp[i], dp[i - coins[j]] + 1);
                &#125;
            &#125;
        &#125;
        return dp[amount] &gt; amount ? -1 : dp[amount];
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="300-最长递增子序列"><a href="#300-最长递增子序列" class="headerlink" title="300. 最长递增子序列"></a>300. 最长递增子序列</h3><p>问题地址：<a href="https://leetcode.cn/problems/longest-increasing-subsequence/">https://leetcode.cn/problems/longest-increasing-subsequence/</a></p>
<p>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</p>
<p>子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123;
        int n &#x3D; nums.size();
        if (n &#x3D;&#x3D; 0) return 0;
        vector&lt;int&gt; dp(n, 0);
        for (int i &#x3D; 0; i &lt; n; ++i) &#123;
            dp[i] &#x3D; 1;
            for (int j &#x3D; 0; j &lt; i; ++j) &#123;
                if (nums[j] &lt; nums[i]) &#123;
                    dp[i] &#x3D; max(dp[i], dp[j] + 1);
                &#125;
            &#125;
        &#125;
        return *max_element(dp.begin(), dp.end());
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="97-交错字符串"><a href="#97-交错字符串" class="headerlink" title="97. 交错字符串"></a>97. 交错字符串</h3><p>问题地址：<a href="https://leetcode.cn/problems/interleaving-string/">https://leetcode.cn/problems/interleaving-string/</a></p>
<p>给定三个字符串 s1、s2、s3，请你帮忙验证 s3 是否是由 s1 和 s2 交错 组成的。</p>
<p>两个字符串 s 和 t 交错 的定义与过程如下，其中每个字符串都会被分割成若干 非空 子字符串：</p>
<ul>
<li>s &#x3D; s1 + s2 + … + sn</li>
<li>t &#x3D; t1 + t2 + … + tm</li>
<li>|n - m| &lt;&#x3D; 1</li>
<li>交错 是 s1 + t1 + s2 + t2 + s3 + t3 + … 或者 t1 + s1 + t2 + s2 + t3 + s3 + …</li>
</ul>
<p>注意：a + b 意味着字符串 a 和 b 连接。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    bool isInterleave(string s1, string s2, string s3) &#123;
        auto f &#x3D; vector&lt;vector&lt;int&gt;&gt;(s1.size() + 1, vector&lt;int&gt;(s2.size() + 1, false));
        int n &#x3D; s1.size(), m &#x3D; s2.size(), t &#x3D; s3.size();
        if (n + m !&#x3D; t) return false;
        f[0][0] &#x3D; true;
        for (int i &#x3D; 0; i &lt;&#x3D; n; ++i) &#123;
            for (int j &#x3D; 0; j &lt;&#x3D; m; ++j) &#123;
                int p &#x3D; i + j - 1;
                if (i &gt; 0) &#123;
                    f[i][j] |&#x3D; (f[i - 1][j] &amp;&amp; s1[i - 1] &#x3D;&#x3D; s3[p]);
                &#125;
                if (j &gt; 0) &#123;
                    f[i][j] |&#x3D; (f[i][j - 1] &amp;&amp; s2[j - 1] &#x3D;&#x3D; s3[p]);
                &#125;
            &#125;
        &#125;
        return f[n][m];
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="120-三角形最小路径和"><a href="#120-三角形最小路径和" class="headerlink" title="120. 三角形最小路径和"></a>120. 三角形最小路径和</h3><p>问题地址：<a href="https://leetcode.cn/problems/triangle/">https://leetcode.cn/problems/triangle/</a></p>
<p>给定一个三角形 triangle ，找出自顶向下的最小路径和。</p>
<p>每一步只能移动到下一行中相邻的结点上。相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。也就是说，如果正位于当前行的下标 i ，那么下一步可以移动到下一行的下标 i 或 i + 1 。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int minimumTotal(vector&lt;vector&lt;int&gt;&gt;&amp; triangle) &#123;
        int n &#x3D; triangle.size();
        vector&lt;vector&lt;int&gt;&gt; f(n, vector&lt;int&gt;(n));
        f[0][0] &#x3D; triangle[0][0];
        for (int i &#x3D; 1; i &lt; n; ++i) &#123;
            f[i][0] &#x3D; f[i - 1][0] + triangle[i][0];
            for (int j &#x3D; 1; j &lt; i; ++j) &#123;
                f[i][j] &#x3D; min(f[i - 1][j - 1], f[i - 1][j]) + triangle[i][j];
            &#125;
            f[i][i] &#x3D; f[i - 1][i - 1] + triangle[i][i];
        &#125;
        return *min_element(f[n - 1].begin(), f[n - 1].end());
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="64-最小路径和"><a href="#64-最小路径和" class="headerlink" title="64. 最小路径和"></a>64. 最小路径和</h3><p>问题地址：<a href="https://leetcode.cn/problems/minimum-path-sum/">https://leetcode.cn/problems/minimum-path-sum/</a></p>
<p>给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p>
<p>说明：每次只能向下或者向右移动一步。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;
        if (grid.size() &#x3D;&#x3D; 0 || grid[0].size() &#x3D;&#x3D; 0) return 0;
        int rows &#x3D; grid.size(), columns &#x3D; grid[0].size();
        auto dp &#x3D; vector&lt;vector&lt;int&gt;&gt;(rows, vector&lt;int&gt;(columns));
        dp[0][0] &#x3D; grid[0][0];
        for (int i &#x3D; 1; i &lt; rows; i++) &#123;
            dp[i][0] &#x3D; dp[i - 1][0] + grid[i][0];
        &#125;
        for (int j &#x3D; 1; j &lt; columns; j++) &#123;
            dp[0][j] &#x3D; dp[0][j - 1] + grid[0][j];
        &#125;
        for (int i &#x3D; 1; i &lt; rows; i++) &#123;
            for (int j &#x3D; 1; j &lt; columns; j++) &#123;
                dp[i][j] &#x3D; min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];
            &#125;
        &#125;
        return dp[rows - 1][columns - 1];
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="63-不同路径-II"><a href="#63-不同路径-II" class="headerlink" title="63. 不同路径 II"></a>63. 不同路径 II</h3><p>问题地址：<a href="https://leetcode.cn/problems/unique-paths-ii/">https://leetcode.cn/problems/unique-paths-ii/</a></p>
<p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。</p>
<p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p>
<p>网格中的障碍物和空位置分别用 1 和 0 来表示。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) &#123;
        int n &#x3D; obstacleGrid.size(), m &#x3D; obstacleGrid.at(0).size();
        vector &lt;int&gt; f(m);

        f[0] &#x3D; (obstacleGrid[0][0] &#x3D;&#x3D; 0);
        for (int i &#x3D; 0; i &lt; n; ++i) &#123;
            for (int j &#x3D; 0; j &lt; m; ++j) &#123;
                if (obstacleGrid[i][j] &#x3D;&#x3D; 1) &#123;
                    f[j] &#x3D; 0;
                    continue;
                &#125;
                if (j - 1 &gt;&#x3D; 0 &amp;&amp; obstacleGrid[i][j - 1] &#x3D;&#x3D; 0) &#123;
                    f[j] +&#x3D; f[j - 1];
                &#125;
            &#125;
        &#125;

        return f.back();
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="43-字符串相乘"><a href="#43-字符串相乘" class="headerlink" title="43. 字符串相乘"></a>43. 字符串相乘</h3><p>问题地址：<a href="https://leetcode.cn/problems/multiply-strings/">https://leetcode.cn/problems/multiply-strings/</a></p>
<p>给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。</p>
<p>注意：不能使用任何内置的 BigInteger 库或直接将输入转换为整数。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    string multiply(string num1, string num2) &#123;
        if (num1 &#x3D;&#x3D; &quot;0&quot; || num2 &#x3D;&#x3D; &quot;0&quot;) &#123;
            return &quot;0&quot;;
        &#125;
        int m &#x3D; num1.size(), n &#x3D; num2.size();
        auto ansArr &#x3D; vector&lt;int&gt;(m + n);
        for (int i &#x3D; m - 1; i &gt;&#x3D; 0; i--) &#123;
            int x &#x3D; num1[i] - &#39;0&#39;;
            for (int j &#x3D; n - 1; j &gt;&#x3D; 0; j--) &#123;
                int y &#x3D; num2[j] - &#39;0&#39;;
                ansArr[i + j + 1] +&#x3D; x * y;
            &#125;
        &#125;
        for (int i &#x3D; m + n - 1; i &gt; 0; i--) &#123;
            ansArr[i - 1] +&#x3D; ansArr[i] &#x2F; 10;
            ansArr[i] %&#x3D; 10;
        &#125;
        int index &#x3D; ansArr[0] &#x3D;&#x3D; 0 ? 1 : 0;
        string ans;
        while (index &lt; m + n) &#123;
            ans.push_back(ansArr[index]);
            index++;
        &#125;
        for (auto &amp;c : ans) &#123;
            c +&#x3D; &#39;0&#39;;
        &#125;
        return ans;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="237-删除链表中的节点"><a href="#237-删除链表中的节点" class="headerlink" title="237. 删除链表中的节点"></a>237. 删除链表中的节点</h3><p>问题地址：<a href="https://leetcode.cn/problems/delete-node-in-a-linked-list/">https://leetcode.cn/problems/delete-node-in-a-linked-list/</a></p>
<p>有一个单链表的 head，我们想删除它其中的一个节点 node。</p>
<p>给你一个需要删除的节点 node 。你将 无法访问 第一个节点  head。</p>
<p>链表的所有值都是 唯一的，并且保证给定的节点 node 不是链表中的最后一个节点。</p>
<p>删除给定的节点。注意，删除节点并不是指从内存中删除它。这里的意思是：</p>
<ul>
<li>给定节点的值不应该存在于链表中。</li>
<li>链表中的节点数应该减少 1。</li>
<li>node 前面的所有值顺序相同。</li>
<li>node 后面的所有值顺序相同。</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;**
 * Definition for singly-linked list.
 * struct ListNode &#123;
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) &#123;&#125;
 * &#125;;
 *&#x2F;
class Solution &#123;
public:
    void deleteNode(ListNode* node) &#123;
        node-&gt;val &#x3D; node-&gt;next-&gt;val;
        node-&gt;next &#x3D; node-&gt;next-&gt;next;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="235-二叉搜索树的最近公共祖先"><a href="#235-二叉搜索树的最近公共祖先" class="headerlink" title="235. 二叉搜索树的最近公共祖先"></a>235. 二叉搜索树的最近公共祖先</h3><p>问题地址：<a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/">https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/</a></p>
<p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;**
 * Definition for a binary tree node.
 * struct TreeNode &#123;
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;
 * &#125;;
 *&#x2F;

class Solution &#123;
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;
        TreeNode* ancestor &#x3D; root;
        while (true) &#123;
            if (p-&gt;val &lt; ancestor-&gt;val &amp;&amp; q-&gt;val &lt;ancestor-&gt;val) &#123;
                ancestor &#x3D; ancestor-&gt;left;
            &#125; else if (p-&gt;val &gt; ancestor-&gt;val &amp;&amp; q-&gt;val &gt; ancestor-&gt;val) &#123;
                ancestor &#x3D; ancestor-&gt;right;
            &#125; else &#123;
                break;
            &#125;
        &#125;
        return ancestor;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142. 环形链表 II"></a>142. 环形链表 II</h3><p>问题地址：<a href="https://leetcode.cn/problems/linked-list-cycle-ii/">https://leetcode.cn/problems/linked-list-cycle-ii/</a></p>
<p>给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p>
<p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p>
<p>不允许修改 链表。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;**
 * Definition for singly-linked list.
 * struct ListNode &#123;
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) &#123;&#125;
 * &#125;;
 *&#x2F;
class Solution &#123;
public:
    ListNode *detectCycle(ListNode *head) &#123;
        unordered_set&lt;ListNode *&gt; visited;
        while (head !&#x3D; nullptr) &#123;
            if (visited.count(head)) &#123;
                return head;
            &#125;
            visited.insert(head);
            head &#x3D; head-&gt;next;
        &#125;
        return nullptr;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62. 不同路径"></a>62. 不同路径</h3><p>问题地址：<a href="https://leetcode.cn/problems/unique-paths/">https://leetcode.cn/problems/unique-paths/</a></p>
<p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p>
<p>问总共有多少条不同的路径？</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int uniquePaths(int m, int n) &#123;
        vector&lt;int&gt; f(n, 1);
        f[0] &#x3D; 1;
        for (int i &#x3D; 1; i &lt; m; ++i) &#123;
            for (int j &#x3D; 1; j &lt; n; j++) &#123;
                f[j] +&#x3D; f[j - 1];
            &#125;
        &#125;
        return f.back();
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="59-螺旋矩阵-II"><a href="#59-螺旋矩阵-II" class="headerlink" title="59. 螺旋矩阵 II"></a>59. 螺旋矩阵 II</h3><p>问题地址：<a href="https://leetcode.cn/problems/spiral-matrix-ii/">https://leetcode.cn/problems/spiral-matrix-ii/</a></p>
<p>给你一个正整数 n ，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    vector&lt;vector&lt;int&gt;&gt; generateMatrix(int n) &#123;
        int t &#x3D; 0;      &#x2F;&#x2F; top
        int b &#x3D; n-1;    &#x2F;&#x2F; bottom
        int l &#x3D; 0;      &#x2F;&#x2F; left
        int r &#x3D; n-1;    &#x2F;&#x2F; right
        vector&lt;vector&lt;int&gt;&gt; ans(n,vector&lt;int&gt;(n));
        int k&#x3D;1;
        while(k&lt;&#x3D;n*n)&#123;
            for(int i&#x3D;l;i&lt;&#x3D;r;++i,++k) ans[t][i] &#x3D; k;
            ++t;
            for(int i&#x3D;t;i&lt;&#x3D;b;++i,++k) ans[i][r] &#x3D; k;
            --r;
            for(int i&#x3D;r;i&gt;&#x3D;l;--i,++k) ans[b][i] &#x3D; k;
            --b;
            for(int i&#x3D;b;i&gt;&#x3D;t;--i,++k) ans[i][l] &#x3D; k;
            ++l;
        &#125;
        return ans;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="89-格雷编码"><a href="#89-格雷编码" class="headerlink" title="89. 格雷编码"></a>89. 格雷编码</h3><p>问题地址：<a href="https://leetcode.cn/problems/gray-code/">https://leetcode.cn/problems/gray-code/</a></p>
<p>n 位格雷码序列 是一个由 2n 个整数组成的序列，其中：</p>
<ul>
<li>每个整数都在范围 [0, 2n - 1] 内（含 0 和 2n - 1）</li>
<li>第一个整数是 0</li>
<li>一个整数在序列中出现 不超过一次</li>
<li>每对 相邻 整数的二进制表示 恰好一位不同 ，且</li>
<li>第一个 和 最后一个 整数的二进制表示 恰好一位不同</li>
</ul>
<p>给你一个整数 n ，返回任一有效的 n 位格雷码序列 。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    vector&lt;int&gt; grayCode(int n) &#123;
        vector&lt;int&gt; ret;
        ret.push_back(0);
        for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;
            int m &#x3D; ret.size();
            for (int j &#x3D; m - 1; j &gt;&#x3D; 0; j--) &#123;
                ret.push_back(ret[j] | (1 &lt;&lt; (i - 1)));
            &#125;
        &#125;
        return ret;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="739-每日温度"><a href="#739-每日温度" class="headerlink" title="739. 每日温度"></a>739. 每日温度</h3><p>问题地址：<a href="https://leetcode.cn/problems/daily-temperatures/">https://leetcode.cn/problems/daily-temperatures/</a></p>
<p>给定一个整数数组 temperatures ，表示每天的温度，返回一个数组 answer ，其中 answer[i] 是指对于第 i 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 0 来代替。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    vector&lt;int&gt; dailyTemperatures(vector&lt;int&gt;&amp; temperatures) &#123;
        int n &#x3D; temperatures.size();
        vector&lt;int&gt; ans(n);
        stack&lt;int&gt; s;
        for (int i &#x3D; 0; i &lt; n; ++i) &#123;
            while (!s.empty() &amp;&amp; temperatures[i] &gt; temperatures[s.top()]) &#123;
                int previousIndex &#x3D; s.top();
                ans[previousIndex] &#x3D; i - previousIndex;
                s.pop();
            &#125;
            s.push(i);
        &#125;
        return ans;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="435-无重叠区间"><a href="#435-无重叠区间" class="headerlink" title="435. 无重叠区间"></a>435. 无重叠区间</h3><p>问题地址：<a href="https://leetcode.cn/problems/non-overlapping-intervals/">https://leetcode.cn/problems/non-overlapping-intervals/</a></p>
<p>给定一个区间的集合 intervals ，其中 intervals[i] &#x3D; [starti, endi] 。返回 需要移除区间的最小数量，使剩余区间互不重叠 。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int eraseOverlapIntervals(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123;
        if (intervals.empty()) &#123;
            return 0;
        &#125;
        
        sort(intervals.begin(), intervals.end(), [](const auto&amp; u, const auto&amp; v) &#123;
            return u[1] &lt; v[1];
        &#125;);

        int n &#x3D; intervals.size();
        int right &#x3D; intervals[0][1];
        int ans &#x3D; 1;
        for (int i &#x3D; 1; i &lt; n; ++i) &#123;
            if (intervals[i][0] &gt;&#x3D; right) &#123;
                ++ans;
                right &#x3D; intervals[i][1];
            &#125;
        &#125;
        return n - ans;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="334-递增的三元子序列"><a href="#334-递增的三元子序列" class="headerlink" title="334. 递增的三元子序列"></a>334. 递增的三元子序列</h3><p>问题地址：<a href="https://leetcode.cn/problems/increasing-triplet-subsequence/">https://leetcode.cn/problems/increasing-triplet-subsequence/</a></p>
<p>给你一个整数数组 nums ，判断这个数组中是否存在长度为 3 的递增子序列。</p>
<p>如果存在这样的三元组下标 (i, j, k) 且满足 i &lt; j &lt; k ，使得 nums[i] &lt; nums[j] &lt; nums[k] ，返回 true ；否则，返回 false 。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    bool increasingTriplet(vector&lt;int&gt;&amp; nums) &#123;
        int n &#x3D; nums.size();
        if (n &lt; 3) &#123;
            return false;
        &#125;
        vector&lt;int&gt; leftMin(n);
        leftMin[0] &#x3D; nums[0];
        for (int i &#x3D; 1; i &lt; n; i++) &#123;
            leftMin[i] &#x3D; min(leftMin[i - 1], nums[i]);
        &#125;
        vector&lt;int&gt; rightMax(n);
        rightMax[n - 1] &#x3D; nums[n - 1];
        for (int i &#x3D; n - 2; i &gt;&#x3D; 0; i--) &#123;
            rightMax[i] &#x3D; max(rightMax[i + 1], nums[i]);
        &#125;
        for (int i &#x3D; 1; i &lt; n - 1; i++) &#123;
            if (nums[i] &gt; leftMin[i - 1] &amp;&amp; nums[i] &lt; rightMax[i + 1]) &#123;
                return true;
            &#125;
        &#125;
        return false;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="443-压缩字符串"><a href="#443-压缩字符串" class="headerlink" title="443. 压缩字符串"></a>443. 压缩字符串</h3><p>问题地址：<a href="https://leetcode.cn/problems/string-compression/">https://leetcode.cn/problems/string-compression/</a></p>
<p>给你一个字符数组 chars ，请使用下述算法压缩：</p>
<p>从一个空字符串 s 开始。对于 chars 中的每组 连续重复字符 ：</p>
<ul>
<li>如果这一组长度为 1 ，则将字符追加到 s 中。</li>
<li>否则，需要向 s 追加字符，后跟这一组的长度。</li>
</ul>
<p>压缩后得到的字符串 s 不应该直接返回 ，需要转储到字符数组 chars 中。需要注意的是，如果组长度为 10 或 10 以上，则在 chars 数组中会被拆分为多个字符。</p>
<p>请在 修改完输入数组后 ，返回该数组的新长度。</p>
<p>你必须设计并实现一个只使用常量额外空间的算法来解决此问题。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int compress(vector&lt;char&gt;&amp; chars) &#123;
        int n &#x3D; chars.size();
        int write &#x3D; 0, left &#x3D; 0;
        for (int read &#x3D; 0; read &lt; n; read++) &#123;
            if (read &#x3D;&#x3D; n - 1 || chars[read] !&#x3D; chars[read + 1]) &#123;
                chars[write++] &#x3D; chars[read];
                int num &#x3D; read - left + 1;
                if (num &gt; 1) &#123;
                    int anchor &#x3D; write;
                    while (num &gt; 0) &#123;
                        chars[write++] &#x3D; num % 10 + &#39;0&#39;;
                        num &#x2F;&#x3D; 10;
                    &#125;
                    reverse(&amp;chars[anchor], &amp;chars[write]);
                &#125;
                left &#x3D; read + 1;
            &#125;
        &#125;
        return write;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="1679-K-和数对的最大数目"><a href="#1679-K-和数对的最大数目" class="headerlink" title="1679. K 和数对的最大数目"></a>1679. K 和数对的最大数目</h3><p>问题地址：<a href="https://leetcode.cn/problems/max-number-of-k-sum-pairs/">https://leetcode.cn/problems/max-number-of-k-sum-pairs/</a></p>
<p>给你一个整数数组 nums 和一个整数 k 。</p>
<p>每一步操作中，你需要从数组中选出和为 k 的两个整数，并将它们移出数组。</p>
<p>返回你可以对数组执行的最大操作数。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int maxOperations(vector&lt;int&gt;&amp; nums, int k) &#123;
        sort(nums.begin(), nums.end());
        int left &#x3D; 0, right &#x3D; nums.size() - 1;
        int count &#x3D; 0;
        while (left &lt; right) &#123;
            if (nums[left] + nums[right] &lt; k) &#123;
                left++;
            &#125; else if (nums[left] + nums[right] &gt; k) &#123;
                right--;
            &#125; else &#123;
                right--;
                left++;
                count++;
            &#125;
        &#125;
        return count;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="1456-定长子串中元音的最大数目"><a href="#1456-定长子串中元音的最大数目" class="headerlink" title="1456. 定长子串中元音的最大数目"></a>1456. 定长子串中元音的最大数目</h3><p>问题地址：<a href="https://leetcode.cn/problems/maximum-number-of-vowels-in-a-substring-of-given-length/">https://leetcode.cn/problems/maximum-number-of-vowels-in-a-substring-of-given-length/</a></p>
<p>给你字符串 s 和整数 k 。</p>
<p>请返回字符串 s 中长度为 k 的单个子字符串中可能包含的最大元音字母数。</p>
<p>英文中的 元音字母 为（a, e, i, o, u）。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int maxVowels(string s, int k) &#123;
        int n &#x3D; s.size();
        int vowel_count &#x3D; 0;
        for (int i &#x3D; 0; i &lt; k; ++i) &#123;
            vowel_count +&#x3D; isVowel(s[i]);
        &#125;
        int ans &#x3D; vowel_count;
        for (int i &#x3D; k; i &lt; n; ++i) &#123;
            vowel_count +&#x3D; isVowel(s[i]) - isVowel(s[i - k]);
            ans &#x3D; max(ans, vowel_count);
        &#125;
        return ans;
    &#125;
    bool isVowel(char ch) &#123;
        return ch &#x3D;&#x3D; &#39;a&#39; || ch &#x3D;&#x3D; &#39;e&#39; || ch &#x3D;&#x3D; &#39;i&#39; || ch &#x3D;&#x3D; &#39;o&#39; || ch &#x3D;&#x3D; &#39;u&#39;;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="1004-最大连续1的个数-III"><a href="#1004-最大连续1的个数-III" class="headerlink" title="1004. 最大连续1的个数 III"></a>1004. 最大连续1的个数 III</h3><p>问题地址：<a href="https://leetcode.cn/problems/max-consecutive-ones-iii/">https://leetcode.cn/problems/max-consecutive-ones-iii/</a></p>
<p>给定一个二进制数组 nums 和一个整数 k，如果可以翻转最多 k 个 0 ，则返回 数组中连续 1 的最大个数 。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int longestOnes(vector&lt;int&gt;&amp; nums, int k) &#123;
        int n &#x3D; nums.size();
        int left &#x3D; 0, lsum &#x3D; 0, rsum &#x3D; 0;
        int ans &#x3D; 0;
        for (int right &#x3D; 0; right &lt; n; ++right) &#123;
            rsum +&#x3D; 1 - nums[right];
            while (lsum &lt; rsum - k) &#123;
                lsum +&#x3D; 1 - nums[left];
                ++left;
            &#125;
            ans &#x3D; max(ans, right - left + 1);
        &#125;
        return ans;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="1493-删掉一个元素以后全为-1-的最长子数组"><a href="#1493-删掉一个元素以后全为-1-的最长子数组" class="headerlink" title="1493. 删掉一个元素以后全为 1 的最长子数组"></a>1493. 删掉一个元素以后全为 1 的最长子数组</h3><p>问题地址：<a href="https://leetcode.cn/problems/longest-subarray-of-1s-after-deleting-one-element/">https://leetcode.cn/problems/longest-subarray-of-1s-after-deleting-one-element/</a></p>
<p>给你一个二进制数组 nums ，你需要从中删掉一个元素。</p>
<p>请你在删掉元素的结果数组中，返回最长的且只包含 1 的非空子数组的长度。</p>
<p>如果不存在这样的子数组，请返回 0 。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int longestSubarray(vector&lt;int&gt;&amp; nums) &#123;
        int sum &#x3D; 0, l &#x3D; 0, r;
        for (r &#x3D; 0; r &lt; nums.size(); r++) &#123;
            sum +&#x3D; nums[r];
            if (sum &lt; r - l) &#123;
                sum -&#x3D; nums[l++];
            &#125;
        &#125;
        return r - l - 1;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="450-删除二叉搜索树中的节点"><a href="#450-删除二叉搜索树中的节点" class="headerlink" title="450. 删除二叉搜索树中的节点"></a>450. 删除二叉搜索树中的节点</h3><p>问题地址：<a href="https://leetcode.cn/problems/delete-node-in-a-bst/">https://leetcode.cn/problems/delete-node-in-a-bst/</a></p>
<p>给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</p>
<p>一般来说，删除节点可分为两个步骤：</p>
<ol>
<li>首先找到需要删除的节点；</li>
<li>如果找到了，删除它。</li>
</ol>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;**
 * Definition for a binary tree node.
 * struct TreeNode &#123;
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;
 * &#125;;
 *&#x2F;
class Solution &#123;
public:
    TreeNode* deleteNode(TreeNode* root, int key) &#123;
        if (root &#x3D;&#x3D; nullptr) &#123;
            return nullptr;
        &#125;
        if (root-&gt;val &gt; key) &#123;
            root-&gt;left &#x3D; deleteNode(root-&gt;left, key);
            return root;
        &#125;
        if (root-&gt;val &lt; key) &#123;
            root-&gt;right &#x3D; deleteNode(root-&gt;right, key);
            return root;
        &#125;
        if (root-&gt;val &#x3D;&#x3D; key) &#123;
            if (!root-&gt;left &amp;&amp; !root-&gt;right) &#123;
                return nullptr;
            &#125;
            if (!root-&gt;right) &#123;
                return root-&gt;left;
            &#125;
            if (!root-&gt;left) &#123;
                return root-&gt;right;
            &#125;
            TreeNode* successor &#x3D; root-&gt;right;
            while (successor-&gt;left) &#123;
                successor &#x3D; successor-&gt;left;
            &#125;
            root-&gt;right &#x3D; deleteNode(root-&gt;right, successor-&gt;val);
            successor-&gt;right &#x3D; root-&gt;right;
            successor-&gt;left &#x3D; root-&gt;left;
            return successor;
        &#125;
        return root;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="1657-确定两个字符串是否接近"><a href="#1657-确定两个字符串是否接近" class="headerlink" title="1657. 确定两个字符串是否接近"></a>1657. 确定两个字符串是否接近</h3><p>问题地址：<a href="https://leetcode.cn/problems/determine-if-two-strings-are-close/">https://leetcode.cn/problems/determine-if-two-strings-are-close/</a></p>
<p>如果可以使用以下操作从一个字符串得到另一个字符串，则认为两个字符串 接近 ：</p>
<ul>
<li>操作 1：交换任意两个 现有 字符。例如，abcde -&gt; aecdb</li>
<li>操作 2：将一个 现有 字符的每次出现转换为另一个 现有 字符，并对另一个字符执行相同的操作。例如，aacabb -&gt; bbcbaa（所有 a 转化为 b ，而所有的 b 转换为 a ）</li>
</ul>
<p>你可以根据需要对任意一个字符串多次使用这两种操作。</p>
<p>给你两个字符串，word1 和 word2 。如果 word1 和 word2 接近 ，就返回 true ；否则，返回 false 。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    bool closeStrings(string word1, string word2) &#123;
        vector&lt;int&gt; c1(26, 0), c2(26, 0);
        for (char c : word1) c1[c - &#39;a&#39;]++;
        for (char c : word2) c2[c - &#39;a&#39;]++;
        for (int i &#x3D; 0; i &lt; 26; i++) &#123;
            if (c1[i] + c2[i] &#x3D;&#x3D; 0) continue;
            if (c1[i] &#x3D;&#x3D; 0 || c2[i] &#x3D;&#x3D; 0) return false;
        &#125;
        sort(c1.begin(), c1.end());
        sort(c2.begin(), c2.end());
        for (int i &#x3D; 0; i &lt; 26; i++) &#123;
            if (c1[i] !&#x3D; c2[i]) return false;
        &#125;
        return true;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="2352-相等行列对"><a href="#2352-相等行列对" class="headerlink" title="2352. 相等行列对"></a>2352. 相等行列对</h3><p>问题地址：<a href="https://leetcode.cn/problems/equal-row-and-column-pairs/">https://leetcode.cn/problems/equal-row-and-column-pairs/</a></p>
<p>给你一个下标从 0 开始、大小为 n x n 的整数矩阵 grid ，返回满足 Ri 行和 Cj 列相等的行列对 (Ri, Cj) 的数目。</p>
<p>如果行和列以相同的顺序包含相同的元素（即相等的数组），则认为二者是相等的。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
private:
    int n;
public:
    int equalPairs(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;
        int res &#x3D; 0;
        n &#x3D; grid.size();
        for (int row &#x3D; 0; row &lt; n; row++) &#123;
            for (int col &#x3D; 0; col &lt; n; col++) &#123;
                if (equal(row, col, grid)) &#123;
                    res++;
                &#125;
            &#125;
        &#125;
        return res;
    &#125;
    bool equal(int row, int col, vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;
        for (auto i &#x3D; 0; i &lt; n; i++) &#123;
            if (grid[row][i] !&#x3D; grid[i][col]) &#123;
                return false;
            &#125;
        &#125;
        return true;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="2390-从字符串中移除星号"><a href="#2390-从字符串中移除星号" class="headerlink" title="2390. 从字符串中移除星号"></a>2390. 从字符串中移除星号</h3><p>问题地址：<a href="https://leetcode.cn/problems/removing-stars-from-a-string/">https://leetcode.cn/problems/removing-stars-from-a-string/</a></p>
<p>给你一个包含若干星号 * 的字符串 s 。</p>
<p>在一步操作中，你可以：</p>
<ul>
<li>选中 s 中的一个星号。</li>
<li>移除星号 左侧 最近的那个 非星号 字符，并移除该星号自身。</li>
</ul>
<p>返回移除 所有 星号之后的字符串。</p>
<p>注意：</p>
<ul>
<li>生成的输入保证总是可以执行题面中描述的操作。</li>
<li>可以证明结果字符串是唯一的。</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    string removeStars(string s) &#123;
        stack&lt;char&gt; stack;
        for (auto c : s) &#123;
            if (stack.empty()) &#123;
                stack.push(c);
                continue;
            &#125;
            if (c &#x3D;&#x3D; &#39;*&#39;) &#123;
                stack.pop();
            &#125; else &#123;
                stack.push(c);
            &#125;
        &#125;
        string res;
        while (!stack.empty()) &#123;
            res +&#x3D; stack.top();
            stack.pop();
        &#125;
        reverse(res.begin(), res.end());
        return res;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="735-小行星碰撞"><a href="#735-小行星碰撞" class="headerlink" title="735. 小行星碰撞"></a>735. 小行星碰撞</h3><p>问题地址：<a href="https://leetcode.cn/problems/asteroid-collision/">https://leetcode.cn/problems/asteroid-collision/</a></p>
<p>给定一个整数数组 asteroids，表示在同一行的小行星。</p>
<p>对于数组中的每一个元素，其绝对值表示小行星的大小，正负表示小行星的移动方向（正表示向右移动，负表示向左移动）。每一颗小行星以相同的速度移动。</p>
<p>找出碰撞后剩下的所有小行星。碰撞规则：两个小行星相互碰撞，较小的小行星会爆炸。如果两颗小行星大小相同，则两颗小行星都会爆炸。两颗移动方向相同的小行星，永远不会发生碰撞。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    vector&lt;int&gt; asteroidCollision(vector&lt;int&gt;&amp; asteroids) &#123;
        vector&lt;int&gt; st;
        for (auto aster : asteroids) &#123;
            bool alive &#x3D; true;
            while (alive &amp;&amp; aster &lt; 0 &amp;&amp; !st.empty() &amp;&amp; st.back() &gt; 0) &#123;
                alive &#x3D; st.back() &lt; -aster;
                if (st.back() &lt;&#x3D; -aster) &#123;
                    st.pop_back();
                &#125;
            &#125;
            if (alive) &#123;
                st.push_back(aster);
            &#125;
        &#125;
        return st;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="394-字符串解码"><a href="#394-字符串解码" class="headerlink" title="394. 字符串解码"></a>394. 字符串解码</h3><p>问题地址：<a href="https://leetcode.cn/problems/decode-string/">https://leetcode.cn/problems/decode-string/</a></p>
<p>给定一个经过编码的字符串，返回它解码后的字符串。</p>
<p>编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。</p>
<p>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。</p>
<p>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    string decodeString(string s) &#123;
        string res &#x3D; &quot;&quot;;
        stack&lt;int&gt; nums;
        stack&lt;string&gt; strs;
        int num &#x3D; 0;
        int len &#x3D; s.size();
        for (int i &#x3D; 0; i &lt; len; ++i) &#123;
            if (s[i] &gt;&#x3D; &#39;0&#39; &amp;&amp; s[i] &lt;&#x3D; &#39;9&#39;) &#123;
                num &#x3D; num * 10 + s[i] - &#39;0&#39;;
            &#125; else if ((s[i] &gt;&#x3D; &#39;a&#39; &amp;&amp; s[i] &lt;&#x3D; &#39;z&#39;) || (s[i] &gt;&#x3D; &#39;A&#39; &amp;&amp; s[i] &lt;&#x3D; &#39;Z&#39;)) &#123;
                res &#x3D; res + s[i];
            &#125; else if (s[i] &#x3D;&#x3D; &#39;[&#39;) &#123;
                nums.push(num);
                num &#x3D; 0;
                strs.push(res);
                res &#x3D; &quot;&quot;;
            &#125; else &#123;
                int times &#x3D; nums.top();
                nums.pop();
                for (int j &#x3D; 0; j &lt; times; ++j) &#123;
                    strs.top() +&#x3D; res;
                &#125;
                res &#x3D; strs.top();
                strs.pop();
            &#125;
        &#125;
        return res;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="649-Dota2-参议院"><a href="#649-Dota2-参议院" class="headerlink" title="649. Dota2 参议院"></a>649. Dota2 参议院</h3><p>问题地址：<a href="https://leetcode.cn/problems/dota2-senate/">https://leetcode.cn/problems/dota2-senate/</a></p>
<p>Dota2 的世界里有两个阵营：Radiant（天辉）和 Dire（夜魇）</p>
<p>Dota2 参议院由来自两派的参议员组成。现在参议院希望对一个 Dota2 游戏里的改变作出决定。他们以一个基于轮为过程的投票进行。在每一轮中，每一位参议员都可以行使两项权利中的 一 项：</p>
<ul>
<li>禁止一名参议员的权利：参议员可以让另一位参议员在这一轮和随后的几轮中丧失 所有的权利 。</li>
<li>宣布胜利：如果参议员发现有权利投票的参议员都是 同一个阵营的 ，他可以宣布胜利并决定在游戏中的有关变化。</li>
</ul>
<p>给你一个字符串 senate 代表每个参议员的阵营。字母 ‘R’ 和 ‘D’分别代表了 Radiant（天辉）和 Dire（夜魇）。然后，如果有 n 个参议员，给定字符串的大小将是 n。</p>
<p>以轮为基础的过程从给定顺序的第一个参议员开始到最后一个参议员结束。这一过程将持续到投票结束。所有失去权利的参议员将在过程中被跳过。</p>
<p>假设每一位参议员都足够聪明，会为自己的政党做出最好的策略，你需要预测哪一方最终会宣布胜利并在 Dota2 游戏中决定改变。输出应该是 “Radiant” 或 “Dire” 。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    string predictPartyVictory(string senate) &#123;
        int n &#x3D; senate.size();
        queue&lt;int&gt; radiant, dire;
        for (int i &#x3D; 0; i &lt; n; ++i) &#123;
            if (senate[i] &#x3D;&#x3D; &#39;R&#39;) &#123;
                radiant.push(i);
            &#125; else &#123;
                dire.push(i);
            &#125;
        &#125;
        while (!radiant.empty() &amp;&amp; !dire.empty()) &#123;
            if (radiant.front() &lt; dire.front()) &#123;
                radiant.push(radiant.front() + n);
            &#125; else &#123;
                dire.push(dire.front() + n);
            &#125;
            radiant.pop();
            dire.pop();
        &#125;
        return !radiant.empty() ? &quot;Radiant&quot; : &quot;Dire&quot;;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="2095-删除链表的中间节点"><a href="#2095-删除链表的中间节点" class="headerlink" title="2095. 删除链表的中间节点"></a>2095. 删除链表的中间节点</h3><p>问题地址：<a href="https://leetcode.cn/problems/delete-the-middle-node-of-a-linked-list/">https://leetcode.cn/problems/delete-the-middle-node-of-a-linked-list/</a></p>
<p>给你一个链表的头节点 head 。删除 链表的 中间节点 ，并返回修改后的链表的头节点 head 。</p>
<p>长度为 n 链表的中间节点是从头数起第 ⌊n &#x2F; 2⌋ 个节点（下标从 0 开始），其中 ⌊x⌋ 表示小于或等于 x 的最大整数。</p>
<ul>
<li>对于 n &#x3D; 1、2、3、4 和 5 的情况，中间节点的下标分别是 0、1、1、2 和 2 。</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;**
 * Definition for singly-linked list.
 * struct ListNode &#123;
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) &#123;&#125;
 *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;
 *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;
 * &#125;;
 *&#x2F;
class Solution &#123;
public:
    ListNode* deleteMiddle(ListNode* head) &#123;
        if (head-&gt;next &#x3D;&#x3D; nullptr) &#123;
            return nullptr;
        &#125;
        ListNode* slow &#x3D; head;
        ListNode* fast &#x3D; head;
        ListNode* pre &#x3D; nullptr;
        while (fast &amp;&amp; fast-&gt;next) &#123;
            fast &#x3D; fast-&gt;next-&gt;next;
            pre &#x3D; slow;
            slow &#x3D; slow-&gt;next;
        &#125;
        pre-&gt;next &#x3D; pre-&gt;next-&gt;next;
        return head;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="2130-链表最大孪生和"><a href="#2130-链表最大孪生和" class="headerlink" title="2130. 链表最大孪生和"></a>2130. 链表最大孪生和</h3><p>问题地址：<a href="https://leetcode.cn/problems/maximum-twin-sum-of-a-linked-list/">https://leetcode.cn/problems/maximum-twin-sum-of-a-linked-list/</a></p>
<p>在一个大小为 n 且 n 为 偶数 的链表中，对于 0 &lt;&#x3D; i &lt;&#x3D; (n &#x2F; 2) - 1 的 i ，第 i 个节点（下标从 0 开始）的孪生节点为第 (n-1-i) 个节点 。</p>
<ul>
<li>比方说，n &#x3D; 4 那么节点 0 是节点 3 的孪生节点，节点 1 是节点 2 的孪生节点。这是长度为 n &#x3D; 4 的链表中所有的孪生节点。</li>
</ul>
<p>孪生和 定义为一个节点和它孪生节点两者值之和。</p>
<p>给你一个长度为偶数的链表的头节点 head ，请你返回链表的 最大孪生和 。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;**
 * Definition for singly-linked list.
 * struct ListNode &#123;
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) &#123;&#125;
 *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;
 *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;
 * &#125;;
 *&#x2F;
class Solution &#123;
public:
    int pairSum(ListNode* head) &#123;
        ListNode* slow &#x3D; head;
        ListNode* fast &#x3D; head-&gt;next;
        while (fast-&gt;next) &#123;
            slow &#x3D; slow-&gt;next;
            fast &#x3D; fast-&gt;next-&gt;next;
        &#125;
        ListNode* last &#x3D; slow-&gt;next;
        while (last-&gt;next) &#123;
            ListNode* cur &#x3D; last-&gt;next;
            last-&gt;next &#x3D; cur-&gt;next;
            cur-&gt;next &#x3D; slow-&gt;next;
            slow-&gt;next &#x3D; cur;
        &#125;
        int ans &#x3D; 0;
        ListNode* x &#x3D; head;
        ListNode* y &#x3D; slow-&gt;next;
        while (y) &#123;
            ans &#x3D; max(ans, x-&gt;val + y-&gt;val);
            x &#x3D; x-&gt;next;
            y &#x3D; y-&gt;next;
        &#125;
        return ans;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="1448-统计二叉树中好节点的数目"><a href="#1448-统计二叉树中好节点的数目" class="headerlink" title="1448. 统计二叉树中好节点的数目"></a>1448. 统计二叉树中好节点的数目</h3><p>问题地址：<a href="https://leetcode.cn/problems/count-good-nodes-in-binary-tree/">https://leetcode.cn/problems/count-good-nodes-in-binary-tree/</a></p>
<p>给你一棵根为 root 的二叉树，请你返回二叉树中好节点的数目。</p>
<p>「好节点」X 定义为：从根到该节点 X 所经过的节点中，没有任何节点的值大于 X 的值。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;**
 * Definition for a binary tree node.
 * struct TreeNode &#123;
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;
 * &#125;;
 *&#x2F;
class Solution &#123;
public:
    int goodNodes(TreeNode* root) &#123;
        return dfs(root, INT_MIN);
    &#125;
    int dfs(TreeNode* root, int path_max) &#123;
        if (root &#x3D;&#x3D; nullptr) &#123;
            return 0;
        &#125;
        int res &#x3D; 0;
        if (root-&gt;val &gt;&#x3D; path_max) &#123;
            res++;
            path_max &#x3D; root-&gt;val;
        &#125;
        res +&#x3D; dfs(root-&gt;left, path_max) + dfs(root-&gt;right, path_max);
        return res;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="437-路径总和-III"><a href="#437-路径总和-III" class="headerlink" title="437. 路径总和 III"></a>437. 路径总和 III</h3><p>问题地址：<a href="https://leetcode.cn/problems/path-sum-iii/">https://leetcode.cn/problems/path-sum-iii/</a></p>
<p>给定一个二叉树的根节点 root ，和一个整数 targetSum ，求该二叉树里节点值之和等于 targetSum 的 路径 的数目。</p>
<p>路径 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;**
 * Definition for a binary tree node.
 * struct TreeNode &#123;
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;
 * &#125;;
 *&#x2F;
class Solution &#123;
private:
    unordered_map&lt;long long, int&gt; prefix;
public:
    int pathSum(TreeNode* root, int targetSum) &#123;
        prefix[0] &#x3D; 1;
        return dfs(root, 0, targetSum);
    &#125;
    int dfs(TreeNode* root, long long curr, int targetSum) &#123;
        if (!root) &#123;
            return 0;
        &#125;
        int ret &#x3D; 0;
        curr +&#x3D; root-&gt;val;
        if (prefix.count(curr - targetSum)) &#123;
            ret &#x3D; prefix[curr - targetSum];
        &#125;
        prefix[curr]++;
        ret +&#x3D; dfs(root-&gt;left, curr, targetSum);
        ret +&#x3D; dfs(root-&gt;right, curr, targetSum);
        prefix[curr]--;
        return ret;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="1372-二叉树中的最长交错路径"><a href="#1372-二叉树中的最长交错路径" class="headerlink" title="1372. 二叉树中的最长交错路径"></a>1372. 二叉树中的最长交错路径</h3><p>问题地址：<a href="https://leetcode.cn/problems/longest-zigzag-path-in-a-binary-tree/">https://leetcode.cn/problems/longest-zigzag-path-in-a-binary-tree/</a></p>
<p>给你一棵以 root 为根的二叉树，二叉树中的交错路径定义如下：</p>
<ul>
<li>选择二叉树中 任意 节点和一个方向（左或者右）。</li>
<li>如果前进方向为右，那么移动到当前节点的的右子节点，否则移动到它的左子节点。</li>
<li>改变前进方向：左变右或者右变左。</li>
<li>重复第二步和第三步，直到你在树中无法继续移动。</li>
</ul>
<p>交错路径的长度定义为：访问过的节点数目 - 1（单个节点的路径长度为 0 ）。</p>
<p>请你返回给定树中最长 交错路径 的长度。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;**
 * Definition for a binary tree node.
 * struct TreeNode &#123;
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;
 * &#125;;
 *&#x2F;
class Solution &#123;
private:
    int maxAns;
public:
    int longestZigZag(TreeNode* root) &#123;
        if (!root) return 0;
        maxAns &#x3D; 0;
        dfs(root, 0, 0);
        dfs(root, 1, 0);
        return maxAns;
    &#125;
    void dfs(TreeNode* o, bool dir, int len) &#123;
        maxAns &#x3D; max(maxAns, len);
        if (!dir) &#123;
            if (o-&gt;left) dfs(o-&gt;left, 1, len + 1);
            if (o-&gt;right) dfs(o-&gt;right, 0, 1);
        &#125; else &#123;
            if (o-&gt;right) dfs(o-&gt;right, 0, len + 1);
            if (o-&gt;left) dfs(o-&gt;left, 1, 1);
        &#125;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="1161-最大层内元素和"><a href="#1161-最大层内元素和" class="headerlink" title="1161. 最大层内元素和"></a>1161. 最大层内元素和</h3><p>问题地址：<a href="https://leetcode.cn/problems/maximum-level-sum-of-a-binary-tree/">https://leetcode.cn/problems/maximum-level-sum-of-a-binary-tree/</a></p>
<p>给你一个二叉树的根节点 root。设根节点位于二叉树的第 1 层，而根节点的子节点位于第 2 层，依此类推。</p>
<p>请返回层内元素之和 最大 的那几层（可能只有一层）的层号，并返回其中 最小 的那个。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;**
 * Definition for a binary tree node.
 * struct TreeNode &#123;
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;
 * &#125;;
 *&#x2F;
class Solution &#123;
private:
    vector&lt;int&gt; sum;
public:
    int maxLevelSum(TreeNode* root) &#123;
        dfs(root, 0);
        int ans &#x3D; 0;
        for (int i &#x3D; 0; i &lt; sum.size(); ++i) &#123;
            if (sum[i] &gt; sum[ans]) &#123;
                ans &#x3D; i;
            &#125;
        &#125;
        return ans + 1;
    &#125;
    void dfs(TreeNode* node, int level) &#123;
        if (level &#x3D;&#x3D; sum.size()) &#123;
            sum.push_back(node-&gt;val);
        &#125; else &#123;
            sum[level] +&#x3D; node-&gt;val;
        &#125;
        if (node-&gt;left) &#123;
            dfs(node-&gt;left, level + 1);
        &#125;
        if (node-&gt;right) &#123;
            dfs(node-&gt;right, level + 1);
        &#125;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="901-股票价格跨度"><a href="#901-股票价格跨度" class="headerlink" title="901. 股票价格跨度"></a>901. 股票价格跨度</h3><p>问题地址：<a href="https://leetcode.cn/problems/online-stock-span/">https://leetcode.cn/problems/online-stock-span/</a></p>
<p>设计一个算法收集某些股票的每日报价，并返回该股票当日价格的 跨度 。</p>
<p>当日股票价格的 跨度 被定义为股票价格小于或等于今天价格的最大连续日数（从今天开始往回数，包括今天）。</p>
<ul>
<li>例如，如果未来 7 天股票的价格是 [100,80,60,70,60,75,85]，那么股票跨度将是 [1,1,1,2,1,4,6] 。</li>
</ul>
<p>实现 StockSpanner 类：</p>
<ul>
<li>StockSpanner() 初始化类对象。</li>
<li>int next(int price) 给出今天的股价 price ，返回该股票当日价格的 跨度 。</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class StockSpanner &#123;
private:
    stack&lt;pair&lt;int, int&gt;&gt; stk;
    int idx;
public:
    StockSpanner() &#123;
        this-&gt;stk.emplace(-1, INT_MAX);
        this-&gt;idx &#x3D; -1;
    &#125;
    
    int next(int price) &#123;
        idx++;
        while (price &gt;&#x3D; stk.top().second) &#123;
            stk.pop();
        &#125;
        int ret &#x3D; idx - stk.top().first;
        stk.emplace(idx, price);
        return ret;
    &#125;
&#125;;

&#x2F;**
 * Your StockSpanner object will be instantiated and called as such:
 * StockSpanner* obj &#x3D; new StockSpanner();
 * int param_1 &#x3D; obj-&gt;next(price);
 *&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="841-钥匙和房间"><a href="#841-钥匙和房间" class="headerlink" title="841. 钥匙和房间"></a>841. 钥匙和房间</h3><p>问题地址：<a href="https://leetcode.cn/problems/keys-and-rooms/">https://leetcode.cn/problems/keys-and-rooms/</a></p>
<p>有 n 个房间，房间按从 0 到 n - 1 编号。最初，除 0 号房间外的其余所有房间都被锁住。你的目标是进入所有的房间。然而，你不能在没有获得钥匙的时候进入锁住的房间。</p>
<p>当你进入一个房间，你可能会在里面找到一套不同的钥匙，每把钥匙上都有对应的房间号，即表示钥匙可以打开的房间。你可以拿上所有钥匙去解锁其他房间。</p>
<p>给你一个数组 rooms 其中 rooms[i] 是你进入 i 号房间可以获得的钥匙集合。如果能进入 所有 房间返回 true，否则返回 false。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
private:
    vector&lt;int&gt; vis;
    int num;
public:
    bool canVisitAllRooms(vector&lt;vector&lt;int&gt;&gt;&amp; rooms) &#123;
        int n &#x3D; rooms.size();
        num &#x3D; 0;
        vis.resize(n);
        dfs(rooms, 0);
        return num &#x3D;&#x3D; n;
    &#125;
    void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; rooms, int x) &#123;
        vis[x] &#x3D; true;
        num++;
        for (auto&amp; it : rooms[x]) &#123;
            if (!vis[it]) &#123;
                dfs(rooms, it);
            &#125;
        &#125;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="547-省份数量"><a href="#547-省份数量" class="headerlink" title="547. 省份数量"></a>547. 省份数量</h3><p>问题地址：<a href="https://leetcode.cn/problems/number-of-provinces/">https://leetcode.cn/problems/number-of-provinces/</a></p>
<p>有 n 个城市，其中一些彼此相连，另一些没有相连。如果城市 a 与城市 b 直接相连，且城市 b 与城市 c 直接相连，那么城市 a 与城市 c 间接相连。</p>
<p>省份 是一组直接或间接相连的城市，组内不含其他没有相连的城市。</p>
<p>给你一个 n x n 的矩阵 isConnected ，其中 isConnected[i][j] &#x3D; 1 表示第 i 个城市和第 j 个城市直接相连，而 isConnected[i][j] &#x3D; 0 表示二者不直接相连。</p>
<p>返回矩阵中 省份 的数量。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int findCircleNum(vector&lt;vector&lt;int&gt;&gt;&amp; isConnected) &#123;
        int cities &#x3D; isConnected.size();
        vector&lt;int&gt; visited(cities);
        int provinces &#x3D; 0;
        for (int i &#x3D; 0; i &lt; cities; i++) &#123;
            if (!visited[i]) &#123;
                dfs(isConnected, visited, cities, i);
                provinces++;
            &#125;
        &#125;
        return provinces;
    &#125;
    void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; isConnected, vector&lt;int&gt;&amp; visited, int cities, int i) &#123;
        for (int j &#x3D; 0; j &lt; cities; j++) &#123;
            if (isConnected[i][j] &#x3D;&#x3D; 1 &amp;&amp; !visited[j]) &#123;
                visited[j] &#x3D; 1;
                dfs(isConnected, visited, cities, j);
            &#125;
        &#125;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="1466-重新规划路线"><a href="#1466-重新规划路线" class="headerlink" title="1466. 重新规划路线"></a>1466. 重新规划路线</h3><p>问题地址：<a href="https://leetcode.cn/problems/reorder-routes-to-make-all-paths-lead-to-the-city-zero/">https://leetcode.cn/problems/reorder-routes-to-make-all-paths-lead-to-the-city-zero/</a></p>
<p>n 座城市，从 0 到 n-1 编号，其间共有 n-1 条路线。因此，要想在两座不同城市之间旅行只有唯一一条路线可供选择（路线网形成一颗树）。去年，交通运输部决定重新规划路线，以改变交通拥堵的状况。</p>
<p>路线用 connections 表示，其中 connections[i] &#x3D; [a, b] 表示从城市 a 到 b 的一条有向路线。</p>
<p>今年，城市 0 将会举办一场大型比赛，很多游客都想前往城市 0 。</p>
<p>请你帮助重新规划路线方向，使每个城市都可以访问城市 0 。返回需要变更方向的最小路线数。</p>
<p>题目数据 保证 每个城市在重新规划路线方向后都能到达城市 0 。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int minReorder(int n, vector&lt;vector&lt;int&gt;&gt;&amp; connections) &#123;
        vector&lt;vector&lt;int&gt;&gt; conn_idx(n, vector&lt;int&gt;());
        for (int i &#x3D; 0; i &lt; connections.size(); i++) &#123;
            conn_idx[connections[i][0]].push_back(i);
            conn_idx[connections[i][1]].push_back(i);
        &#125;
        vector&lt;bool&gt; vi(connections.size(), false);
        int ans &#x3D; 0;
        queue&lt;int&gt; que;
        que.push(0);
        while (!que.empty()) &#123;
            auto q &#x3D; que.front();
            que.pop();
            for (auto idx : conn_idx[q]) &#123;
                if (vi[idx]) continue;
                vi[idx] &#x3D; true;
                int a &#x3D; connections[idx][0];
                int b &#x3D; connections[idx][1];
                ans +&#x3D; (a &#x3D;&#x3D; q);
                a &#x3D; (a &#x3D;&#x3D; q) ? b : a;
                que.push(a);
            &#125;
        &#125;
        return ans;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="1926-迷宫中离入口最近的出口"><a href="#1926-迷宫中离入口最近的出口" class="headerlink" title="1926. 迷宫中离入口最近的出口"></a>1926. 迷宫中离入口最近的出口</h3><p>问题地址：<a href="https://leetcode.cn/problems/nearest-exit-from-entrance-in-maze/">https://leetcode.cn/problems/nearest-exit-from-entrance-in-maze/</a></p>
<p>给你一个 m x n 的迷宫矩阵 maze （下标从 0 开始），矩阵中有空格子（用 ‘.’ 表示）和墙（用 ‘+’ 表示）。同时给你迷宫的入口 entrance ，用 entrance &#x3D; [entrancerow, entrancecol] 表示你一开始所在格子的行和列。</p>
<p>每一步操作，你可以往 上，下，左 或者 右 移动一个格子。你不能进入墙所在的格子，你也不能离开迷宫。你的目标是找到离 entrance 最近 的出口。出口 的含义是 maze 边界 上的 空格子。entrance 格子 不算 出口。</p>
<p>请你返回从 entrance 到最近出口的最短路径的 步数 ，如果不存在这样的路径，请你返回 -1 。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int nearestExit(vector&lt;vector&lt;char&gt;&gt;&amp; maze, vector&lt;int&gt;&amp; entrance) &#123;
        int m &#x3D; maze.size();
        int n &#x3D; maze[0].size();
        vector&lt;int&gt; dx &#x3D; &#123;1, 0, -1, 0&#125;;
        vector&lt;int&gt; dy &#x3D; &#123;0, 1, 0, -1&#125;;
        queue&lt;tuple&lt;int, int, int&gt;&gt; q;
        q.emplace(entrance[0], entrance[1], 0);
        maze[entrance[0]][entrance[1]] &#x3D; &#39;+&#39;;
        while (!q.empty()) &#123;
            auto [cx, cy, d] &#x3D; q.front();
            q.pop();
            for (int k &#x3D; 0; k &lt; 4; ++k) &#123;
                int nx &#x3D; cx + dx[k];
                int ny &#x3D; cy + dy[k];
                if (nx &gt;&#x3D; 0 &amp;&amp; nx &lt; m &amp;&amp; ny &gt;&#x3D; 0 &amp;&amp; ny &lt; n &amp;&amp; maze[nx][ny] &#x3D;&#x3D; &#39;.&#39;) &#123;
                    if (nx &#x3D;&#x3D; 0 || nx &#x3D;&#x3D; m - 1 || ny &#x3D;&#x3D; 0 || ny &#x3D;&#x3D; n - 1) &#123;
                        return d + 1;
                    &#125;
                    maze[nx][ny] &#x3D; &#39;+&#39;;
                    q.emplace(nx, ny, d + 1);
                &#125;
            &#125;
        &#125;
        return -1;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="2336-无限集中的最小数字"><a href="#2336-无限集中的最小数字" class="headerlink" title="2336. 无限集中的最小数字"></a>2336. 无限集中的最小数字</h3><p>问题地址：<a href="https://leetcode.cn/problems/smallest-number-in-infinite-set/">https://leetcode.cn/problems/smallest-number-in-infinite-set/</a></p>
<p>现有一个包含所有正整数的集合 [1, 2, 3, 4, 5, …] 。</p>
<p>实现 SmallestInfiniteSet 类：</p>
<ul>
<li>SmallestInfiniteSet() 初始化 SmallestInfiniteSet 对象以包含 所有 正整数。</li>
<li>int popSmallest() 移除 并返回该无限集中的最小整数。</li>
<li>void addBack(int num) 如果正整数 num 不 存在于无限集中，则将一个 num 添加 到该无限集最后。</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class SmallestInfiniteSet &#123;
private:
    set&lt;int&gt; s;
public:
    SmallestInfiniteSet() &#123;
        s.clear();
        for (int i &#x3D; 1; i &lt; 1001; i++) s.insert(i);
    &#125;
    
    int popSmallest() &#123;
        int x &#x3D; *s.begin();
        s.erase(s.begin());
        return x;
    &#125;
    
    void addBack(int num) &#123;
        s.insert(num);
    &#125;
&#125;;

&#x2F;**
 * Your SmallestInfiniteSet object will be instantiated and called as such:
 * SmallestInfiniteSet* obj &#x3D; new SmallestInfiniteSet();
 * int param_1 &#x3D; obj-&gt;popSmallest();
 * obj-&gt;addBack(num);
 *&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="1268-搜索推荐系统"><a href="#1268-搜索推荐系统" class="headerlink" title="1268. 搜索推荐系统"></a>1268. 搜索推荐系统</h3><p>问题地址：<a href="https://leetcode.cn/problems/search-suggestions-system/">https://leetcode.cn/problems/search-suggestions-system/</a></p>
<p>给你一个产品数组 products 和一个字符串 searchWord ，products  数组中每个产品都是一个字符串。</p>
<p>请你设计一个推荐系统，在依次输入单词 searchWord 的每一个字母后，推荐 products 数组中前缀与 searchWord 相同的最多三个产品。如果前缀相同的可推荐产品超过三个，请按字典序返回最小的三个。</p>
<p>请你以二维列表的形式，返回在输入 searchWord 每个字母后相应的推荐产品的列表。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    vector&lt;vector&lt;string&gt;&gt; suggestedProducts(vector&lt;string&gt;&amp; products, string searchWord) &#123;
        sort(products.begin(), products.end());
        int n &#x3D; products.size();
        vector&lt;vector&lt;string&gt;&gt; ans;
        for (int i &#x3D; 0; i &lt; searchWord.length(); i++) &#123;
            string cur &#x3D; searchWord.substr(0, i + 1);
            int l &#x3D; 0, r &#x3D; n - 1;
            while (l &lt; r) &#123;
                int mid &#x3D; (l + r) &gt;&gt; 1;
                if (products[mid] &gt;&#x3D; cur) r &#x3D; mid;
                else l &#x3D; mid + 1;
            &#125;
            vector&lt;string&gt; list;
            if (products[r] &gt;&#x3D; cur) &#123;
                for (int j &#x3D; r; j &lt;&#x3D; min(n - 1, r + 2); j++) &#123;
                    if (products[j].length() &lt; cur.length()) break;
                    if (products[j].substr(0, i + 1) !&#x3D; cur) break;
                    list.push_back(products[j]);
                &#125;
            &#125;
            ans.push_back(list);
        &#125;
        return ans;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="1318-或运算的最小翻转次数"><a href="#1318-或运算的最小翻转次数" class="headerlink" title="1318. 或运算的最小翻转次数"></a>1318. 或运算的最小翻转次数</h3><p>问题地址：<a href="https://leetcode.cn/problems/minimum-flips-to-make-a-or-b-equal-to-c/">https://leetcode.cn/problems/minimum-flips-to-make-a-or-b-equal-to-c/</a></p>
<p>给你三个正整数 a、b 和 c。</p>
<p>你可以对 a 和 b 的二进制表示进行位翻转操作，返回能够使按位或运算   a OR b &#x3D;&#x3D; c  成立的最小翻转次数。</p>
<p>「位翻转操作」是指将一个数的二进制表示任何单个位上的 1 变成 0 或者 0 变成 1 。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int minFlips(int a, int b, int c) &#123;
        int ans &#x3D; 0;
        for (int i &#x3D; 0; i &lt; 31; ++i) &#123;
            int bit_a &#x3D; (a &gt;&gt; i) &amp; 1;
            int bit_b &#x3D; (b &gt;&gt; i) &amp; 1;
            int bit_c &#x3D; (c &gt;&gt; i) &amp; 1;
            if (bit_c &#x3D;&#x3D; 0) &#123;
                ans +&#x3D; bit_a + bit_b;
            &#125; else &#123;
                ans +&#x3D; (bit_a + bit_b &#x3D;&#x3D; 0);
            &#125;
        &#125;
        return ans;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="2542-最大子序列的分数"><a href="#2542-最大子序列的分数" class="headerlink" title="2542. 最大子序列的分数"></a>2542. 最大子序列的分数</h3><p>问题地址：<a href="https://leetcode.cn/problems/maximum-subsequence-score/">https://leetcode.cn/problems/maximum-subsequence-score/</a></p>
<p>给你两个下标从 0 开始的整数数组 nums1 和 nums2 ，两者长度都是 n ，再给你一个正整数 k 。你必须从 nums1 中选一个长度为 k 的 子序列 对应的下标。</p>
<p>对于选择的下标 i0 ，i1 ，…， ik - 1 ，你的 分数 定义如下：</p>
<ul>
<li>nums1 中下标对应元素求和，乘以 nums2 中下标对应元素的 最小值 。</li>
<li>用公式表示： (nums1[i0] + nums1[i1] +…+ nums1[ik - 1]) * min(nums2[i0] , nums2[i1], … ,nums2[ik - 1]) 。</li>
</ul>
<p>请你返回 最大 可能的分数。</p>
<p>一个数组的 子序列 下标是集合 {0, 1, …, n-1} 中删除若干元素得到的剩余集合，也可以不删除任何元素。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    long long maxScore(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2, int k) &#123;
        long res &#x3D; 0L;
        int n &#x3D; nums1.size();
        vector&lt;int&gt; ids(n);
        iota(ids.begin(), ids.end(), 0);
        sort(ids.begin(), ids.end(), [&amp;](int i, int j) &#123;
            return nums2[i] &gt; nums2[j];
        &#125;);
        priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; minHeap;
        long sum1 &#x3D; 0L;
        for (int i &#x3D; 0; i &lt; k - 1; ++i) &#123;
            int id &#x3D; ids[i];
            sum1 +&#x3D; nums1[id];
            minHeap.push(nums1[id]);
        &#125;
        for (int i &#x3D; k - 1; i &lt; n; ++i) &#123;
            int id &#x3D; ids[i];
            int num1 &#x3D; nums1[id];
            sum1 +&#x3D; num1;
            minHeap.push(num1);
            res &#x3D; max(sum1 * nums2[id], res);
            sum1 -&#x3D; minHeap.top();
            minHeap.pop();
        &#125;
        return res;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="2462-雇佣-K-位工人的总代价"><a href="#2462-雇佣-K-位工人的总代价" class="headerlink" title="2462. 雇佣 K 位工人的总代价"></a>2462. 雇佣 K 位工人的总代价</h3><p>问题地址：<a href="https://leetcode.cn/problems/total-cost-to-hire-k-workers/">https://leetcode.cn/problems/total-cost-to-hire-k-workers/</a></p>
<p>给你一个下标从 0 开始的整数数组 costs ，其中 costs[i] 是雇佣第 i 位工人的代价。</p>
<p>同时给你两个整数 k 和 candidates 。我们想根据以下规则恰好雇佣 k 位工人：</p>
<ul>
<li>总共进行 k 轮雇佣，且每一轮恰好雇佣一位工人。</li>
<li>在每一轮雇佣中，从最前面 candidates 和最后面 candidates 人中选出代价最小的一位工人，如果有多位代价相同且最小的工人，选择下标更小的一位工人。<ul>
<li>比方说，costs &#x3D; [3,2,7,7,1,2] 且 candidates &#x3D; 2 ，第一轮雇佣中，我们选择第 4 位工人，因为他的代价最小 [3,2,7,7,1,2] 。</li>
<li>第二轮雇佣，我们选择第 1 位工人，因为他们的代价与第 4 位工人一样都是最小代价，而且下标更小，[3,2,7,7,2] 。注意每一轮雇佣后，剩余工人的下标可能会发生变化。</li>
</ul>
</li>
<li>如果剩余员工数目不足 candidates 人，那么下一轮雇佣他们中代价最小的一人，如果有多位代价相同且最小的工人，选择下标更小的一位工人。</li>
<li>一位工人只能被选择一次。</li>
</ul>
<p>返回雇佣恰好 k 位工人的总代价。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    long long totalCost(vector&lt;int&gt;&amp; costs, int k, int candidates) &#123;
        priority_queue&lt;int, vector&lt;int&gt;, greater&lt;&gt;&gt; pq0, pq1;
        int i &#x3D; 0;
        int j &#x3D; costs.size() - 1;
        long long ans &#x3D; 0;
        while (k--) &#123;
            while (pq0.size() &lt; candidates &amp;&amp; i &lt;&#x3D; j) &#123;
                pq0.push(costs[i++]);
            &#125;
            while (pq1.size() &lt; candidates &amp;&amp; i &lt;&#x3D; j) &#123;
                pq1.push(costs[j--]);
            &#125;
            int a &#x3D; (pq0.size() &gt; 0) ? pq0.top() : INT_MAX;
            int b &#x3D; (pq1.size() &gt; 0) ? pq1.top() : INT_MAX;
            if (a &lt;&#x3D; b) &#123;
                ans +&#x3D; a;
                pq0.pop();
            &#125; else &#123;
                ans +&#x3D; b;
                pq1.pop();
            &#125;
        &#125;
        return ans;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="2300-咒语和药水的成功对数"><a href="#2300-咒语和药水的成功对数" class="headerlink" title="2300. 咒语和药水的成功对数"></a>2300. 咒语和药水的成功对数</h3><p>问题地址：<a href="https://leetcode.cn/problems/successful-pairs-of-spells-and-potions/">https://leetcode.cn/problems/successful-pairs-of-spells-and-potions/</a></p>
<p>给你两个正整数数组 spells 和 potions ，长度分别为 n 和 m ，其中 spells[i] 表示第 i 个咒语的能量强度，potions[j] 表示第 j 瓶药水的能量强度。</p>
<p>同时给你一个整数 success 。一个咒语和药水的能量强度 相乘 如果 大于等于 success ，那么它们视为一对 成功 的组合。</p>
<p>请你返回一个长度为 n 的整数数组 pairs，其中 pairs[i] 是能跟第 i 个咒语成功组合的 药水 数目。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    vector&lt;int&gt; successfulPairs(vector&lt;int&gt;&amp; spells, vector&lt;int&gt;&amp; potions, long long success) &#123;
        sort(potions.begin(), potions.end());
        for (auto &amp;x : spells) &#123;
            x &#x3D; potions.end() - upper_bound(
                potions.begin(),
                potions.end(),
                (success - 1) &#x2F; x
            );
        &#125;
        return spells;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="875-爱吃香蕉的珂珂"><a href="#875-爱吃香蕉的珂珂" class="headerlink" title="875. 爱吃香蕉的珂珂"></a>875. 爱吃香蕉的珂珂</h3><p>问题地址：<a href="https://leetcode.cn/problems/koko-eating-bananas/">https://leetcode.cn/problems/koko-eating-bananas/</a></p>
<p>珂珂喜欢吃香蕉。这里有 n 堆香蕉，第 i 堆中有 piles[i] 根香蕉。警卫已经离开了，将在 h 小时后回来。</p>
<p>珂珂可以决定她吃香蕉的速度 k （单位：根&#x2F;小时）。每个小时，她将会选择一堆香蕉，从中吃掉 k 根。如果这堆香蕉少于 k 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉。  </p>
<p>珂珂喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。</p>
<p>返回她可以在 h 小时内吃掉所有香蕉的最小速度 k（k 为整数）。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int minEatingSpeed(vector&lt;int&gt;&amp; piles, int h) &#123;
        int low &#x3D; 1;
        int high &#x3D; 0;
        for (int pile : piles) &#123;
            high &#x3D; max(high, pile);
        &#125;
        int k &#x3D; high;
        while (low &lt; high) &#123;
            int speed &#x3D; (high - low) &#x2F; 2 + low;
            long time &#x3D; getTime(piles, speed);
            if (time &lt;&#x3D; h) &#123;
                k &#x3D; speed;
                high &#x3D; speed;
            &#125; else &#123;
                low &#x3D; speed + 1;
            &#125;
        &#125;
        return k;
    &#125;

    long getTime(const vector&lt;int&gt;&amp; piles, int speed) &#123;
        long time &#x3D; 0;
        for (int pile : piles) &#123;
            int curTime &#x3D; (pile + speed - 1) &#x2F; speed;
            time +&#x3D; curTime;
        &#125;
        return time;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="216-组合总和-III"><a href="#216-组合总和-III" class="headerlink" title="216. 组合总和 III"></a>216. 组合总和 III</h3><p>问题地址：<a href="https://leetcode.cn/problems/combination-sum-iii/">https://leetcode.cn/problems/combination-sum-iii/</a></p>
<p>找出所有相加之和为 n 的 k 个数的组合，且满足下列条件：</p>
<ul>
<li>只使用数字1到9</li>
<li>每个数字 最多使用一次</li>
</ul>
<p> </p>
<p>返回 所有可能的有效组合的列表 。该列表不能包含相同的组合两次，组合可以以任何顺序返回。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
private:
    vector&lt;int&gt; temp;
    vector&lt;vector&lt;int&gt;&gt; ans;
public:
    vector&lt;vector&lt;int&gt;&gt; combinationSum3(int k, int n) &#123;
        dfs(1, 9, k, n);
        return ans;
    &#125;
    void dfs(int cur, int n, int k, int sum) &#123;
        if (temp.size() + (n - cur + 1) &lt; k || temp.size() &gt; k) &#123;
            return;
        &#125;
        if (temp.size() &#x3D;&#x3D; k &amp;&amp; accumulate(temp.begin(), temp.end(), 0) &#x3D;&#x3D; sum) &#123;
            ans.push_back(temp);
            return;
        &#125;
        temp.push_back(cur);
        dfs(cur + 1, n, k, sum);
        temp.pop_back();
        dfs(cur + 1, n , k, sum);
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="1143-最长公共子序列"><a href="#1143-最长公共子序列" class="headerlink" title="1143. 最长公共子序列"></a>1143. 最长公共子序列</h3><p>问题地址：<a href="https://leetcode.cn/problems/longest-common-subsequence/">https://leetcode.cn/problems/longest-common-subsequence/</a></p>
<p>给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。</p>
<p>一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p>
<ul>
<li>例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。</li>
</ul>
<p>两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int longestCommonSubsequence(string text1, string text2) &#123;
        int m &#x3D; text1.length(), n &#x3D; text2.length();
        vector&lt;vector&lt;int&gt;&gt; dp(m + 1, vector&lt;int&gt;(n + 1));
        for (int i &#x3D; 1; i &lt;&#x3D; m; i++) &#123;
            char c1 &#x3D; text1[i - 1];
            for (int j &#x3D; 1; j &lt;&#x3D; n; j++) &#123;
                char c2 &#x3D; text2[j - 1];
                if (c1 &#x3D;&#x3D; c2) &#123;
                    dp[i][j] &#x3D; dp[i - 1][j - 1] + 1;
                &#125; else &#123;
                    dp[i][j] &#x3D; max(dp[i - 1][j], dp[i][j - 1]);
                &#125;
            &#125;
        &#125;
        return dp[m][n];
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="714-买卖股票的最佳时机含手续费"><a href="#714-买卖股票的最佳时机含手续费" class="headerlink" title="714. 买卖股票的最佳时机含手续费"></a>714. 买卖股票的最佳时机含手续费</h3><p>问题地址：<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/</a></p>
<p>给定一个整数数组 prices，其中 prices[i]表示第 i 天的股票价格 ；整数 fee 代表了交易股票的手续费用。</p>
<p>你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。</p>
<p>返回获得利润的最大值。</p>
<p>注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int maxProfit(vector&lt;int&gt;&amp; prices, int fee) &#123;
        int n &#x3D; prices.size();
        vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(2));
        dp[0][0] &#x3D; 0, dp[0][1] &#x3D; -prices[0];
        for (int i &#x3D; 1; i &lt; n; ++i) &#123;
            dp[i][0] &#x3D; max(dp[i - 1][0], dp[i - 1][1] + prices[i] - fee);
            dp[i][1] &#x3D; max(dp[i - 1][1], dp[i - 1][0] - prices[i]);
        &#125;
        return dp[n - 1][0];
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="790-多米诺和托米诺平铺"><a href="#790-多米诺和托米诺平铺" class="headerlink" title="790. 多米诺和托米诺平铺"></a>790. 多米诺和托米诺平铺</h3><p>问题地址：<a href="https://leetcode.cn/problems/domino-and-tromino-tiling/">https://leetcode.cn/problems/domino-and-tromino-tiling/</a></p>
<p>有两种形状的瓷砖：一种是 2 x 1 的多米诺形，另一种是形如 “L” 的托米诺形。两种形状都可以旋转。</p>
<p><img src="https://cos.luyf-lemon-love.space/images/20231213210117.png"></p>
<p>给定整数 n ，返回可以平铺 2 x n 的面板的方法的数量。返回对 109 + 7 取模 的值。</p>
<p>平铺指的是每个正方形都必须有瓷砖覆盖。两个平铺不同，当且仅当面板上有四个方向上的相邻单元中的两个，使得恰好有一个平铺有一个瓷砖占据两个正方形。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">const long long mod &#x3D; 1e9 + 7;
class Solution &#123;
public:
    int numTilings(int n) &#123;
        vector&lt;vector&lt;long long&gt;&gt; dp(n + 1, vector&lt;long long&gt;(4));
        dp[0][3] &#x3D; 1;
        for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;
            dp[i][0] &#x3D; dp[i - 1][3];
            dp[i][1] &#x3D; (dp[i - 1][0] + dp[i - 1][2]) % mod;
            dp[i][2] &#x3D; (dp[i - 1][0] + dp[i - 1][1]) % mod;
            dp[i][3] &#x3D; (dp[i - 1][0] + dp[i - 1][1] + dp[i - 1][2] + dp[i - 1][3]) % mod;
        &#125;
        return dp[n][3];
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="面试题-01-05-一次编辑"><a href="#面试题-01-05-一次编辑" class="headerlink" title="面试题 01.05. 一次编辑"></a>面试题 01.05. 一次编辑</h3><p>问题地址：<a href="https://leetcode.cn/problems/one-away-lcci/">https://leetcode.cn/problems/one-away-lcci/</a></p>
<p>字符串有三种编辑操作:插入一个英文字符、删除一个英文字符或者替换一个英文字符。 给定两个字符串，编写一个函数判定它们是否只需要一次(或者零次)编辑。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    bool oneEditAway(string first, string second) &#123;
        int lf &#x3D; first.length(), ls &#x3D; second.length();
        if (lf &gt; ls) return oneEditAway(second, first);
        if (ls - lf &gt; 1) return false;
        if (lf &#x3D;&#x3D; ls) &#123;
            int count &#x3D; 0;
            for (int i &#x3D; 0; i &lt; lf; i++) &#123;
                if (first[i] !&#x3D; second[i]) count +&#x3D; 1;
            &#125;
            return count &lt;&#x3D; 1;
        &#125;
        int i &#x3D; 0, ofs &#x3D; 0;
        while (i &lt; lf) &#123;
            if (first[i] !&#x3D; second[i + ofs]) &#123;
                if (++ofs &gt; 1) return false;
            &#125; else &#123;
                i +&#x3D; 1;
            &#125;
        &#125;
        return true;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="面试题-01-07-旋转矩阵"><a href="#面试题-01-07-旋转矩阵" class="headerlink" title="面试题 01.07. 旋转矩阵"></a>面试题 01.07. 旋转矩阵</h3><p>问题地址：<a href="https://leetcode.cn/problems/rotate-matrix-lcci/">https://leetcode.cn/problems/rotate-matrix-lcci/</a></p>
<p>给你一幅由 N × N 矩阵表示的图像，其中每个像素的大小为 4 字节。请你设计一种算法，将图像旋转 90 度。</p>
<p>不占用额外内存空间能否做到？</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;
        int n &#x3D; matrix.size();
        for (int i &#x3D; 0; i &lt; n &#x2F; 2; ++i) &#123;
            for (int j &#x3D; 0; j &lt; n; ++j) &#123;
                swap(matrix[i][j], matrix[n - i -1][j]);
            &#125;
        &#125;
        for (int i &#x3D; 0; i &lt; n; ++i) &#123;
            for (int j &#x3D; 0; j &lt; i; ++j) &#123;
                swap(matrix[i][j], matrix[j][i]);
            &#125;
        &#125;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="面试题-01-08-零矩阵"><a href="#面试题-01-08-零矩阵" class="headerlink" title="面试题 01.08. 零矩阵"></a>面试题 01.08. 零矩阵</h3><p>问题地址：<a href="https://leetcode.cn/problems/zero-matrix-lcci/">https://leetcode.cn/problems/zero-matrix-lcci/</a></p>
<p>编写一种算法，若M × N矩阵中某个元素为0，则将其所在的行与列清零。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    void setZeroes(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;
        int m &#x3D; matrix.size();
        int n &#x3D; matrix[0].size();
        vector&lt;int&gt; row(m), col(n);
        for (int i &#x3D; 0; i &lt; m; i++) &#123;
            for (int j &#x3D; 0; j &lt; n; j++) &#123;
                if (!matrix[i][j]) &#123;
                    row[i] &#x3D; col[j] &#x3D; true;
                &#125;
            &#125;
        &#125;
        for (int i &#x3D; 0; i &lt; m; i++) &#123;
            for (int j &#x3D; 0; j &lt; n; j++) &#123;
                if (row[i] || col[j]) &#123;
                    matrix[i][j] &#x3D; 0;
                &#125;
            &#125;
        &#125;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="面试题-02-04-分割链表"><a href="#面试题-02-04-分割链表" class="headerlink" title="面试题 02.04. 分割链表"></a>面试题 02.04. 分割链表</h3><p>问题地址：<a href="https://leetcode.cn/problems/partition-list-lcci/">https://leetcode.cn/problems/partition-list-lcci/</a></p>
<p>给你一个链表的头节点 head 和一个特定值 x ，请你对链表进行分隔，使得所有 小于 x 的节点都出现在 大于或等于 x 的节点之前。</p>
<p>你不需要 保留 每个分区中各节点的初始相对位置。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;**
 * Definition for singly-linked list.
 * struct ListNode &#123;
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) &#123;&#125;
 * &#125;;
 *&#x2F;
class Solution &#123;
public:
    ListNode* partition(ListNode* head, int x) &#123;
        ListNode* small &#x3D; new ListNode(0);
        ListNode* smallHead &#x3D; small;
        ListNode* large &#x3D; new ListNode(0);
        ListNode* largeHead &#x3D; large;
        while (head !&#x3D; nullptr) &#123;
            if (head-&gt;val &lt; x) &#123;
                small-&gt;next &#x3D; head;
                small &#x3D; small-&gt;next;
            &#125; else &#123;
                large-&gt;next &#x3D; head;
                large &#x3D; large-&gt;next;
            &#125;
            head &#x3D; head-&gt;next;
        &#125;
        large-&gt;next &#x3D; nullptr;
        small-&gt;next &#x3D; largeHead-&gt;next;
        return smallHead-&gt;next;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="面试题-02-05-链表求和"><a href="#面试题-02-05-链表求和" class="headerlink" title="面试题 02.05. 链表求和"></a>面试题 02.05. 链表求和</h3><p>问题地址：<a href="https://leetcode.cn/problems/sum-lists-lcci/">https://leetcode.cn/problems/sum-lists-lcci/</a></p>
<p>给定两个用链表表示的整数，每个节点包含一个数位。</p>
<p>这些数位是反向存放的，也就是个位排在链表首部。</p>
<p>编写函数对这两个整数求和，并用链表形式返回结果。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;**
 * Definition for singly-linked list.
 * struct ListNode &#123;
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) &#123;&#125;
 * &#125;;
 *&#x2F;
class Solution &#123;
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123;
        ListNode* head &#x3D; nullptr, * tail &#x3D; nullptr;
        int carry &#x3D; 0;
        while (l1 || l2) &#123;
            int n1 &#x3D; l1 ? l1-&gt;val : 0;
            int n2 &#x3D; l2 ? l2-&gt;val : 0;
            int sum &#x3D; n1 + n2 + carry;
            if (!head) &#123;
                head &#x3D; tail &#x3D; new ListNode(sum % 10);
            &#125; else &#123;
                tail-&gt;next &#x3D; new ListNode(sum % 10);
                tail &#x3D; tail-&gt;next;
            &#125;
            carry &#x3D; sum &#x2F; 10;
            if (l1) &#123;
                l1 &#x3D; l1-&gt;next;
            &#125;
            if (l2) &#123;
                l2 &#x3D; l2-&gt;next;
            &#125;
        &#125;
        if (carry &gt; 0) &#123;
            tail-&gt;next &#x3D; new ListNode(carry);
        &#125;
        return head;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="面试题-02-08-环路检测"><a href="#面试题-02-08-环路检测" class="headerlink" title="面试题 02.08. 环路检测"></a>面试题 02.08. 环路检测</h3><p>问题地址：<a href="https://leetcode.cn/problems/linked-list-cycle-lcci/">https://leetcode.cn/problems/linked-list-cycle-lcci/</a></p>
<p>给定一个链表，如果它是有环链表，实现一个算法返回环路的开头节点。若环不存在，请返回 null。</p>
<p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;**
 * Definition for singly-linked list.
 * struct ListNode &#123;
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) &#123;&#125;
 * &#125;;
 *&#x2F;
class Solution &#123;
public:
    ListNode *detectCycle(ListNode *head) &#123;
        unordered_set&lt;ListNode*&gt; visited;
        while (head !&#x3D; nullptr) &#123;
            if (visited.count(head)) &#123;
                return head;
            &#125;
            visited.insert(head);
            head &#x3D; head-&gt;next;
        &#125;
        return nullptr;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="面试题-03-03-堆盘子"><a href="#面试题-03-03-堆盘子" class="headerlink" title="面试题 03.03. 堆盘子"></a>面试题 03.03. 堆盘子</h3><p>问题地址：<a href="https://leetcode.cn/problems/stack-of-plates-lcci/">https://leetcode.cn/problems/stack-of-plates-lcci/</a></p>
<p>堆盘子。设想有一堆盘子，堆太高可能会倒下来。因此，在现实生活中，盘子堆到一定高度时，我们就会另外堆一堆盘子。请实现数据结构SetOfStacks，模拟这种行为。SetOfStacks应该由多个栈组成，并且在前一个栈填满时新建一个栈。此外，SetOfStacks.push()和SetOfStacks.pop()应该与普通栈的操作方法相同（也就是说，pop()返回的值，应该跟只有一个栈时的情况一样）。 进阶：实现一个popAt(int index)方法，根据指定的子栈，执行pop操作。</p>
<p>当某个栈为空时，应当删除该栈。当栈中没有元素或不存在该栈时，pop，popAt 应返回 -1.</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class StackOfPlates &#123;
private:
    vector&lt;stack&lt;int&gt;&gt; stks;
    int capacity;
public:
    StackOfPlates(int cap) &#123;
        capacity &#x3D; cap;
    &#125;
    
    void push(int val) &#123;
        if (capacity &#x3D;&#x3D; 0) &#123;
            return;
        &#125;
        if (stks.empty() || stks.back().size() &#x3D;&#x3D; capacity) &#123;
            stks.emplace_back(stack&lt;int&gt;());
        &#125;
        stks.back().push(val);
    &#125;
    
    int pop() &#123;
        if (capacity &#x3D;&#x3D; 0 || stks.empty()) &#123;
            return -1;
        &#125;
        int res &#x3D; stks.back().top();
        stks.back().pop();
        if (stks.back().empty()) &#123;
            stks.pop_back();
        &#125;
        return res;
    &#125;
    
    int popAt(int index) &#123;
        if (capacity &#x3D;&#x3D; 0 || index &gt;&#x3D; stks.size() || stks[index].empty()) &#123;
            return -1;
        &#125;
        int res &#x3D; stks[index].top();
        stks[index].pop();
        if (stks[index].empty()) &#123;
            stks.erase(stks.begin() + index);
        &#125;
        return res;
    &#125;
&#125;;

&#x2F;**
 * Your StackOfPlates object will be instantiated and called as such:
 * StackOfPlates* obj &#x3D; new StackOfPlates(cap);
 * obj-&gt;push(val);
 * int param_2 &#x3D; obj-&gt;pop();
 * int param_3 &#x3D; obj-&gt;popAt(index);
 *&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="面试题-03-05-栈排序"><a href="#面试题-03-05-栈排序" class="headerlink" title="面试题 03.05. 栈排序"></a>面试题 03.05. 栈排序</h3><p>问题地址：<a href="https://leetcode.cn/problems/sort-of-stacks-lcci/">https://leetcode.cn/problems/sort-of-stacks-lcci/</a></p>
<p>栈排序。 编写程序，对栈进行排序使最小元素位于栈顶。最多只能使用一个其他的临时栈存放数据，但不得将元素复制到别的数据结构（如数组）中。该栈支持如下操作：push、pop、peek 和 isEmpty。当栈为空时，peek 返回 -1。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class SortedStack &#123;
private:
    stack&lt;int&gt; st;
    void mySort(int val) &#123;
        if (st.empty() || st.top() &gt;&#x3D; val) &#123;
            st.emplace(val);
        &#125; else &#123;
            int tmp &#x3D; st.top();
            st.pop();
            mySort(val);
            st.emplace(tmp);
        &#125;
    &#125;
public:
    SortedStack() &#123;&#125;
    
    void push(int val) &#123;
        mySort(val);
    &#125;
    
    void pop() &#123;
        if (!st.empty()) st.pop();
    &#125;
    
    int peek() &#123;
        if (st.empty()) return -1;
        return st.top();
    &#125;
    
    bool isEmpty() &#123;
        if (st.empty()) return true;
        else return false;
    &#125;
&#125;;

&#x2F;**
 * Your SortedStack object will be instantiated and called as such:
 * SortedStack* obj &#x3D; new SortedStack();
 * obj-&gt;push(val);
 * obj-&gt;pop();
 * int param_3 &#x3D; obj-&gt;peek();
 * bool param_4 &#x3D; obj-&gt;isEmpty();
 *&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="面试题-04-01-节点间通路"><a href="#面试题-04-01-节点间通路" class="headerlink" title="面试题 04.01. 节点间通路"></a>面试题 04.01. 节点间通路</h3><p>问题地址：<a href="https://leetcode.cn/problems/route-between-nodes-lcci/">https://leetcode.cn/problems/route-between-nodes-lcci/</a></p>
<p>节点间通路。给定有向图，设计一个算法，找出两个节点之间是否存在一条路径。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
private:
    unordered_map&lt;int, unordered_set&lt;int&gt;&gt; m;
    vector&lt;bool&gt; visited;
public:
    bool findWhetherExistsPath(int n, vector&lt;vector&lt;int&gt;&gt;&amp; graph, int start, int target) &#123;
        for (auto i &#x3D; 0; i &lt; graph.size(); i++) &#123;
            m[graph[i][0]].insert(graph[i][1]);
        &#125;
        visited &#x3D; vector&lt;bool&gt;(n, false);
        return dfs(start, target);
    &#125;
    bool dfs(int start, int target) &#123;
        if (start &#x3D;&#x3D; target) &#123;
            return true;
        &#125;
        if (visited[start]) &#123;
            return false;
        &#125;
        visited[start] &#x3D; true;
        for (auto&amp; neighbor : m[start]) &#123;
            if (dfs(neighbor, target)) &#123;
                return true;
            &#125;
        &#125;
        return false;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="面试题-04-03-特定深度节点链表"><a href="#面试题-04-03-特定深度节点链表" class="headerlink" title="面试题 04.03. 特定深度节点链表"></a>面试题 04.03. 特定深度节点链表</h3><p>问题地址：<a href="https://leetcode.cn/problems/list-of-depth-lcci/">https://leetcode.cn/problems/list-of-depth-lcci/</a></p>
<p>给定一棵二叉树，设计一个算法，创建含有某一深度上所有节点的链表（比如，若一棵树的深度为 D，则会创建出 D 个链表）。返回一个包含所有深度的链表的数组。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;**
 * Definition for a binary tree node.
 * struct TreeNode &#123;
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;
 * &#125;;
 *&#x2F;
&#x2F;**
 * Definition for singly-linked list.
 * struct ListNode &#123;
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) &#123;&#125;
 * &#125;;
 *&#x2F;
class Solution &#123;
public:
    vector&lt;ListNode*&gt; listOfDepth(TreeNode* tree) &#123;
        vector&lt;ListNode*&gt; res;
        if (tree &#x3D;&#x3D; nullptr) &#123;
            return res;
        &#125;
        queue&lt;TreeNode*&gt; q;
        q.push(tree);
        while (!q.empty()) &#123;
            ListNode* head &#x3D; nullptr;
            ListNode* prev &#x3D; nullptr;
            int currSize &#x3D; q.size();
            for (int i &#x3D; 0; i &lt; currSize; ++i) &#123;
                TreeNode* currNode &#x3D; q.front();
                ListNode* newNode &#x3D; new ListNode(currNode-&gt;val);
                q.pop();
                if (head &#x3D;&#x3D; nullptr) &#123;
                    head &#x3D; newNode;
                &#125; else &#123;
                    prev-&gt;next &#x3D; newNode;
                &#125;
                prev &#x3D; newNode;
                if (currNode-&gt;left !&#x3D; nullptr) &#123;
                    q.push(currNode-&gt;left);
                &#125;
                if (currNode-&gt;right !&#x3D; nullptr) &#123;
                    q.push(currNode-&gt;right);
                &#125;
            &#125;
            res.push_back(head);
        &#125;
        return res;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="面试题-04-05-合法二叉搜索树"><a href="#面试题-04-05-合法二叉搜索树" class="headerlink" title="面试题 04.05. 合法二叉搜索树"></a>面试题 04.05. 合法二叉搜索树</h3><p>问题地址：<a href="https://leetcode.cn/problems/legal-binary-search-tree-lcci/">https://leetcode.cn/problems/legal-binary-search-tree-lcci/</a></p>
<p>实现一个函数，检查一棵二叉树是否为二叉搜索树。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;**
 * Definition for a binary tree node.
 * struct TreeNode &#123;
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;
 * &#125;;
 *&#x2F;
class Solution &#123;
public:
    bool isValidBST(TreeNode* root) &#123;
        return helper(root, LONG_MIN, LONG_MAX);
    &#125;
    bool helper(TreeNode* root, long long lower, long long upper) &#123;
        if (root &#x3D;&#x3D; nullptr) &#123;
            return true;
        &#125;
        if (root-&gt;val &lt;&#x3D; lower || root-&gt;val &gt;&#x3D; upper) &#123;
            return false;
        &#125;
        return helper(root-&gt;left, lower, root-&gt;val) &amp;&amp;
               helper(root-&gt;right, root-&gt;val, upper);
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="面试题-04-06-后继者"><a href="#面试题-04-06-后继者" class="headerlink" title="面试题 04.06. 后继者"></a>面试题 04.06. 后继者</h3><p>问题地址：<a href="https://leetcode.cn/problems/successor-lcci/">https://leetcode.cn/problems/successor-lcci/</a></p>
<p>设计一个算法，找出二叉搜索树中指定节点的“下一个”节点（也即中序后继）。</p>
<p>如果指定节点没有对应的“下一个”节点，则返回null。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;**
 * Definition for a binary tree node.
 * struct TreeNode &#123;
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;
 * &#125;;
 *&#x2F;
class Solution &#123;
public:
    TreeNode* inorderSuccessor(TreeNode* root, TreeNode* p) &#123;
        stack&lt;TreeNode*&gt; st;
        TreeNode* prev &#x3D; nullptr, *curr &#x3D; root;
        while (!st.empty() || curr !&#x3D; nullptr) &#123;
            while (curr !&#x3D; nullptr) &#123;
                st.emplace(curr);
                curr &#x3D; curr-&gt;left;
            &#125;
            curr &#x3D; st.top();
            st.pop();
            if (prev &#x3D;&#x3D; p) &#123;
                return curr;
            &#125;
            prev &#x3D; curr;
            curr &#x3D; curr-&gt;right;
        &#125;
        return nullptr;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="面试题-04-08-首个共同祖先"><a href="#面试题-04-08-首个共同祖先" class="headerlink" title="面试题 04.08. 首个共同祖先"></a>面试题 04.08. 首个共同祖先</h3><p>问题地址：<a href="https://leetcode.cn/problems/first-common-ancestor-lcci/">https://leetcode.cn/problems/first-common-ancestor-lcci/</a></p>
<p>设计并实现一个算法，找出二叉树中某两个节点的第一个共同祖先。不得将其他的节点存储在另外的数据结构中。注意：这不一定是二叉搜索树。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;**
 * Definition for a binary tree node.
 * struct TreeNode &#123;
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;
 * &#125;;
 *&#x2F;
class Solution &#123;
private:
    TreeNode* ans;
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;
        dfs(root, p, q);
        return ans;
    &#125;
    bool dfs(TreeNode* root, TreeNode* p, TreeNode* q) &#123;
        if (root &#x3D;&#x3D; nullptr) return false;
        bool lson &#x3D; dfs(root-&gt;left, p, q);
        bool rson &#x3D; dfs(root-&gt;right, p, q);
        if ((lson &amp;&amp; rson) || ((root-&gt;val &#x3D;&#x3D; p-&gt;val || root-&gt;val &#x3D;&#x3D; q-&gt;val) &amp;&amp; (lson || rson))) &#123;
            ans &#x3D; root;
        &#125;
        return lson || rson || (root-&gt;val &#x3D;&#x3D; p-&gt;val || root-&gt;val &#x3D;&#x3D; q-&gt;val);
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="面试题-04-10-检查子树"><a href="#面试题-04-10-检查子树" class="headerlink" title="面试题 04.10. 检查子树"></a>面试题 04.10. 检查子树</h3><p>问题地址：<a href="https://leetcode.cn/problems/check-subtree-lcci/">https://leetcode.cn/problems/check-subtree-lcci/</a></p>
<p>检查子树。你有两棵非常大的二叉树：T1，有几万个节点；T2，有几万个节点。设计一个算法，判断 T2 是否为 T1 的子树。</p>
<p>如果 T1 有这么一个节点 n，其子树与 T2 一模一样，则 T2 为 T1 的子树，也就是说，从节点 n 处把树砍断，得到的树与 T2 完全相同。</p>
<p>注意：此题相对书上原题略有改动。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;**
 * Definition for a binary tree node.
 * struct TreeNode &#123;
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;
 * &#125;;
 *&#x2F;
class Solution &#123;
public:
    bool checkSubTree(TreeNode* t1, TreeNode* t2) &#123;
        if (t2 &#x3D;&#x3D; nullptr) return true;
        else if (t1 &#x3D;&#x3D; nullptr) return false;
        else &#123;
            return compare(t1, t2) || checkSubTree(t1-&gt;left, t2) || checkSubTree(t1-&gt;right, t2);
        &#125;

    &#125;
    bool compare(TreeNode* t1, TreeNode* t2) &#123;
        if (t2 &#x3D;&#x3D; nullptr &amp;&amp; t1 !&#x3D; nullptr) return false;
        if (t1 &#x3D;&#x3D; nullptr &amp;&amp; t2 !&#x3D; nullptr) return false;
        if (t1 &#x3D;&#x3D; nullptr &amp;&amp; t2 &#x3D;&#x3D; nullptr) return true;
        if (t1-&gt;val &#x3D;&#x3D; t2-&gt;val) &#123;
            return compare(t1-&gt;left, t2-&gt;left) &amp;&amp; compare(t1-&gt;right, t2-&gt;right);
        &#125;
        return false;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="面试题-04-12-求和路径"><a href="#面试题-04-12-求和路径" class="headerlink" title="面试题 04.12. 求和路径"></a>面试题 04.12. 求和路径</h3><p>问题地址：<a href="https://leetcode.cn/problems/paths-with-sum-lcci/">https://leetcode.cn/problems/paths-with-sum-lcci/</a></p>
<p>给定一棵二叉树，其中每个节点都含有一个整数数值(该值或正或负)。设计一个算法，打印节点数值总和等于某个给定值的所有路径的数量。注意，路径不一定非得从二叉树的根节点或叶节点开始或结束，但是其方向必须向下(只能从父节点指向子节点方向)。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;**
 * Definition for a binary tree node.
 * struct TreeNode &#123;
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;
 * &#125;;
 *&#x2F;
class Solution &#123;
public:
    int pathSum(TreeNode* root, int sum) &#123;
        if (!root) &#123;
            return 0;
        &#125;
        int ret &#x3D; rootSum(root, sum);
        ret +&#x3D; pathSum(root-&gt;left, sum);
        ret +&#x3D; pathSum(root-&gt;right, sum);
        return ret;
    &#125;
    int rootSum(TreeNode* root, int sum) &#123;
        if (!root) &#123;
            return 0;
        &#125;
        int ret &#x3D; 0;
        if (root-&gt;val &#x3D;&#x3D; sum) &#123;
            ret++;
        &#125;
        ret +&#x3D; rootSum(root-&gt;left, sum - root-&gt;val);
        ret +&#x3D; rootSum(root-&gt;right, sum - root-&gt;val);
        return ret;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="面试题-05-02-二进制数转字符串"><a href="#面试题-05-02-二进制数转字符串" class="headerlink" title="面试题 05.02. 二进制数转字符串"></a>面试题 05.02. 二进制数转字符串</h3><p>问题地址：<a href="https://leetcode.cn/problems/binary-number-to-string-lcci/">https://leetcode.cn/problems/binary-number-to-string-lcci/</a></p>
<p>二进制数转字符串。给定一个介于0和1之间的实数（如0.72），类型为double，打印它的二进制表达式。如果该数字无法精确地用32位以内的二进制表示，则打印“ERROR”。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    string printBin(double num) &#123;
        string res &#x3D; &quot;0.&quot;;
        while (res.size() &lt;&#x3D; 32 &amp;&amp; num !&#x3D; 0) &#123;
            num *&#x3D; 2;
            int digit &#x3D; num;
            res.push_back(digit + &#39;0&#39;);
            num -&#x3D; digit;
        &#125;
        return res.size() &lt;&#x3D; 32 ? res : &quot;ERROR&quot;;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="面试题-05-08-绘制直线"><a href="#面试题-05-08-绘制直线" class="headerlink" title="面试题 05.08. 绘制直线"></a>面试题 05.08. 绘制直线</h3><p>问题地址：<a href="https://leetcode.cn/problems/draw-line-lcci/">https://leetcode.cn/problems/draw-line-lcci/</a></p>
<p>已知一个由像素点组成的单色屏幕，每行均有 w 个像素点，所有像素点初始为 0，左上角位置为 (0,0)。</p>
<p>现将每行的像素点按照「每 32 个像素点」为一组存放在一个 int 中，再依次存入长度为 length 的一维数组中。</p>
<p>我们将在屏幕上绘制一条从点 (x1,y) 到点 (x2,y) 的直线（即像素点修改为 1），请返回绘制过后的数组。</p>
<p>注意：</p>
<ul>
<li>用例保证屏幕宽度 w 可被 32 整除（即一个 int 不会分布在两行上）</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    vector&lt;int&gt; drawLine(int length, int w, int x1, int x2, int y) &#123;
        int per_row &#x3D; w &#x2F; 32;
        vector&lt;int&gt; res(length, 0);
        for (int i &#x3D; x1; i &lt;&#x3D; x2 &amp;&amp; i &lt; length * 32; i++) &#123;
            res[y * per_row + i &#x2F; 32] |&#x3D; (1 &lt;&lt; 31 - i % 32);
        &#125;
        return res;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="面试题-08-02-迷路的机器人"><a href="#面试题-08-02-迷路的机器人" class="headerlink" title="面试题 08.02. 迷路的机器人"></a>面试题 08.02. 迷路的机器人</h3><p>问题地址：<a href="https://leetcode.cn/problems/robot-in-a-grid-lcci/">https://leetcode.cn/problems/robot-in-a-grid-lcci/</a></p>
<p>设想有个机器人坐在一个网格的左上角，网格 r 行 c 列。机器人只能向下或向右移动，但不能走到一些被禁止的网格（有障碍物）。设计一种算法，寻找机器人从左上角移动到右下角的路径。</p>
<p>网格中的障碍物和空位置分别用 1 和 0 来表示。</p>
<p>返回一条可行的路径，路径由经过的网格的行号和列号组成。左上角为 0 行 0 列。如果没有可行的路径，返回空数组。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    vector&lt;vector&lt;int&gt;&gt; pathWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) &#123;
        vector&lt;vector&lt;int&gt;&gt; ans;
        if (obstacleGrid.size() &#x3D;&#x3D; 0 || obstacleGrid[0].size() &#x3D;&#x3D; 0) return ans;
        int m &#x3D; obstacleGrid.size(), n &#x3D; obstacleGrid[0].size();
        vector&lt;vector&lt;bool&gt;&gt; vis(m, vector&lt;bool&gt;(n, false));
        function&lt;bool(int, int)&gt; dfs &#x3D; [&amp;](int x, int y) &#123;
            if (x &gt;&#x3D; m || y &gt;&#x3D; n || obstacleGrid[x][y] &#x3D;&#x3D; 1 || vis[x][y]) return false;
            if (x &#x3D;&#x3D; m - 1 &amp;&amp; y &#x3D;&#x3D; n - 1) &#123;
                ans.push_back(&#123;x, y&#125;);
                return true;
            &#125;
            vis[x][y] &#x3D; true;
            ans.push_back(&#123;x, y&#125;);
            if (dfs(x + 1, y) || dfs(x, y + 1)) &#123;
                return true;
            &#125;
            ans.pop_back();
            return false;
        &#125;;
        dfs(0, 0);
        return ans;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="面试题-08-04-幂集"><a href="#面试题-08-04-幂集" class="headerlink" title="面试题 08.04. 幂集"></a>面试题 08.04. 幂集</h3><p>问题地址：<a href="https://leetcode.cn/problems/power-set-lcci/">https://leetcode.cn/problems/power-set-lcci/</a></p>
<p>幂集。编写一种方法，返回某集合的所有子集。集合中不包含重复的元素。</p>
<p>说明：解集不能包含重复的子集。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123;
        int n &#x3D; nums.size();
        vector&lt;int&gt; t;
        vector&lt;vector&lt;int&gt;&gt; ans;
        for (int mask &#x3D; 0; mask &lt; (1 &lt;&lt; n); ++mask) &#123;
            t.clear();
            for (int i &#x3D; 0; i &lt; n; ++i) &#123;
                if (mask &amp; (1 &lt;&lt; i)) &#123;
                    t.push_back(nums[i]);
                &#125;
            &#125;
            ans.push_back(t);
        &#125;
        return ans;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="面试题-08-05-递归乘法"><a href="#面试题-08-05-递归乘法" class="headerlink" title="面试题 08.05. 递归乘法"></a>面试题 08.05. 递归乘法</h3><p>问题地址：<a href="https://leetcode.cn/problems/recursive-mulitply-lcci/">https://leetcode.cn/problems/recursive-mulitply-lcci/</a></p>
<p>递归乘法。 写一个递归函数，不使用 * 运算符， 实现两个正整数的相乘。可以使用加号、减号、位移，但要吝啬一些。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int multiply(int A, int B) &#123;
        if (B &#x3D;&#x3D; 1) return A;
        return (B &amp; 1) ? (multiply(A, B &gt;&gt; 1) &lt;&lt; 1) + A :
            multiply(A, B &gt;&gt; 1) &lt;&lt; 1;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="面试题-08-07-无重复字符串的排列组合"><a href="#面试题-08-07-无重复字符串的排列组合" class="headerlink" title="面试题 08.07. 无重复字符串的排列组合"></a>面试题 08.07. 无重复字符串的排列组合</h3><p>问题地址：<a href="https://leetcode.cn/problems/permutation-i-lcci/">https://leetcode.cn/problems/permutation-i-lcci/</a></p>
<p>无重复字符串的排列组合。编写一种方法，计算某字符串的所有排列组合，字符串每个字符均不相同。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    vector&lt;string&gt; permutation(string S) &#123;
        vector&lt;string&gt; res;
        dfs(res, S, 0);
        return res;
    &#125;
    void dfs(vector&lt;string&gt;&amp; res, string&amp; S, int i) &#123;
        if (i &#x3D;&#x3D; S.length()) &#123;
            res.push_back(S);
        &#125; else &#123;
            for (int j &#x3D; i; j &lt; S.length(); ++j) &#123;
                swap(S[i], S[j]);
                dfs(res, S, i + 1);
                swap(S[i], S[j]);
            &#125;
        &#125;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="面试题-08-08-有重复字符串的排列组合"><a href="#面试题-08-08-有重复字符串的排列组合" class="headerlink" title="面试题 08.08. 有重复字符串的排列组合"></a>面试题 08.08. 有重复字符串的排列组合</h3><p>问题地址：<a href="https://leetcode.cn/problems/permutation-ii-lcci/">https://leetcode.cn/problems/permutation-ii-lcci/</a></p>
<p>有重复字符串的排列组合。编写一种方法，计算某字符串的所有排列组合。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    vector&lt;string&gt; permutation(string S) &#123;
        vector&lt;string&gt; res;
        dfs(res, S, 0);
        return res;
    &#125;
    void dfs(vector&lt;string&gt;&amp; res, string&amp; S, int i) &#123;
        if (i &#x3D;&#x3D; S.length()) &#123;
            res.push_back(S);
            return;
        &#125;
        set&lt;char&gt; hash;
        for (int j &#x3D; i; j &lt; S.length(); ++j) &#123;
            if (hash.find(S[j]) &#x3D;&#x3D; hash.end()) &#123;
                hash.insert(S[j]);
                swap(S[i], S[j]);
                dfs(res, S, i + 1);
                swap(S[i], S[j]);
            &#125;
        &#125;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="面试题-08-09-括号"><a href="#面试题-08-09-括号" class="headerlink" title="面试题 08.09. 括号"></a>面试题 08.09. 括号</h3><p>问题地址：<a href="https://leetcode.cn/problems/bracket-lcci/">https://leetcode.cn/problems/bracket-lcci/</a></p>
<p>括号。设计一种算法，打印n对括号的所有合法的（例如，开闭一一对应）组合。</p>
<p>说明：解集不能包含重复的子集。</p>
<p>例如，给出 n &#x3D; 3，生成结果为：</p>
<pre class="line-numbers language-none"><code class="language-none">[
  &quot;((()))&quot;,
  &quot;(()())&quot;,
  &quot;(())()&quot;,
  &quot;()(())&quot;,
  &quot;()()()&quot;
]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    vector&lt;string&gt; generateParenthesis(int n) &#123;
        vector&lt;string&gt; result;
        string current;
        backtrack(result, current, 0, 0, n);
        return result;
    &#125;
    void backtrack(vector&lt;string&gt;&amp; ans, string&amp; cur, int open, int close, int n) &#123;
        if (cur.size() &#x3D;&#x3D; n * 2) &#123;
            ans.push_back(cur);
            return;
        &#125;
        if (open &lt; n) &#123;
            cur.push_back(&#39;(&#39;);
            backtrack(ans, cur, open + 1, close, n);
            cur.pop_back();
        &#125;
        if (close &lt; open) &#123;
            cur.push_back(&#39;)&#39;);
            backtrack(ans, cur, open, close + 1, n);
            cur.pop_back();
        &#125;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="面试题-08-11-硬币"><a href="#面试题-08-11-硬币" class="headerlink" title="面试题 08.11. 硬币"></a>面试题 08.11. 硬币</h3><p>问题地址：<a href="https://leetcode.cn/problems/coin-lcci/">https://leetcode.cn/problems/coin-lcci/</a></p>
<p>硬币。给定数量不限的硬币，币值为25分、10分、5分和1分，编写代码计算n分有几种表示法。(结果可能会很大，你需要将结果模上1000000007)</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
private:
    static constexpr int mod &#x3D; 1000000007;
    static constexpr int coins[4] &#x3D; &#123;25, 10, 5, 1&#125;;
public:
    int waysToChange(int n) &#123;
        vector&lt;int&gt; f(n + 1);
        f[0] &#x3D; 1;
        for (int c &#x3D; 0; c &lt; 4; ++c) &#123;
            int coin &#x3D; coins[c];
            for (int i &#x3D; coin; i &lt;&#x3D; n; ++i) &#123;
                f[i] &#x3D; (f[i] + f[i - coin]) % mod;
            &#125;
        &#125;
        return f[n];
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="面试题-08-14-布尔运算"><a href="#面试题-08-14-布尔运算" class="headerlink" title="面试题 08.14. 布尔运算"></a>面试题 08.14. 布尔运算</h3><p>问题地址：<a href="https://leetcode.cn/problems/boolean-evaluation-lcci/">https://leetcode.cn/problems/boolean-evaluation-lcci/</a></p>
<p>给定一个布尔表达式和一个期望的布尔结果 result，布尔表达式由 0 (false)、1 (true)、&amp; (AND)、 | (OR) 和 ^ (XOR) 符号组成。实现一个函数，算出有几种可使该表达式得出 result 值的括号方法。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:

    int countEval(string s, int result) &#123;
        int size &#x3D; s.size();

        vector&lt;int&gt; digits;
        vector&lt;char&gt; ops;
        for(int i &#x3D; 1; i &lt; size; i+&#x3D;2)&#123;
            digits.push_back(s[i-1] - &#39;0&#39; );
            ops.push_back(s[i]);
        &#125;
        digits.push_back(s.back() - &#39;0&#39;);

        vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; dp(digits.size(), vector&lt;vector&lt;int&gt; &gt;(digits.size(), vector&lt;int&gt;(2, 0) ) );

        for(int i &#x3D; digits.size() - 1; i &gt;&#x3D; 0; i--)&#123;
            for(int j &#x3D; i; j &lt; digits.size(); j++ )&#123;
                if(i &#x3D;&#x3D; j)&#123;
                    dp[i][j][0] &#x3D; digits[i] &#x3D;&#x3D; 0;
                    dp[i][j][1] &#x3D; digits[i] &#x3D;&#x3D; 1;
                    continue;
                &#125;    
                for(int k &#x3D; i; k &lt; j; k++)&#123;
                    char op &#x3D; ops[k];

                    for(int left &#x3D; 0; left &lt; 2; left++ )&#123;
                        for(int rght &#x3D; 0; rght &lt; 2; rght++ )&#123;
                            if (getBoolAns(left, rght, op) &#x3D;&#x3D; 0 ) &#123;
                                dp[i][j][0] +&#x3D; dp[i][k][left] * dp[k+1][j][rght];
                            &#125; else&#123;
                                dp[i][j][1] +&#x3D; dp[i][k][left] * dp[k+1][j][rght];
                            &#125;
                        &#125;
                    &#125;
                &#125;
            &#125;
        &#125;
        return dp[0][digits.size() - 1][result];
    &#125;

    int getBoolAns(int val1, int val2, char op) &#123;
        switch(op)&#123;
            case &#39;&amp;&#39;:
                return val1 &amp; val2;
            case &#39;|&#39;:
                return val1 | val2;
            case &#39;^&#39;:
                return val1 ^ val2;
            
        &#125;
        return 1;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="面试题-10-02-变位词组"><a href="#面试题-10-02-变位词组" class="headerlink" title="面试题 10.02. 变位词组"></a>面试题 10.02. 变位词组</h3><p>问题地址：<a href="https://leetcode.cn/problems/group-anagrams-lcci/">https://leetcode.cn/problems/group-anagrams-lcci/</a></p>
<p>编写一种方法，对字符串数组进行排序，将所有变位词组合在一起。变位词是指字母相同，但排列不同的字符串。</p>
<p>注意：本题相对原题稍作修改</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) &#123;
        unordered_map&lt;string, vector&lt;string&gt;&gt; mp;
        for (string&amp; str : strs) &#123;
            string key &#x3D; str;
            sort(key.begin(), key.end());
            mp[key].emplace_back(str);
        &#125;
        vector&lt;vector&lt;string&gt;&gt; ans;
        for (auto it &#x3D; mp.begin(); it !&#x3D; mp.end(); ++it) &#123;
            ans.emplace_back(it-&gt;second);
        &#125;
        return ans;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="面试题-10-03-搜索旋转数组"><a href="#面试题-10-03-搜索旋转数组" class="headerlink" title="面试题 10.03. 搜索旋转数组"></a>面试题 10.03. 搜索旋转数组</h3><p>问题地址：<a href="https://leetcode.cn/problems/search-rotate-array-lcci/">https://leetcode.cn/problems/search-rotate-array-lcci/</a></p>
<p>搜索旋转数组。给定一个排序后的数组，包含n个整数，但这个数组已被旋转过很多次了，次数不详。请编写代码找出数组中的某个元素，假设数组元素原先是按升序排列的。若有多个相同元素，返回索引值最小的一个。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int search(vector&lt;int&gt;&amp; arr, int target) &#123;
        int left &#x3D; 0;
        int right &#x3D; arr.size() - 1;
        if (right &#x3D;&#x3D;  -1) return -1;
        while (left &lt; right) &#123;
            int mid &#x3D; left + (right - left) &#x2F; 2;
            if (arr[left] &lt; arr[mid]) &#123;
                if (arr[left] &lt;&#x3D; target &amp;&amp; target &lt;&#x3D; arr[mid]) &#123;
                    right &#x3D; mid;
                &#125; else &#123;
                    left &#x3D; mid + 1;
                &#125;
            &#125; else if (arr[left] &gt; arr[mid]) &#123;
                if (arr[left] &lt;&#x3D; target || target &lt;&#x3D; arr[mid]) &#123;
                    right &#x3D; mid;
                &#125; else &#123;
                    left &#x3D; mid + 1;
                &#125;
            &#125; else if (arr[left] &#x3D;&#x3D; arr[mid]) &#123;
                if (arr[left] !&#x3D; target) &#123;
                    left++;
                &#125; else &#123;
                    right &#x3D; left;
                &#125;
            &#125;
        &#125;
        return (arr[left] &#x3D;&#x3D; target) ? left : -1;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="面试题-10-09-排序矩阵查找"><a href="#面试题-10-09-排序矩阵查找" class="headerlink" title="面试题 10.09. 排序矩阵查找"></a>面试题 10.09. 排序矩阵查找</h3><p>问题地址：<a href="https://leetcode.cn/problems/sorted-matrix-search-lcci/">https://leetcode.cn/problems/sorted-matrix-search-lcci/</a></p>
<p>给定M×N矩阵，每一行、每一列都按升序排列，请编写代码找出某元素。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123;
        if (matrix.size() &#x3D;&#x3D; 0 || matrix[0].size() &#x3D;&#x3D; 0) &#123;
            return false;
        &#125;
        for (const auto&amp; row : matrix) &#123;
            for (auto element : row) &#123;
                if (element &#x3D;&#x3D; target) &#123;
                    return true;
                &#125;
            &#125;
        &#125;
        return false;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="面试题-10-10-数字流的秩"><a href="#面试题-10-10-数字流的秩" class="headerlink" title="面试题 10.10. 数字流的秩"></a>面试题 10.10. 数字流的秩</h3><p>问题地址：<a href="https://leetcode.cn/problems/rank-from-stream-lcci/">https://leetcode.cn/problems/rank-from-stream-lcci/</a></p>
<p>假设你正在读取一串整数。每隔一段时间，你希望能找出数字 x 的秩(小于或等于 x 的值的个数)。请实现数据结构和算法来支持这些操作，也就是说：</p>
<p>实现 track(int x) 方法，每读入一个数字都会调用该方法；</p>
<p>实现 getRankOfNumber(int x) 方法，返回小于或等于 x 的值的个数。</p>
<p>注意：本题相对原题稍作改动</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class StreamRank &#123;
private:
    vector&lt;int&gt; v;
public:
    StreamRank() &#123;&#125;
    
    void track(int x) &#123;
        auto it &#x3D; upper_bound(v.begin(), v.end(), x);
        v.insert(it, x);
    &#125;
    
    int getRankOfNumber(int x) &#123;
        return upper_bound(v.begin(), v.end(), x) - v.begin();
    &#125;
&#125;;

&#x2F;**
 * Your StreamRank object will be instantiated and called as such:
 * StreamRank* obj &#x3D; new StreamRank();
 * obj-&gt;track(x);
 * int param_2 &#x3D; obj-&gt;getRankOfNumber(x);
 *&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="面试题-10-11-峰与谷"><a href="#面试题-10-11-峰与谷" class="headerlink" title="面试题 10.11. 峰与谷"></a>面试题 10.11. 峰与谷</h3><p>问题地址：<a href="https://leetcode.cn/problems/peaks-and-valleys-lcci/">https://leetcode.cn/problems/peaks-and-valleys-lcci/</a></p>
<p>在一个整数数组中，“峰”是大于或等于相邻整数的元素，相应地，“谷”是小于或等于相邻整数的元素。例如，在数组{5, 8, 4, 2, 3, 4, 6}中，{8, 6}是峰， {5, 2}是谷。现在给定一个整数数组，将该数组按峰与谷的交替顺序排序。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    void wiggleSort(vector&lt;int&gt;&amp; nums) &#123;
        for (int i &#x3D; 1; i &lt; nums.size(); i++) &#123;
            if (i % 2 &#x3D;&#x3D; 0) &#123;
                if (nums[i] &lt; nums[i - 1]) swap(nums[i], nums[i - 1]);
            &#125; else &#123;
                if (nums[i] &gt; nums[i - 1]) swap(nums[i], nums[i - 1]);
            &#125;
        &#125;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="面试题-16-01-交换数字"><a href="#面试题-16-01-交换数字" class="headerlink" title="面试题 16.01. 交换数字"></a>面试题 16.01. 交换数字</h3><p>问题地址：<a href="https://leetcode.cn/problems/swap-numbers-lcci/">https://leetcode.cn/problems/swap-numbers-lcci/</a></p>
<p>编写一个函数，不用临时变量，直接交换numbers &#x3D; [a, b]中a与b的值。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    vector&lt;int&gt; swapNumbers(vector&lt;int&gt;&amp; numbers) &#123;
        numbers[0] ^&#x3D; numbers[1];
        numbers[1] ^&#x3D; numbers[0];
        numbers[0] ^&#x3D; numbers[1];
        return numbers;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="面试题-16-02-单词频率"><a href="#面试题-16-02-单词频率" class="headerlink" title="面试题 16.02. 单词频率"></a>面试题 16.02. 单词频率</h3><p>问题地址：<a href="https://leetcode.cn/problems/words-frequency-lcci/">https://leetcode.cn/problems/words-frequency-lcci/</a></p>
<p>设计一个方法，找出任意指定单词在一本书中的出现频率。</p>
<p>你的实现应该支持如下操作：</p>
<ul>
<li>WordsFrequency(book)构造函数，参数为字符串数组构成的一本书</li>
<li>get(word)查询指定单词在书中出现的频率</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class WordsFrequency &#123;
private:
    unordered_map&lt;string, int&gt; map;
public:
    WordsFrequency(vector&lt;string&gt;&amp; book) &#123;
        for (auto word : book) map[word]++;
    &#125;
    
    int get(string word) &#123;
        return map[word];
    &#125;
&#125;;

&#x2F;**
 * Your WordsFrequency object will be instantiated and called as such:
 * WordsFrequency* obj &#x3D; new WordsFrequency(book);
 * int param_1 &#x3D; obj-&gt;get(word);
 *&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="面试题-16-04-井字游戏"><a href="#面试题-16-04-井字游戏" class="headerlink" title="面试题 16.04. 井字游戏"></a>面试题 16.04. 井字游戏</h3><p>问题地址：<a href="https://leetcode.cn/problems/tic-tac-toe-lcci/">https://leetcode.cn/problems/tic-tac-toe-lcci/</a></p>
<p>设计一个算法，判断玩家是否赢了井字游戏。输入是一个 N x N 的数组棋盘，由字符” “，”X”和”O”组成，其中字符” “代表一个空位。</p>
<p>以下是井字游戏的规则：</p>
<ul>
<li>玩家轮流将字符放入空位（” “）中。</li>
<li>第一个玩家总是放字符”O”，且第二个玩家总是放字符”X”。</li>
<li>“X”和”O”只允许放置在空位中，不允许对已放有字符的位置进行填充。</li>
<li>当有N个相同（且非空）的字符填充任何行、列或对角线时，游戏结束，对应该字符的玩家获胜。</li>
<li>当所有位置非空时，也算为游戏结束。</li>
<li>如果游戏结束，玩家不允许再放置字符。</li>
</ul>
<p>如果游戏存在获胜者，就返回该游戏的获胜者使用的字符（”X”或”O”）；如果游戏以平局结束，则返回 “Draw”；如果仍会有行动（游戏未结束），则返回 “Pending”。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    string tictactoe(vector&lt;string&gt;&amp; board) &#123;
        auto n &#x3D; board.size();
        int row_sum &#x3D; 0, col_sum &#x3D; 0, left_dia_sum &#x3D; 0, right_dia_sum &#x3D; 0, isFull &#x3D; 1;
        for (auto i &#x3D; 0; i &lt; n; i++) &#123;
            row_sum &#x3D; 0, col_sum &#x3D; 0;
            left_dia_sum +&#x3D; board[i][i];
            right_dia_sum +&#x3D; board[i][n - 1 - i];
            for (auto j &#x3D; 0; j &lt; n; j++) &#123;
                row_sum +&#x3D; board[i][j];
                col_sum +&#x3D; board[j][i];
                if (board[i][j] &#x3D;&#x3D; &#39; &#39;) isFull &#x3D; 0;
            &#125;
            if (row_sum &#x3D;&#x3D; ((int)&#39;X&#39;) * n || col_sum &#x3D;&#x3D; ((int)&#39;X&#39;) * n) &#123;
                return string(&quot;X&quot;);
            &#125;
            if (row_sum &#x3D;&#x3D; ((int)&#39;O&#39;) * n || col_sum &#x3D;&#x3D; ((int)&#39;O&#39;) * n) &#123;
                return string(&quot;O&quot;);
            &#125;
        &#125;
        if (left_dia_sum &#x3D;&#x3D; ((int)&#39;X&#39;) * n || right_dia_sum &#x3D;&#x3D; ((int)&#39;X&#39;) * n) &#123;
            return string(&quot;X&quot;);
        &#125;
        if (left_dia_sum &#x3D;&#x3D; ((int)&#39;O&#39;) * n || right_dia_sum &#x3D;&#x3D; ((int)&#39;O&#39;) * n) &#123;
            return string(&quot;O&quot;);
        &#125;
        if (isFull) &#123;
            return string(&quot;Draw&quot;);
        &#125; else &#123;
            return string(&quot;Pending&quot;);
        &#125;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="面试题-16-06-最小差"><a href="#面试题-16-06-最小差" class="headerlink" title="面试题 16.06. 最小差"></a>面试题 16.06. 最小差</h3><p>问题地址：<a href="https://leetcode.cn/problems/smallest-difference-lcci/">https://leetcode.cn/problems/smallest-difference-lcci/</a></p>
<p>给定两个整数数组a和b，计算具有最小差绝对值的一对数值（每个数组中取一个值），并返回该对数值的差</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int smallestDifference(vector&lt;int&gt;&amp; a, vector&lt;int&gt;&amp; b) &#123;
        sort(a.begin(), a.end());
        sort(b.begin(), b.end());
        int na &#x3D; a.size();
        int i &#x3D; 0;
        int nb &#x3D; b.size();
        int j &#x3D; 0;
        long res &#x3D; LONG_MAX;
        while (i &lt; na &amp;&amp; j &lt; nb) &#123;
            if (a[i] !&#x3D; b[j]) &#123;
                res &#x3D; min(res, abs((long)a[i] - (long)b[j]));
                a[i] &gt; b[j] ? ++j : ++i;
            &#125; else &#123;
                return 0;
            &#125;
        &#125;
        return res;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="面试题-16-09-运算"><a href="#面试题-16-09-运算" class="headerlink" title="面试题 16.09. 运算"></a>面试题 16.09. 运算</h3><p>问题地址：<a href="https://leetcode.cn/problems/operations-lcci/">https://leetcode.cn/problems/operations-lcci/</a></p>
<p>请实现整数数字的乘法、减法和除法运算，运算结果均为整数数字，程序中只允许使用加法运算符和逻辑运算符，允许程序中出现正负常数，不允许使用位运算。</p>
<p>你的实现应该支持如下操作：</p>
<ul>
<li>Operations() 构造函数</li>
<li>minus(a, b) 减法，返回a - b</li>
<li>multiply(a, b) 乘法，返回a * b</li>
<li>divide(a, b) 除法，返回a &#x2F; b</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Operations &#123;
private:
    vector&lt;int&gt; negs, poss;

    int neg(int a) &#123;
        if (!a) return 0;
        int result &#x3D; 0;
        if (a &gt; 0) &#123;
            for (auto p &#x3D; negs.rbegin(); p !&#x3D; negs.rend(); p++) &#123;
                if (*p + a &lt; 0) continue;
                a +&#x3D; *p;
                result +&#x3D; *p;
            &#125;
        &#125; else &#123;
            for (auto p &#x3D; poss.rbegin(); p !&#x3D; poss.rend(); p++) &#123;
                if (*p + a &gt; 0) continue;
                a +&#x3D; *p;
                result +&#x3D; *p;
            &#125;
        &#125;
        return result;
    &#125;
public:
    Operations() &#123;
        int p &#x3D; 1, n &#x3D; -1;
        poss.push_back(p);
        negs.push_back(n);

        for (auto i &#x3D; 0; i &lt; 30; i++) &#123;
            p +&#x3D; p;
            n +&#x3D; n;

            poss.push_back(p);
            negs.push_back(n);
        &#125;
    &#125;
    
    int minus(int a, int b) &#123;
        return a + neg(b);
    &#125;
    
    int multiply(int a, int b) &#123;
        if (!a || !b) return 0;
        if (a &#x3D;&#x3D; 1) return b;
        if (b &lt; 0) return neg(multiply(a, neg(b)));

        int result &#x3D; a;
        int times &#x3D; 1;

        while (times &lt; poss[30] &amp;&amp; times + times &lt;&#x3D; b) &#123;
            result +&#x3D; result;
            times +&#x3D; times;
        &#125;
        result +&#x3D; multiply(a, minus(b, times));
        return result;
    &#125;
    
    int divide(int a, int b) &#123;
        if (!a) return 0;
        int result &#x3D; 1;
        if (a &gt; 0) &#123;
            if (b &#x3D;&#x3D; INT_MIN) return 0;
            if (b &lt; 0) return neg(divide(a, neg(b)));
            if (a &lt; b) return 0;

            int acc &#x3D; b;
            while (acc &lt; poss[30] &amp;&amp; a &gt;&#x3D; acc + acc) &#123;
                result +&#x3D; result;
                acc +&#x3D; acc;
            &#125;
            result +&#x3D; divide(minus(a, acc), b);
        &#125; else &#123;
            if (b &#x3D;&#x3D; 1) return a;
            if (b &gt; 0) return neg(divide(a, neg(b)));
            if (a &gt; b) return 0;

            int acc &#x3D; b;
            while (acc &gt;&#x3D; negs[30] &amp;&amp; a &lt;&#x3D; acc + acc) &#123;
                result +&#x3D; result;
                acc +&#x3D; acc;
            &#125;
            result +&#x3D; divide(minus(a, acc), b);
        &#125;
        return result;
    &#125;
&#125;;

&#x2F;**
 * Your Operations object will be instantiated and called as such:
 * Operations* obj &#x3D; new Operations();
 * int param_1 &#x3D; obj-&gt;minus(a,b);
 * int param_2 &#x3D; obj-&gt;multiply(a,b);
 * int param_3 &#x3D; obj-&gt;divide(a,b);
 *&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="面试题-16-10-生存人数"><a href="#面试题-16-10-生存人数" class="headerlink" title="面试题 16.10. 生存人数"></a>面试题 16.10. 生存人数</h3><p>问题地址：<a href="https://leetcode.cn/problems/living-people-lcci/">https://leetcode.cn/problems/living-people-lcci/</a></p>
<p>给定 N 个人的出生年份和死亡年份，第 i 个人的出生年份为 birth[i]，死亡年份为 death[i]，实现一个方法以计算生存人数最多的年份。</p>
<p>你可以假设所有人都出生于 1900 年至 2000 年（含 1900 和 2000 ）之间。如果一个人在某一年的任意时期处于生存状态，那么他应该被纳入那一年的统计中。例如，生于 1908 年、死于 1909 年的人应当被列入 1908 年和 1909 年的计数。</p>
<p>如果有多个年份生存人数相同且均为最大值，输出其中最小的年份。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int maxAliveYear(vector&lt;int&gt;&amp; birth, vector&lt;int&gt;&amp; death) &#123;
        int n &#x3D; birth.size();
        vector&lt;int&gt; a(2002, 0);
        for (auto i &#x3D; 0; i &lt; n; i++) &#123;
            int x &#x3D; birth[i], y &#x3D; death[i];
            a[x] +&#x3D; 1; a[y+1] -&#x3D; 1;
        &#125;
        int mx &#x3D; 0, year &#x3D; 0, sum(0);
        for (auto i &#x3D; 1900; i &lt;&#x3D; 2000; ++i) &#123;
            sum +&#x3D; a[i];
            if (mx &lt; sum) &#123;
                mx &#x3D; sum;
                year &#x3D; i;
            &#125;
        &#125;
        return year;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="面试题-16-21-交换和"><a href="#面试题-16-21-交换和" class="headerlink" title="面试题 16.21. 交换和"></a>面试题 16.21. 交换和</h3><p>问题地址：<a href="https://leetcode.cn/problems/sum-swap-lcci/">https://leetcode.cn/problems/sum-swap-lcci/</a></p>
<p>给定两个整数数组，请交换一对数值（每个数组中取一个数值），使得两个数组所有元素的和相等。</p>
<p>返回一个数组，第一个元素是第一个数组中要交换的元素，第二个元素是第二个数组中要交换的元素。若有多个答案，返回任意一个均可。若无满足条件的数值，返回空数组。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    vector&lt;int&gt; findSwapValues(vector&lt;int&gt;&amp; array1, vector&lt;int&gt;&amp; array2) &#123;
        int sum1 &#x3D; 0, sum2 &#x3D; 0;
        for (auto num : array1) sum1 +&#x3D; num;
        for (auto num : array2) sum2 +&#x3D; num;
        if ((sum1 - sum2) % 2) return &#123;&#125;;
        unordered_set&lt;int&gt; set(array2.begin(), array2.end());
        const int diff &#x3D; (sum1 - sum2) &#x2F; 2;
        for (auto x : array1) &#123;
            auto y &#x3D; x - diff;
            if (set.count(y)) return &#123;x, y&#125;;
        &#125;
        return &#123;&#125;;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="面试题-16-24-数对和"><a href="#面试题-16-24-数对和" class="headerlink" title="面试题 16.24. 数对和"></a>面试题 16.24. 数对和</h3><p>问题地址：<a href="https://leetcode.cn/problems/pairs-with-sum-lcci/">https://leetcode.cn/problems/pairs-with-sum-lcci/</a></p>
<p>设计一个算法，找出数组中两数之和为指定值的所有整数对。一个数只能属于一个数对。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    vector&lt;vector&lt;int&gt;&gt; pairSums(vector&lt;int&gt;&amp; nums, int target) &#123;
        sort(nums.begin(), nums.end());
        int l &#x3D; 0;
        int r &#x3D; nums.size() - 1;
        vector&lt;vector&lt;int&gt;&gt; ret;
        while (l &lt; r) &#123;
            if (nums[l] + nums[r] &#x3D;&#x3D; target) &#123;
                ret.push_back(&#123;nums[l], nums[r]&#125;);
                l++;
                r--;
            &#125; else if (nums[l] + nums[r] &gt; target) &#123;
                r--;
            &#125; else &#123;
                l++;
            &#125;
        &#125;
        return ret;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="40-组合总和-II"><a href="#40-组合总和-II" class="headerlink" title="40. 组合总和 II"></a>40. 组合总和 II</h3><p>问题地址：<a href="https://leetcode.cn/problems/combination-sum-ii/">https://leetcode.cn/problems/combination-sum-ii/</a></p>
<p>给定一个候选人编号的集合 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p>
<p>candidates 中的每个数字在每个组合中只能使用 一次 。</p>
<p>注意：解集不能包含重复的组合。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
private:
    vector&lt;int&gt; candidates;
    vector&lt;vector&lt;int&gt;&gt; res;
    vector&lt;int&gt; path;
public:
    vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) &#123;
        sort(candidates.begin(), candidates.end());
        this-&gt;candidates &#x3D; candidates;
        dfs(0, target);
        return res;
    &#125;
    void dfs(int start, int target) &#123;
        if (target &#x3D;&#x3D; 0) &#123;
            res.push_back(path);
            return;
        &#125;
        for (auto i &#x3D; start; i &lt; candidates.size() &amp;&amp; target - candidates[i] &gt;&#x3D; 0; i++) &#123;
            if (i &gt; start &amp;&amp; candidates[i] &#x3D;&#x3D; candidates[i - 1]) continue;
            path.push_back(candidates[i]);
            dfs(i + 1, target - candidates[i]);
            path.pop_back();
        &#125;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="47-全排列-II"><a href="#47-全排列-II" class="headerlink" title="47. 全排列 II"></a>47. 全排列 II</h3><p>问题地址：<a href="https://leetcode.cn/problems/permutations-ii/">https://leetcode.cn/problems/permutations-ii/</a></p>
<p>给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
private:
    vector&lt;int&gt; vis;
public:
    vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) &#123;
        vector&lt;vector&lt;int&gt;&gt; ans;
        vector&lt;int&gt; perm;
        vis.resize(nums.size());
        sort(nums.begin(), nums.end());
        backtrack(nums, ans, 0, perm);
        return ans;
    &#125;
    void backtrack(vector&lt;int&gt;&amp; nums, vector&lt;vector&lt;int&gt;&gt;&amp; ans, int idx, vector&lt;int&gt;&amp; perm) &#123;
        if (idx &#x3D;&#x3D; nums.size()) &#123;
            ans.emplace_back(perm);
            return;
        &#125;
        for (int i &#x3D; 0; i &lt; (int)nums.size(); ++i) &#123;
            if (vis[i] || (i &gt; 0 &amp;&amp; nums[i] &#x3D;&#x3D; nums[i - 1] &amp;&amp; !vis[i - 1])) &#123;
                continue;
            &#125;
            perm.emplace_back(nums[i]);
            vis[i] &#x3D; 1;
            backtrack(nums, ans, idx + 1, perm);
            vis[i] &#x3D; 0;
            perm.pop_back();
        &#125;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="75-颜色分类"><a href="#75-颜色分类" class="headerlink" title="75. 颜色分类"></a>75. 颜色分类</h3><p>问题地址：<a href="https://leetcode.cn/problems/sort-colors/">https://leetcode.cn/problems/sort-colors/</a></p>
<p>给定一个包含红色、白色和蓝色、共 n 个元素的数组 nums ，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p>
<p>我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p>
<p>必须在不使用库内置的 sort 函数的情况下解决这个问题。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    void sortColors(vector&lt;int&gt;&amp; nums) &#123;
        int n &#x3D; nums.size();
        int ptr &#x3D; 0;
        for (auto i &#x3D; 0; i &lt; n; ++i) &#123;
            if (nums[i] &#x3D;&#x3D; 0) &#123;
                swap(nums[i], nums[ptr]);
                ++ptr;
            &#125;
        &#125;
        for (auto i &#x3D; ptr; i &lt; n; ++i) &#123;
            if (nums[i] &#x3D;&#x3D; 1) &#123;
                swap(nums[i], nums[ptr]);
                ++ptr;
            &#125;
        &#125;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="90-子集-II"><a href="#90-子集-II" class="headerlink" title="90. 子集 II"></a>90. 子集 II</h3><p>问题地址：<a href="https://leetcode.cn/problems/subsets-ii/">https://leetcode.cn/problems/subsets-ii/</a></p>
<p>给你一个整数数组 nums ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。</p>
<p>解集 不能 包含重复的子集。返回的解集中，子集可以按 任意顺序 排列。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    vector&lt;vector&lt;int&gt;&gt; subsetsWithDup(vector&lt;int&gt;&amp; nums) &#123;
        sort(nums.begin(), nums.end());
        int n &#x3D; nums.size();
        vector&lt;vector&lt;int&gt;&gt; res;
        vector&lt;int&gt; tmp;

        function&lt;void(int)&gt; dfs &#x3D; [&amp;](int idx) &#123;
            res.push_back(tmp);
            for (int i &#x3D; idx; i &lt; n; ++i) &#123;
                if (i - 1 &gt;&#x3D; idx &amp;&amp; nums[i - 1] &#x3D;&#x3D; nums[i]) continue;
                tmp.push_back(nums[i]);
                dfs(i + 1);
                tmp.pop_back();
            &#125;
        &#125;;
         dfs(0);
         return res;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="LCR-121-寻找目标值-二维数组"><a href="#LCR-121-寻找目标值-二维数组" class="headerlink" title="LCR 121. 寻找目标值 - 二维数组"></a>LCR 121. 寻找目标值 - 二维数组</h3><p>问题地址：<a href="https://leetcode.cn/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/">https://leetcode.cn/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/</a></p>
<p>m*n 的二维数组 plants 记录了园林景观的植物排布情况，具有以下特性：</p>
<ul>
<li>每行中，每棵植物的右侧相邻植物不矮于该植物；</li>
<li>每列中，每棵植物的下侧相邻植物不矮于该植物。</li>
</ul>
<p>请判断 plants 中是否存在目标高度值 target。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    bool findTargetIn2DPlants(vector&lt;vector&lt;int&gt;&gt;&amp; plants, int target) &#123;
        int i &#x3D; plants.size() - 1, j &#x3D; 0;
        while (i &gt;&#x3D; 0 &amp;&amp; j &lt; plants[0].size()) &#123;
            if (plants[i][j] &gt; target) i--;
            else if (plants[i][j] &lt; target) j++;
            else return true;
        &#125;
        return false;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="347-前-K-个高频元素"><a href="#347-前-K-个高频元素" class="headerlink" title="347. 前 K 个高频元素"></a>347. 前 K 个高频元素</h3><p>问题地址：<a href="https://leetcode.cn/problems/top-k-frequent-elements/">https://leetcode.cn/problems/top-k-frequent-elements/</a></p>
<p>给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按 任意顺序 返回答案。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
private:
    static bool cmp(pair&lt;int, int&gt;&amp; m, pair&lt;int, int&gt;&amp; n) &#123;
        return m.second &gt; n.second;
    &#125;
public:
    vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) &#123;
        unordered_map&lt;int, int&gt; occurrences;
        for (auto&amp; v : nums) &#123;
            occurrences[v]++;
        &#125;

        priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, decltype(&amp;cmp)&gt; q(cmp);
        for (auto&amp; [num, count] : occurrences) &#123;
            if (q.size() &#x3D;&#x3D; k) &#123;
                if (q.top().second &lt; count) &#123;
                    q.pop();
                    q.emplace(num, count);
                &#125;
            &#125; else &#123;
                q.emplace(num, count);
            &#125;
        &#125;
        vector&lt;int&gt; ret;
        while (!q.empty()) &#123;
            ret.emplace_back(q.top().first);
            q.pop();
        &#125;
        return ret;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="438-找到字符串中所有字母异位词"><a href="#438-找到字符串中所有字母异位词" class="headerlink" title="438. 找到字符串中所有字母异位词"></a>438. 找到字符串中所有字母异位词</h3><p>问题地址：<a href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/">https://leetcode.cn/problems/find-all-anagrams-in-a-string/</a></p>
<p>给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。</p>
<p>异位词 指由相同字母重排列形成的字符串（包括相同的字符串）。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    vector&lt;int&gt; findAnagrams(string s, string p) &#123;
        int sLen &#x3D; s.size(), pLen &#x3D; p.size();

        if (sLen &lt; pLen) &#123;
            return vector&lt;int&gt;();
        &#125;

        vector&lt;int&gt; ans;
        vector&lt;int&gt; sCount(26);
        vector&lt;int&gt; pCount(26);
        for (auto i &#x3D; 0; i &lt; pLen; ++i) &#123;
            ++sCount[s[i] - &#39;a&#39;];
            ++pCount[p[i] - &#39;a&#39;];
        &#125;

        if (sCount &#x3D;&#x3D; pCount) &#123;
            ans.emplace_back(0);
        &#125;

        for (int i &#x3D; 0; i &lt; sLen - pLen; ++i) &#123;
            --sCount[s[i] - &#39;a&#39;];
            ++sCount[s[i + pLen] - &#39;a&#39;];

            if (sCount &#x3D;&#x3D; pCount) &#123;
                ans.emplace_back(i + 1);
            &#125;
        &#125;

        return ans;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="560-和为-K-的子数组"><a href="#560-和为-K-的子数组" class="headerlink" title="560. 和为 K 的子数组"></a>560. 和为 K 的子数组</h3><p>问题地址：<a href="https://leetcode.cn/problems/subarray-sum-equals-k/">https://leetcode.cn/problems/subarray-sum-equals-k/</a></p>
<p>给你一个整数数组 nums 和一个整数 k ，请你统计并返回 该数组中和为 k 的子数组的个数 。</p>
<p>子数组是数组中元素的连续非空序列。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int subarraySum(vector&lt;int&gt;&amp; nums, int k) &#123;
        unordered_map&lt;int, int&gt; mp;
        mp[0] &#x3D; 1;
        int count &#x3D; 0, pre &#x3D; 0;
        for (auto&amp; x : nums) &#123;
            pre +&#x3D; x;
            if (mp.find(pre - k) !&#x3D; mp.end()) &#123;
                count +&#x3D; mp[pre - k];
            &#125;
            mp[pre]++;
        &#125;
        return count++;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="240-搜索二维矩阵-II"><a href="#240-搜索二维矩阵-II" class="headerlink" title="240. 搜索二维矩阵 II"></a>240. 搜索二维矩阵 II</h3><p>问题地址：<a href="https://leetcode.cn/problems/search-a-2d-matrix-ii/">https://leetcode.cn/problems/search-a-2d-matrix-ii/</a></p>
<p>编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target 。该矩阵具有以下特性：</p>
<ul>
<li>每行的元素从左到右升序排列。</li>
<li>每列的元素从上到下升序排列。</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123;
        int r &#x3D; matrix.size(), c &#x3D; matrix[0].size();
        int i &#x3D; 0, j &#x3D; c - 1;
        while (i &lt; r &amp;&amp; j &gt; -1) &#123;
            if (matrix[i][j] &#x3D;&#x3D; target) &#123;
                return true;
            &#125;
            if (matrix[i][j] &gt; target) &#123;
                --j;
            &#125;
            else &#123;
                ++i;
            &#125;
        &#125;
        return false;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="131-分割回文串"><a href="#131-分割回文串" class="headerlink" title="131. 分割回文串"></a>131. 分割回文串</h3><p>问题地址：<a href="https://leetcode.cn/problems/palindrome-partitioning/">https://leetcode.cn/problems/palindrome-partitioning/</a></p>
<p>给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是 回文串 。返回 s 所有可能的分割方案。</p>
<p>回文串 是正着读和反着读都一样的字符串。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
private:
    vector&lt;vector&lt;int&gt;&gt; f;
    vector&lt;vector&lt;string&gt;&gt; ret;
    vector&lt;string&gt; ans;
    int n;

public:
    void dfs(const string&amp; s, int i) &#123;
        if (i &#x3D;&#x3D; n) &#123;
            ret.push_back(ans);
            return;
        &#125;
        for (int j &#x3D; i; j &lt; n; ++j) &#123;
            if (f[i][j]) &#123;
                ans.push_back(s.substr(i, j - i + 1));
                dfs(s, j + 1);
                ans.pop_back();
            &#125;
        &#125;
    &#125;

    vector&lt;vector&lt;string&gt;&gt; partition(string s) &#123;
        n &#x3D; s.size();
        f.assign(n, vector&lt;int&gt;(n, true));

        for (int i &#x3D; n - 1; i &gt;&#x3D; 0; --i) &#123;
            for (int j &#x3D; i + 1; j &lt; n; ++j) &#123;
                f[i][j] &#x3D; (s[i] &#x3D;&#x3D; s[j]) &amp;&amp; f[i + 1][j - 1];
            &#125;
        &#125;

        dfs(s, 0);
        return ret;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="763-划分字母区间"><a href="#763-划分字母区间" class="headerlink" title="763. 划分字母区间"></a>763. 划分字母区间</h3><p>问题地址：<a href="https://leetcode.cn/problems/partition-labels/">https://leetcode.cn/problems/partition-labels/</a></p>
<p>给你一个字符串 s 。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。</p>
<p>注意，划分结果需要满足：将所有划分结果按顺序连接，得到的字符串仍然是 s 。</p>
<p>返回一个表示每个字符串片段的长度的列表。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    vector&lt;int&gt; partitionLabels(string s) &#123;
        int last[26];
        int length &#x3D; s.size();
        for (int i &#x3D; 0; i &lt; length; i++) &#123;
            last[s[i] - &#39;a&#39;] &#x3D; i;
        &#125;
        vector&lt;int&gt; partition;
        int start &#x3D; 0, end &#x3D; 0;
        for (int i &#x3D; 0; i &lt; length; i++) &#123;
            end &#x3D; max(end, last[s[i] - &#39;a&#39;]);
            if (i &#x3D;&#x3D; end) &#123;
                partition.push_back(end - start + 1);
                start &#x3D; end + 1;
            &#125;
        &#125;
        return partition;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="279-完全平方数"><a href="#279-完全平方数" class="headerlink" title="279. 完全平方数"></a>279. 完全平方数</h3><p>问题地址：<a href="https://leetcode.cn/problems/perfect-squares/">https://leetcode.cn/problems/perfect-squares/</a></p>
<p>给你一个整数 n ，返回 和为 n 的完全平方数的最少数量 。</p>
<p>完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int numSquares(int n) &#123;
        vector&lt;int&gt; f(n + 1);
        for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;
            int minn &#x3D; INT_MAX;
            for (int j &#x3D; 1; j * j &lt;&#x3D; i; j++) &#123;
                minn &#x3D; min(minn, f[i - j * j]);
            &#125;
            f[i] &#x3D; minn + 1;
        &#125;
        return f[n];
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="287-寻找重复数"><a href="#287-寻找重复数" class="headerlink" title="287. 寻找重复数"></a>287. 寻找重复数</h3><p>问题地址：<a href="https://leetcode.cn/problems/find-the-duplicate-number/">https://leetcode.cn/problems/find-the-duplicate-number/</a></p>
<p>给定一个包含 n + 1 个整数的数组 nums ，其数字都在 [1, n] 范围内（包括 1 和 n），可知至少存在一个重复的整数。</p>
<p>假设 nums 只有 一个重复的整数 ，返回 这个重复的数 。</p>
<p>你设计的解决方案必须 不修改 数组 nums 且只用常量级 O(1) 的额外空间。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int findDuplicate(vector&lt;int&gt;&amp; nums) &#123;
        unordered_map&lt;int, bool&gt; map;
        for (auto num : nums) &#123;
            if (map[num]) return num;
            map[num] &#x3D; true;
        &#125;
        return -1;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="152-乘积最大子数组"><a href="#152-乘积最大子数组" class="headerlink" title="152. 乘积最大子数组"></a>152. 乘积最大子数组</h3><p>问题地址：<a href="https://leetcode.cn/problems/maximum-product-subarray/">https://leetcode.cn/problems/maximum-product-subarray/</a></p>
<p>给你一个整数数组 nums ，请你找出数组中乘积最大的非空连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</p>
<p>测试用例的答案是一个 32-位 整数。</p>
<p>子数组 是数组的连续子序列。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int maxProduct(vector&lt;int&gt;&amp; nums) &#123;
        vector&lt;int&gt; maxF(nums), minF(nums);
        for (int i &#x3D; 1; i &lt; nums.size(); ++i) &#123;
            maxF[i] &#x3D; max(maxF[i - 1] * nums[i], max(nums[i], minF[i - 1] * nums[i]));
            minF[i] &#x3D; min(minF[i - 1] * nums[i], min(nums[i], maxF[i - 1] * nums[i]));
        &#125;
        return *max_element(maxF.begin(), maxF.end());
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="416-分割等和子集"><a href="#416-分割等和子集" class="headerlink" title="416. 分割等和子集"></a>416. 分割等和子集</h3><p>问题地址：<a href="https://leetcode.cn/problems/partition-equal-subset-sum/">https://leetcode.cn/problems/partition-equal-subset-sum/</a></p>
<p>给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    bool canPartition(vector&lt;int&gt;&amp; nums) &#123;
        int n &#x3D; nums.size(), m &#x3D; 0;
        for (auto x : nums) m +&#x3D; x;
        if (m % 2) return false;
        m &#x2F;&#x3D; 2;
        vector&lt;bool&gt; f(m + 1);
        f[0] &#x3D; true;
        for (auto i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;
            for (auto j &#x3D; m; j &gt;&#x3D; nums[i - 1]; j--) &#123;
                f[j] &#x3D; f[j] || f[j - nums[i - 1]];
            &#125;
        &#125;
        return f[m];
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="困难"><a href="#困难" class="headerlink" title="困难"></a>困难</h2><h3 id="220-存在重复元素-III"><a href="#220-存在重复元素-III" class="headerlink" title="220. 存在重复元素 III"></a>220. 存在重复元素 III</h3><p>问题地址：<a href="https://leetcode.cn/problems/contains-duplicate-iii/">https://leetcode.cn/problems/contains-duplicate-iii/</a></p>
<p>给你一个整数数组 <code>nums</code> 和两个整数 <code>indexDiff</code> 和 <code>valueDiff</code> 。</p>
<p>找出满足下述条件的下标对 <code>(i, j)</code>：</p>
<ul>
<li><code>i != j</code>,</li>
<li><code>abs(i - j) &lt;= indexDiff</code></li>
<li><code>abs(nums[i] - nums[j]) &lt;= valueDiff</code></li>
</ul>
<p>如果存在，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int getID(int x, long w) &#123;
        return x &lt; 0 ? (x + 1ll) &#x2F; w - 1 : x &#x2F; w;
    &#125;

    bool containsNearbyAlmostDuplicate(vector&lt;int&gt;&amp; nums, int k, int t) &#123;
        unordered_map&lt;int, int&gt; mp;
        int n &#x3D; nums.size();
        for (int i &#x3D; 0; i &lt; n; i++) &#123;
            long x &#x3D; nums[i];
            int id &#x3D; getID(x, t + 1ll);
            if (mp.count(id)) &#123;
                return true;
            &#125;
            if (mp.count(id - 1) &amp;&amp; abs(x - mp[id - 1]) &lt;&#x3D; t) &#123;
                return true;
            &#125;
            if (mp.count(id + 1) &amp;&amp; abs(x - mp[id + 1]) &lt;&#x3D; t) &#123;
                return true;
            &#125;
            mp[id] &#x3D; x;
            if (i &gt;&#x3D; k) &#123;
                mp.erase(getID(nums[i - k], t + 1ll));
            &#125;
        &#125;
        return false;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="140-单词拆分-II"><a href="#140-单词拆分-II" class="headerlink" title="140. 单词拆分 II"></a>140. 单词拆分 II</h3><p>问题地址：<a href="https://leetcode.cn/problems/word-break-ii/">https://leetcode.cn/problems/word-break-ii/</a></p>
<p>给定一个字符串 <code>s</code> 和一个字符串字典 <code>wordDict</code> ，在字符串 <code>s</code> 中增加空格来构建一个句子，使得句子中所有的单词都在词典中。<code>以任意顺序</code> 返回所有这些可能的句子。</p>
<p><code>注意：</code>词典中的同一个单词可能在分段中被重复使用多次。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
private:
    unordered_map&lt;int, vector&lt;string&gt;&gt; ans;
    unordered_set&lt;string&gt; wordSet;
public:
    vector&lt;string&gt; wordBreak(string s, vector&lt;string&gt;&amp; wordDict) &#123;
        wordSet &#x3D; unordered_set(wordDict.begin(), wordDict.end());
        backtrack(s, 0);
        return ans[0];
    &#125;

    void backtrack(const string&amp; s, int index) &#123;
        if (!ans.count(index)) &#123;
            if (index &#x3D;&#x3D; s.size()) &#123;
                ans[index] &#x3D; &#123;&quot;&quot;&#125;;
                return;
            &#125;
            ans[index] &#x3D; &#123;&#125;;
            for (int i &#x3D; index + 1; i &lt;&#x3D; s.size(); ++i) &#123;
                string word &#x3D; s.substr(index, i - index);
                if (wordSet.count(word)) &#123;
                    backtrack(s, i);
                    for (const string&amp; succ : ans[i]) &#123;
                        ans[index].push_back(succ.empty() ? word : word + &quot; &quot; + succ);
                    &#125;
                &#125;
            &#125;
        &#125;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="732-我的日程安排表-III"><a href="#732-我的日程安排表-III" class="headerlink" title="732. 我的日程安排表 III"></a>732. 我的日程安排表 III</h3><p>问题地址：<a href="https://leetcode.cn/problems/my-calendar-iii/">https://leetcode.cn/problems/my-calendar-iii/</a></p>
<p>当 <code>k</code> 个日程安排有一些时间上的交叉时（例如 <code>k</code> 个日程安排都在同一时间内），就会产生 <code>k</code> 次预订。</p>
<p>给你一些日程安排 <code>[start, end)</code> ，请你在每个日程安排添加后，返回一个整数 <code>k</code> ，表示所有先前日程安排会产生的最大 <code>k</code> 次预订。</p>
<p>实现一个 <code>MyCalendarThree</code> 类来存放你的日程安排，你可以一直添加新的日程安排。</p>
<ul>
<li><code>MyCalendarThree()</code> 初始化对象。</li>
<li><code>int book(int start, int end)</code> 返回一个整数 <code>k</code> ，表示日历中存在的 <code>k</code> 次预订的最大值。</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class MyCalendarThree &#123;
public:
    MyCalendarThree() &#123;
        
    &#125;
    
    int book(int start, int end) &#123;
        int ans &#x3D; 0;
        int maxBook &#x3D; 0;
        cnt[start]++;
        cnt[end]--;
        for (auto &amp;[_, freq] : cnt) &#123;
            maxBook +&#x3D; freq;
            ans &#x3D; max(maxBook, ans);
        &#125;
        return ans;
    &#125;
private:
    map&lt;int, int&gt; cnt;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="768-最多能完成排序的块-II"><a href="#768-最多能完成排序的块-II" class="headerlink" title="768. 最多能完成排序的块 II"></a>768. 最多能完成排序的块 II</h3><p>问题地址：<a href="https://leetcode.cn/problems/max-chunks-to-make-sorted-ii/">https://leetcode.cn/problems/max-chunks-to-make-sorted-ii/</a></p>
<p>给你一个整数数组 arr 。</p>
<p>将 arr 分割成若干 块 ，并将这些块分别进行排序。之后再连接起来，使得连接的结果和按升序排序后的原数组相同。</p>
<p>返回能将数组分成的最多块数？</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int maxChunksToSorted(vector&lt;int&gt;&amp; arr) &#123;
        unordered_map&lt;int, int&gt; cnt;
        int res &#x3D; 0;
        vector&lt;int&gt; sortedArr &#x3D; arr;
        sort(sortedArr.begin(), sortedArr.end());
        for (int i &#x3D; 0; i &lt; sortedArr.size(); i++) &#123;
            int x &#x3D; arr[i], y &#x3D; sortedArr[i];
            cnt[x]++;
            if (cnt[x] &#x3D;&#x3D; 0) &#123;
                cnt.erase(x);
            &#125;
            cnt[y]--;
            if (cnt[y] &#x3D;&#x3D; 0) &#123;
                cnt.erase(y);
            &#125;
            if (cnt.size() &#x3D;&#x3D; 0) &#123;
                res++;
            &#125;
        &#125;
        return res;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="4-寻找两个正序数组的中位数"><a href="#4-寻找两个正序数组的中位数" class="headerlink" title="4. 寻找两个正序数组的中位数"></a>4. 寻找两个正序数组的中位数</h3><p>问题地址：<a href="https://leetcode.cn/problems/median-of-two-sorted-arrays/">https://leetcode.cn/problems/median-of-two-sorted-arrays/</a></p>
<p>给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。</p>
<p>算法的时间复杂度应该为 O(log (m+n)) 。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;
        int m &#x3D; nums1.size(), n &#x3D; nums2.size(), i &#x3D; 0, j &#x3D; 0, l &#x3D; 0, r &#x3D; 0;
        for (int x &#x3D; 0; x &lt;&#x3D; (m + n) &#x2F; 2; x++) &#123;
            l &#x3D; r;
            r &#x3D; (i &lt; m &amp;&amp; (j &gt;&#x3D; n || nums1[i] &lt; nums2[j])) ?
                nums1[i++] : nums2[j++];
        &#125;
        return (m + n) &amp; 1 ? r : (l + r) &#x2F; 2.0;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="10-正则表达式匹配"><a href="#10-正则表达式匹配" class="headerlink" title="10. 正则表达式匹配"></a>10. 正则表达式匹配</h3><p>问题地址：<a href="https://leetcode.cn/problems/regular-expression-matching/">https://leetcode.cn/problems/regular-expression-matching/</a></p>
<p>给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 ‘.’ 和 ‘*’ 的正则表达式匹配。</p>
<ul>
<li>‘.’ 匹配任意单个字符</li>
<li>‘*’ 匹配零个或多个前面的那一个元素</li>
</ul>
<p>所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    bool isMatch(string s, string p) &#123;
        int m &#x3D; s.size();
        int n &#x3D; p.size();
        auto matches &#x3D; [&amp;](int i, int j) &#123;
            if (i &#x3D;&#x3D; 0) &#123;
                return false;
            &#125;
            if (p[j - 1] &#x3D;&#x3D; &#39;.&#39;) &#123;
                return true;
            &#125;
            return s[i - 1] &#x3D;&#x3D; p[j - 1];
        &#125;;

        vector&lt;vector&lt;int&gt;&gt; f(m + 1, vector&lt;int&gt;(n + 1));
        f[0][0] &#x3D; true;
        for (int i &#x3D; 0; i &lt;&#x3D; m; ++i) &#123;
            for (int j &#x3D; 1; j &lt;&#x3D; n; ++j) &#123;
                if (p[j - 1] &#x3D;&#x3D; &#39;*&#39;) &#123;
                    f[i][j] |&#x3D; f[i][j - 2];
                    if (matches(i, j - 1)) &#123;
                        f[i][j] |&#x3D; f[i - 1][j];
                    &#125;
                &#125;
                else &#123;
                    if (matches(i, j)) &#123;
                        f[i][j] |&#x3D; f[i - 1][j - 1];
                    &#125;
                &#125;
            &#125;
        &#125;
        return f[m][n];
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="23-合并-K-个升序链表"><a href="#23-合并-K-个升序链表" class="headerlink" title="23. 合并 K 个升序链表"></a>23. 合并 K 个升序链表</h3><p>问题地址：<a href="https://leetcode.cn/problems/merge-k-sorted-lists/">https://leetcode.cn/problems/merge-k-sorted-lists/</a></p>
<p>给你一个链表数组，每个链表都已经按升序排列。</p>
<p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;**
 * Definition for singly-linked list.
 * struct ListNode &#123;
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) &#123;&#125;
 *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;
 *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;
 * &#125;;
 *&#x2F;
class Solution &#123;
public:
    ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123;
        ListNode * ans &#x3D; nullptr;
        for (size_t i &#x3D; 0; i &lt; lists.size(); ++i) &#123;
            ans &#x3D; mergeTwoLists(ans, lists[i]);
        &#125;
        return ans;
    &#125;

    ListNode * mergeTwoLists(ListNode * a, ListNode * b) &#123;
        if ((!a) || (!b)) return a ? a : b;
        ListNode head, * tail &#x3D; &amp;head, * aPtr &#x3D; a, * bPtr &#x3D; b;
        while (aPtr &amp;&amp; bPtr) &#123;
            if (aPtr-&gt;val &lt; bPtr-&gt;val) &#123;
                tail-&gt;next &#x3D; aPtr; aPtr &#x3D; aPtr-&gt;next;
            &#125; else &#123;
                tail-&gt;next &#x3D; bPtr; bPtr &#x3D; bPtr-&gt;next;
            &#125;
            tail &#x3D; tail-&gt;next;
        &#125;
        tail-&gt;next &#x3D; (aPtr ? aPtr : bPtr);
        return head.next;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="25-K-个一组翻转链表"><a href="#25-K-个一组翻转链表" class="headerlink" title="25. K 个一组翻转链表"></a>25. K 个一组翻转链表</h3><p>问题地址：<a href="https://leetcode.cn/problems/reverse-nodes-in-k-group/">https://leetcode.cn/problems/reverse-nodes-in-k-group/</a></p>
<p>给你链表的头节点 head ，每 k 个节点一组进行翻转，请你返回修改后的链表。</p>
<p>k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。</p>
<p>你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;**
 * Definition for singly-linked list.
 * struct ListNode &#123;
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) &#123;&#125;
 *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;
 *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;
 * &#125;;
 *&#x2F;
class Solution &#123;
public:
    ListNode* reverseKGroup(ListNode* head, int k) &#123;
        stack&lt;ListNode *&gt; stk;
        ListNode * res &#x3D; new ListNode(0);
        ListNode * p &#x3D; res, * q;
        int i;
        while (head) &#123;
            for (i &#x3D; 0; head &amp;&amp; i &lt; k; i++) &#123;
                stk.push(head);
                head &#x3D; head-&gt;next;
            &#125;
            if (i !&#x3D; k) break;
            while (!stk.empty()) &#123;
                p-&gt;next &#x3D; stk.top();
                p &#x3D; p-&gt;next;
                stk.pop();
            &#125;
            q &#x3D; head;
        &#125;
        p-&gt;next &#x3D; q;
        return res-&gt;next;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="2763-所有子数组中不平衡数字之和"><a href="#2763-所有子数组中不平衡数字之和" class="headerlink" title="2763. 所有子数组中不平衡数字之和"></a>2763. 所有子数组中不平衡数字之和</h3><p>问题地址：<a href="https://leetcode.cn/problems/sum-of-imbalance-numbers-of-all-subarrays/">https://leetcode.cn/problems/sum-of-imbalance-numbers-of-all-subarrays/</a></p>
<p>一个长度为 n 下标从 0 开始的整数数组 arr 的 不平衡数字 定义为，在 sarr &#x3D; sorted(arr) 数组中，满足以下条件的下标数目：</p>
<ul>
<li>0 &lt;&#x3D; i &lt; n - 1 ，和</li>
<li>sarr[i+1] - sarr[i] &gt; 1</li>
</ul>
<p>这里，sorted(arr) 表示将数组 arr 排序后得到的数组。</p>
<p>给你一个下标从 0 开始的整数数组 nums ，请你返回它所有 子数组 的 不平衡数字 之和。</p>
<p>子数组指的是一个数组中连续一段 非空 的元素序列。</p>
<p>提示：</p>
<ul>
<li>1 &lt;&#x3D; nums.length &lt;&#x3D; 1000</li>
<li>1 &lt;&#x3D; nums[i] &lt;&#x3D; nums.length</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int sumImbalanceNumbers(vector&lt;int&gt;&amp; nums) &#123;
        int ans &#x3D; 0, n &#x3D; nums.size();
        bool vis[n + 2];
        for (int i &#x3D; 0; i &lt; n; i++) &#123;
            memset(vis, 0, sizeof(vis));
            vis[nums[i]] &#x3D; true;
            int cnt &#x3D; 0;
            for (int j &#x3D; i + 1; j &lt; n; j++) &#123;
                int x &#x3D; nums[j];
                if (!vis[x]) &#123;
                    cnt +&#x3D; 1 - vis[x - 1] - vis[x + 1];
                    vis[x] &#x3D; true;
                &#125;
                ans +&#x3D; cnt;
            &#125;
        &#125;
        return ans;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="30-串联所有单词的子串"><a href="#30-串联所有单词的子串" class="headerlink" title="30. 串联所有单词的子串"></a>30. 串联所有单词的子串</h3><p>问题地址：<a href="https://leetcode.cn/problems/substring-with-concatenation-of-all-words/">https://leetcode.cn/problems/substring-with-concatenation-of-all-words/</a></p>
<p>给定一个字符串 s 和一个字符串数组 words。 words 中所有字符串 长度相同。</p>
<p> s 中的 串联子串 是指一个包含  words 中所有字符串以任意顺序排列连接起来的子串。</p>
<ul>
<li>例如，如果 words &#x3D; <code>[&quot;ab&quot;,&quot;cd&quot;,&quot;ef&quot;]</code>， 那么 “abcdef”， “abefcd”，”cdabef”， “cdefab”，”efabcd”， 和 “efcdab” 都是串联子串。 “acdbef” 不是串联子串，因为他不是任何 words 排列的连接。</li>
</ul>
<p>返回所有串联子串在 s 中的开始索引。你可以以 任意顺序 返回答案。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    vector&lt;int&gt; findSubstring(string s, vector&lt;string&gt;&amp; words) &#123;
        vector&lt;int&gt; res;
        int m &#x3D; words.size(), n &#x3D; words[0].size(), ls &#x3D; s.size();
        for (int i &#x3D; 0; i &lt; n &amp;&amp; i + m * n &lt;&#x3D; ls; ++i) &#123;
            unordered_map&lt;string, int&gt; differ;
            for (int j &#x3D; 0; j &lt; m; ++j) &#123;
                ++differ[s.substr(i + j * n, n)];
            &#125;
            for (string &amp;word : words) &#123;
                if (--differ[word] &#x3D;&#x3D; 0) &#123;
                    differ.erase(word);
                &#125;
            &#125;
            for (int start &#x3D; i; start &lt; ls - m * n + 1; start +&#x3D; n) &#123;
                if (start !&#x3D; i) &#123;
                    string word &#x3D; s.substr(start + (m - 1) * n, n);
                    if (++differ[word] &#x3D;&#x3D; 0) &#123;
                        differ.erase(word);
                    &#125;
                    word &#x3D; s.substr(start - n, n);
                    if (--differ[word] &#x3D;&#x3D; 0) &#123;
                        differ.erase(word);
                    &#125;
                &#125;
                if (differ.empty()) &#123;
                    res.emplace_back(start);
                &#125;
            &#125;
        &#125;
        return res;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="32-最长有效括号"><a href="#32-最长有效括号" class="headerlink" title="32. 最长有效括号"></a>32. 最长有效括号</h3><p>问题地址：<a href="https://leetcode.cn/problems/longest-valid-parentheses/">https://leetcode.cn/problems/longest-valid-parentheses/</a></p>
<p>给你一个只包含 ‘(‘ 和 ‘)’ 的字符串，找出最长有效（格式正确且连续）括号子串的长度。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
public:
    int longestValidParentheses(string s) &#123;
        int maxans &#x3D; 0, n &#x3D; s.length();
        vector&lt;int&gt; dp(n, 0);
        for (int i &#x3D; 1; i &lt; n; i++) &#123;
            if (s[i] &#x3D;&#x3D; &#39;)&#39;) &#123;
                if (s[i - 1] &#x3D;&#x3D; &#39;(&#39;) &#123;
                    dp[i] &#x3D; (i &gt;&#x3D; 2 ? dp[i - 2] : 0) + 2;
                &#125; else if (i - dp[i - 1] &gt; 0 &amp;&amp; s[i - dp[i - 1] - 1] &#x3D;&#x3D; &#39;(&#39;) &#123;
                    dp[i] &#x3D; dp[i - 1] + ((i - dp[i - 1]) &gt;&#x3D; 2 ? dp[i - dp[i - 1] - 2] : 0) + 2;
                &#125;
                maxans &#x3D; max(maxans, dp[i]);
            &#125;
        &#125;
        return maxans;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="37-解数独"><a href="#37-解数独" class="headerlink" title="37. 解数独"></a>37. 解数独</h3><p>问题地址：<a href="https://leetcode.cn/problems/sudoku-solver/">https://leetcode.cn/problems/sudoku-solver/</a></p>
<p>编写一个程序，通过填充空格来解决数独问题。</p>
<p>数独的解法需 遵循如下规则：</p>
<ol>
<li>数字 1-9 在每一行只能出现一次。</li>
<li>数字 1-9 在每一列只能出现一次。</li>
<li>数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）</li>
</ol>
<p>数独部分空格内已填入了数字，空白格用 ‘.’ 表示。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Solution &#123;
private:
    bool line[9][9];
    bool column[9][9];
    bool block[3][3][9];
    bool valid;
    vector&lt;pair&lt;int, int&gt;&gt; spaces;
public:
    void dfs(vector&lt;vector&lt;char&gt;&gt;&amp; board, int pos) &#123;
        if (pos &#x3D;&#x3D; spaces.size()) &#123;
            valid &#x3D; true;
            return;
        &#125;
        
        auto [i, j] &#x3D; spaces[pos];
        for (int digit &#x3D; 0; digit &lt; 9 &amp;&amp; !valid; ++digit) &#123;
            if (!line[i][digit] &amp;&amp; !column[j][digit] &amp;&amp; !block[i &#x2F; 3][j &#x2F; 3][digit]) &#123;
                line[i][digit] &#x3D; column[j][digit] &#x3D; block[i &#x2F; 3][j &#x2F; 3][digit] &#x3D; true;
                board[i][j] &#x3D; digit + &#39;0&#39; + 1;
                dfs(board, pos + 1);
                line[i][digit] &#x3D; column[j][digit] &#x3D; block[i &#x2F; 3][j &#x2F; 3][digit] &#x3D; false;
            &#125;
        &#125;
    &#125;
    void solveSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123;
        memset(line, false, sizeof(line));
        memset(column, false, sizeof(column));
        memset(block, false, sizeof(block));
        valid &#x3D; false;
        for (int i &#x3D; 0; i &lt; 9; ++i) &#123;
            for (int j &#x3D; 0; j &lt; 9; ++j) &#123;
                if (board[i][j] &#x3D;&#x3D; &#39;.&#39;) &#123;
                    spaces.emplace_back(i, j);
                &#125; else &#123;
                    int digit &#x3D; board[i][j] - &#39;0&#39; - 1;
                    line[i][digit] &#x3D; column[j][digit] &#x3D; block[i &#x2F; 3][j &#x2F; 3][digit] &#x3D; true;
                &#125;
            &#125;
        &#125;
        dfs(board, 0);
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="C-快速参考"><a href="#C-快速参考" class="headerlink" title="C++ 快速参考"></a>C++ 快速参考</h2><p>std::max_element: <a href="https://en.cppreference.com/w/cpp/algorithm/max_element">https://en.cppreference.com/w/cpp/algorithm/max_element</a></p>
<p>std::lower_bound: <a href="https://en.cppreference.com/w/cpp/algorithm/lower_bound">https://en.cppreference.com/w/cpp/algorithm/lower_bound</a></p>
<p>std::upper_bound: <a href="https://zh.cppreference.com/w/cpp/algorithm/upper_bound">https://zh.cppreference.com/w/cpp/algorithm/upper_bound</a></p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>第八十八篇博文写完，开心！！！！</p>
<p>今天，也是充满希望的一天。</p>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">LuYF-Lemon-love</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://luyf-lemon-love.space/2023/08/26/00088-leetcode-shua-ti-bi-ji/">https://luyf-lemon-love.space/2023/08/26/00088-leetcode-shua-ti-bi-ji/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">LuYF-Lemon-love</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/%E5%88%B7%E9%A2%98/">
                                    <span class="chip bg-color">刷题</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">谢谢小主！</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="https://cos.luyf-lemon-love.space/images/20220511162303.png" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="https://cos.luyf-lemon-love.space/images/20220511162220.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2023/09/08/00089-python-dataclasses-shu-ju-lei/">
                    <div class="card-image">
                        
                        <img src="https://cos.luyf-lemon-love.space/images/042-伞.jpg" class="responsive-img" alt="00089-Python dataclasses --- 数据类">
                        
                        <span class="card-title">00089-Python dataclasses --- 数据类</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2023-09-08
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Python/" class="post-category">
                                    Python
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Python/">
                        <span class="chip bg-color">Python</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2023/08/26/00087-du-de-qiang-hua-xue-xi-lun-wen-pdf-ban-ben/">
                    <div class="card-image">
                        
                        <img src="https://cos.luyf-lemon-love.space/images/041-狐狸头女孩玩具枪.jpg" class="responsive-img" alt="00087-读的强化学习论文 PDF 版本">
                        
                        <span class="card-title">00087-读的强化学习论文 PDF 版本</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2023-08-26
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Paper/" class="post-category">
                                    Paper
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/">
                        <span class="chip bg-color">强化学习</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>


  <!-- 是否加载使用自带的 prismjs. -->
  <script type="text/javascript" src="/libs/prism/prism.min.js"></script>


<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>



    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>


<script src="https://cdn.bootcss.com/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
    MathJax.Hub.Config({
        tex2jax: {inlineMath: [['$', '$'], ['\\(', '\\)']]}
    });
</script>



    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="503838841"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="/libs/aplayer/Meting.min.js"></script>

    

    <div class="container row center-align"
         style="margin-bottom: 15px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2022-2024</span>
            
            <a href="/about" target="_blank">LuYF-Lemon-love</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            
            <br>
            
                &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                        class="white-color">990.6k</span>
            
            
            
                
            
            
                <span id="busuanzi_container_site_pv">
                &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;
                    <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
                <span id="busuanzi_container_site_uv">
                &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;
                    <span id="busuanzi_value_site_uv" class="white-color"></span>
            </span>
            
            <br>

            <!-- 运行天数提醒. -->
            
                <span id="sitetime"> Loading ...</span>
                <script>
                    var calcSiteTime = function () {
                        var seconds = 1000;
                        var minutes = seconds * 60;
                        var hours = minutes * 60;
                        var days = hours * 24;
                        var years = days * 365;
                        var today = new Date();
                        var startYear = "2022";
                        var startMonth = "5";
                        var startDate = "7";
                        var startHour = "4";
                        var startMinute = "53";
                        var startSecond = "32";
                        var todayYear = today.getFullYear();
                        var todayMonth = today.getMonth() + 1;
                        var todayDate = today.getDate();
                        var todayHour = today.getHours();
                        var todayMinute = today.getMinutes();
                        var todaySecond = today.getSeconds();
                        var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                        var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                        var diff = t2 - t1;
                        var diffYears = Math.floor(diff / years);
                        var diffDays = Math.floor((diff / days) - diffYears * 365);

                        // 区分是否有年份.
                        var language = 'zh-CN';
                        if (startYear === String(todayYear)) {
                            document.getElementById("year").innerHTML = todayYear;
                            var daysTip = 'This site has been running for ' + diffDays + ' days';
                            if (language === 'zh-CN') {
                                daysTip = '本站已运行 ' + diffDays + ' 天';
                            } else if (language === 'zh-HK') {
                                daysTip = '本站已運行 ' + diffDays + ' 天';
                            }
                            document.getElementById("sitetime").innerHTML = daysTip;
                        } else {
                            document.getElementById("year").innerHTML = startYear + " - " + todayYear;
                            var yearsAndDaysTip = 'This site has been running for ' + diffYears + ' years and '
                                + diffDays + ' days';
                            if (language === 'zh-CN') {
                                yearsAndDaysTip = '本站已运行 ' + diffYears + ' 年 ' + diffDays + ' 天';
                            } else if (language === 'zh-HK') {
                                yearsAndDaysTip = '本站已運行 ' + diffYears + ' 年 ' + diffDays + ' 天';
                            }
                            document.getElementById("sitetime").innerHTML = yearsAndDaysTip;
                        }
                    }

                    calcSiteTime();
                </script>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/LuYF-Lemon-love" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:luyanfeng_nlp@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>













    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 白天和黑夜主题 -->
<div class="stars-con">
    <div id="stars"></div>
    <div id="stars2"></div>
    <div id="stars3"></div>  
</div>

<script>
    function switchNightMode() {
        $('<div class="Cuteen_DarkSky"><div class="Cuteen_DarkPlanet"></div></div>').appendTo($('body')),
        setTimeout(function () {
            $('body').hasClass('DarkMode') 
            ? ($('body').removeClass('DarkMode'), localStorage.setItem('isDark', '0'), $('#sum-moon-icon').removeClass("fa-sun").addClass('fa-moon')) 
            : ($('body').addClass('DarkMode'), localStorage.setItem('isDark', '1'), $('#sum-moon-icon').addClass("fa-sun").removeClass('fa-moon')),
            
            setTimeout(function () {
            $('.Cuteen_DarkSky').fadeOut(1e3, function () {
                $(this).remove()
            })
            }, 2e3)
        })
    }
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    

    
    
    

    <!-- 雪花特效 -->
    

    <!-- 鼠标星星特效 -->
     
        <script type="text/javascript">
            // 只在桌面版网页启用特效
            var windowWidth = $(window).width();
            if (windowWidth > 768) {
                document.write('<script type="text/javascript" src="/libs/others/star.js"><\/script>');
            }
        </script>
    

     
        <script src="https://ssl.captcha.qq.com/TCaptcha.js"></script>
        <script src="/libs/others/TencentCaptcha.js"></script>
        <button id="TencentCaptcha" data-appid="xxxxxxxxxx" data-cbfn="callback" type="button" hidden></button>
    

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    
    <script type="text/javascript" color="0,0,255"
        pointColor="0,0,255" opacity='0.7'
        zIndex="-1" count="99"
        src="/libs/background/canvas-nest.js"></script>
    

    

    
    <script type="text/javascript" src="/libs/background/ribbon-dynamic.js" async="async"></script>
    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
