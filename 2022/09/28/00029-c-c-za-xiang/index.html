<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="00029-C/C++ 杂项, NLP LLM DeepLearning LuYF-Lemon-love 自然语言处理 深度学习 大语言模型">
    <meta name="description" content="前言介绍一些 C/C++ 标准库和可移植操作系统接口（Portable Operating System Interface，缩写为 POSIX）。
C/C++ Reference: https://cplusplus.com/refere">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>00029-C/C++ 杂项 | LuYF-Lemon-love の Blog</title>
    <link rel="icon" type="image/jpeg" href="https://cos.luyf-lemon-love.space/images/苏苏1.jpeg">
    
    <style>
        body{
            background-image: url(https://cdn.jsdelivr.net/gh/Tokisaki-Galaxy/res/site/medias/background.jpg);
            background-repeat:no-repeat;
            background-size: 100% 100%;
            background-attachment:fixed;
        }
    </style>



    <!-- bg-cover style     -->



<link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.min.css">
<link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
<link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
<link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
<link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
<link rel="stylesheet" type="text/css" href="/css/matery.css">
<link rel="stylesheet" type="text/css" href="/css/my.css">
<link rel="stylesheet" type="text/css" href="/css/dark.css" media="none" onload="if(media!='all')media='all'">




    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
    <link rel="stylesheet" href="/css/post.css">




    
        <link rel="stylesheet" type="text/css" href="/css/reward.css">
    



    <script src="/libs/jquery/jquery-3.6.0.min.js"></script>

<meta name="generator" content="Hexo 7.3.0"></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <span class="logo-span">LuYF-Lemon-love の Blog</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
  <li>
    <a href="javascript:;" class="waves-effect waves-light" onclick="switchNightMode()" title="深色/浅色模式" >
      <i id="sum-moon-icon" class="fas fa-sun" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <div class="logo-name">LuYF-Lemon-love の Blog</div>
        <div class="logo-desc">
            
            天之道，损有余而补不足，人之道则不然，损不足以奉有余。
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/LuYF-Lemon-love/paper-is-all-you-need" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/LuYF-Lemon-love/paper-is-all-you-need" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    
<script src="/libs/cryptojs/crypto-js.min.js"></script>
<script>
    (function() {
        let pwd = '';
        if (pwd && pwd.length > 0) {
            if (pwd !== CryptoJS.SHA256(prompt('请输入访问本文章的密码')).toString(CryptoJS.enc.Hex)) {
                alert('密码错误，将返回主页！');
                location.href = '/';
            }
        }
    })();
</script>




<div class="bg-cover pd-header post-cover" style="background-image: url('https://cos.luyf-lemon-love.space/images/以绪塔尔.png')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">00029-C/C++ 杂项</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/C/">
                                <span class="chip bg-color">C++</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E6%9D%82%E9%A1%B9/" class="post-category">
                                杂项
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2022-09-28
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2024-12-28
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    26.2k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    150 分
                </div>
                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/libs/prism/prism.min.css">
        

        
        <!-- 代码块折行 -->
        <style type="text/css">
            code[class*="language-"], pre[class*="language-"] { white-space: pre-wrap !important; }
        </style>
        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>介绍一些 <code>C/C++</code> 标准库和可移植操作系统接口（<code>Portable Operating System Interface</code>，缩写为 <code>POSIX</code>）。</p>
<p><code>C/C++ Reference</code>: <a href="https://cplusplus.com/reference/">https://cplusplus.com/reference/</a> 。</p>
<p>操作系统：Ubuntu 20.04.4 LTS</p>
<p>下面是各个章节的<code>快速索引</code>:</p>
<ol>
<li><p><a href="#1">C Library</a></p>
</li>
<li><p><a href="#2">Containers</a></p>
</li>
<li><p><a href="#3">Input&#x2F;Output Stream Library</a></p>
</li>
<li><p><a href="#4">Atomics and threading library</a></p>
</li>
<li><p><a href="#5">Miscellaneous headers</a></p>
</li>
<li><p><a href="#6">C++ 语法</a></p>
</li>
<li><p><a href="#7">计算机基础</a></p>
</li>
<li><p><a href="#8">常用的 C++ 内置函数</a></p>
</li>
</ol>
<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ol>
<li><p><a href="https://baike.baidu.com/item/%E5%8F%AF%E7%A7%BB%E6%A4%8D%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%8E%A5%E5%8F%A3/12718298?fromtitle=POSIX&fromid=3792413&fr=aladdin">可移植操作系统接口</a></p>
</li>
<li><p><a href="https://cplusplus.com/reference/">C&#x2F;C++ Reference</a></p>
</li>
<li><p><a href="https://cplusplus.com/reference/cstdio/"><code>&lt;cstdio&gt;</code> (stdio.h)</a></p>
</li>
<li><p><a href="https://cplusplus.com/reference/cstdio/fopen/">fopen</a></p>
</li>
<li><p><a href="https://cplusplus.com/reference/cstdio/fclose/">fclose</a></p>
</li>
<li><p><a href="https://cplusplus.com/reference/cstdio/fputc/">fputc</a></p>
</li>
<li><p><a href="https://cplusplus.com/reference/cstdio/rewind/">rewind</a></p>
</li>
<li><p><a href="https://cplusplus.com/reference/cstdio/fscanf/">fscanf</a></p>
</li>
<li><p><a href="https://cplusplus.com/reference/cstdio/fwrite/">fwrite</a></p>
</li>
<li><p><a href="https://cplusplus.com/reference/cstdio/fread/">fread</a></p>
</li>
<li><p><a href="https://cplusplus.com/reference/cstring/"><code>&lt;cstring&gt;</code> (string.h)</a></p>
</li>
<li><p><a href="https://cplusplus.com/reference/cstring/strcmp/">strcmp</a></p>
</li>
<li><p><a href="https://cplusplus.com/reference/string/"><code>&lt;string&gt;</code></a></p>
</li>
<li><p><a href="https://cplusplus.com/reference/string/to_string/"><code>std::to_string</code></a></p>
</li>
<li><p><a href="https://cplusplus.com/reference/cstdio/puts/">puts</a></p>
</li>
<li><p><a href="https://cplusplus.com/reference/cstdio/fputs/">fputs</a></p>
</li>
<li><p><a href="https://baike.baidu.com/item/%E5%8F%B3%E7%A7%BB%E8%BF%90%E7%AE%97%E7%AC%A6">右移运算符</a></p>
</li>
<li><p><a href="https://cplusplus.com/reference/cmath/exp/">exp</a></p>
</li>
<li><p><a href="https://cplusplus.com/reference/cstdlib/calloc/">calloc</a></p>
</li>
<li><p><a href="https://cplusplus.com/reference/cstring/memcpy/">memcpy</a></p>
</li>
<li><p><a href="https://cplusplus.com/reference/cstring/memset/">memset</a></p>
</li>
<li><p><a href="https://cplusplus.com/reference/cstdlib/free/">free</a></p>
</li>
<li><p><a href="https://cplusplus.com/reference/cstdlib/atof/">atof</a></p>
</li>
<li><p><a href="https://cplusplus.com/reference/cstdlib/atoi/">atoi</a></p>
</li>
<li><p><a href="https://cplusplus.com/reference/cstring/memcmp/">memcmp</a></p>
</li>
<li><p><a href="https://cplusplus.com/reference/algorithm/"><code>&lt;algorithm&gt;</code></a></p>
</li>
<li><p><a href="https://cplusplus.com/reference/algorithm/sort/">sort</a></p>
</li>
<li><p><a href="https://cplusplus.com/reference/cmath/fabs/">fabs</a></p>
</li>
<li><p><a href="https://cplusplus.com/reference/string/string/c_str/">c_str</a></p>
</li>
<li><p><a href="https://cplusplus.com/reference/cstdlib/rand/">rand</a></p>
</li>
<li><p><a href="https://baike.baidu.com/item/ASCII/309296?fr=aladdin">ASCII</a></p>
</li>
<li><p><a href="https://cplusplus.com/reference/iostream/cout/">cout</a></p>
</li>
<li><p><a href="https://cplusplus.com/reference/utility/pair/">pair</a></p>
</li>
<li><p><a href="https://cplusplus.com/reference/iterator/begin/">begin</a></p>
</li>
<li><p><a href="https://cplusplus.com/reference/cstdio/fprintf/">fprintf</a></p>
</li>
<li><p><a href="https://cplusplus.com/reference/cstdio/fgetc/">fgetc</a></p>
</li>
<li><p><a href="https://cplusplus.com/reference/cstdio/feof/">feof</a></p>
</li>
<li><p><a href="https://cplusplus.com/reference/iostream/cerr/">cerr</a></p>
</li>
<li><p><a href="https://cplusplus.com/reference/algorithm/min/">min</a></p>
</li>
<li><p><a href="https://cplusplus.com/reference/map/map/operator[]/">std::map::operator[]</a></p>
</li>
<li><p><a href="https://cplusplus.com/reference/vector/vector/operator[]/">std::vector::operator[]</a></p>
</li>
<li><p><a href="https://cplusplus.com/reference/map/map/size/">size</a></p>
</li>
<li><p><a href="https://cplusplus.com/reference/vector/vector/size/">size</a></p>
</li>
<li><p><a href="https://cplusplus.com/reference/map/map/clear/">clear</a></p>
</li>
<li><p><a href="https://cplusplus.com/reference/vector/vector/clear/">clear</a></p>
</li>
<li><p><a href="https://cplusplus.com/reference/map/map/count/">count</a></p>
</li>
<li><p><a href="https://cplusplus.com/reference/vector/vector/resize/">resize</a></p>
</li>
<li><p><a href="https://cplusplus.com/reference/vector/vector/operator=/">operator&#x3D;</a></p>
</li>
<li><p><a href="https://cplusplus.com/reference/vector/vector/push_back/">push_back</a></p>
</li>
<li><p><a href="https://cplusplus.com/reference/cstdio/fseek/">fseek</a></p>
</li>
<li><p><a href="https://cplusplus.com/reference/cstring/strtok/">strtok</a></p>
</li>
<li><p><a href="https://cplusplus.com/reference/cstdio/scanf/">scanf</a></p>
</li>
<li><p><a href="https://cplusplus.com/reference/array/array/begin/">std::array::begin</a></p>
</li>
<li><p><a href="https://cplusplus.com/reference/algorithm/transform/">std::transform</a></p>
</li>
<li><p><a href="https://blog.csdn.net/qq_63610563/article/details/124088619">const修饰成员函数</a></p>
</li>
<li><p><a href="https://zh.cppreference.com/w/cpp/language/ascii">ASCII 码表</a></p>
</li>
<li><p><a href="https://zh.cppreference.com/w/cpp/types/is_same">std::is_same</a></p>
</li>
<li><p><a href="https://zh.cppreference.com/w/cpp/utility/tuple/tie">std::tie</a></p>
</li>
<li><p><a href="https://zh.cppreference.com/w/cpp/utility/tuple/ignore">std::ignore</a></p>
</li>
<li><p><a href="https://zh.cppreference.com/w/cpp/types/remove_reference">std::remove_reference</a></p>
</li>
<li><p><a href="https://zh.cppreference.com/w/cpp/io/manip/boolalpha">std::boolalpha, std::noboolalpha</a></p>
</li>
<li><p><a href="https://zh.cppreference.com/w/cpp/utility/tuple/make_tuple">std::make_tuple</a></p>
</li>
<li><p><a href="https://zh.cppreference.com/w/cpp/utility/tuple/tuple_size">std::tuple_size<a href="std::tuple">std::tuple</a></a></p>
</li>
<li><p><a href="https://zh.cppreference.com/w/cpp/algorithm/accumulate">std::accumulate</a></p>
</li>
<li><p><a href="https://cplusplus.com/reference/cmath/acos/">acos</a></p>
</li>
<li><p><a href="https://zh.cppreference.com/w/cpp/iterator/distance">std::distance</a></p>
</li>
<li><p><a href="https://zh.cppreference.com/w/cpp/error/exception/what">std::exception::what</a></p>
</li>
<li><p><a href="https://zh.cppreference.com/w/cpp/iterator/advance">std::advance</a></p>
</li>
<li><p><a href="https://zh.cppreference.com/w/cpp/iterator/next">std::next</a></p>
</li>
<li><p><a href="https://zh.cppreference.com/w/cpp/utility/functional/multiplies">std::multiplies</a></p>
</li>
<li><p><a href="https://zh.cppreference.com/w/cpp/algorithm/find">std::find, std::find_if, std::find_if_not</a></p>
</li>
<li><p><a href="https://zh.cppreference.com/w/cpp/container/list/splice">std::list&lt;T,Allocator&gt;::splice</a></p>
</li>
<li><p><a href="https://zh.cppreference.com/w/cpp/algorithm/partition">std::partition</a></p>
</li>
</ol>
<div id = "1"></div>

<h1 id="C-Library"><a href="#C-Library" class="headerlink" title="C Library"></a><code>C Library</code></h1><h2 id="math-h"><a href="#math-h" class="headerlink" title="&lt;cmath&gt; (math.h)"></a><code>&lt;cmath&gt;</code> (math.h)</h2><p><code>&lt;cmath&gt; (math.h)</code>: <a href="https://cplusplus.com/reference/cmath/">https://cplusplus.com/reference/cmath/</a> 。</p>
<p><code>&lt;cmath&gt; (math.h)</code>: C numerics library.</p>
<h3 id="Trigonometric-functions"><a href="#Trigonometric-functions" class="headerlink" title="Trigonometric functions"></a>Trigonometric functions</h3><ul>
<li><code>acos</code>: Compute arc cosine (function)</li>
</ul>
<h4 id="acos"><a href="#acos" class="headerlink" title="acos"></a>acos</h4><p><code>acos</code>: <a href="https://cplusplus.com/reference/cmath/acos/">https://cplusplus.com/reference/cmath/acos/</a> 。</p>
<p><code>double acos (double x);</code></p>
<p><strong><code>Compute arc cosine</code></strong></p>
<p>Returns the principal value of the arc cosine of x, expressed in radians.</p>
<p>In trigonometrics, arc cosine is the inverse operation of cosine.</p>
<blockquote>
<p>Header <code>&lt;tgmath.h&gt;</code> provides a type-generic macro version of this function.</p>
</blockquote>
<p><strong><code>Parameters</code></strong></p>
<p><strong>x</strong></p>
<p>Value whose arc cosine is computed, in the interval <code>[-1,+1]</code>.</p>
<p>If the argument is out of this interval, a domain error occurs.</p>
<p><strong><code>Return Value</code></strong></p>
<p>Principal arc cosine of x, in the interval <code>[0,pi]</code> radians.</p>
<p>One radian is equivalent to <code>180/PI</code> degrees.</p>
<blockquote>
<p>If a <code>domain error</code> occurs, the global variable errno is set to EDOM.</p>
</blockquote>
<p><strong><code>Example</code></strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;* acos example *&#x2F;
#include &lt;stdio.h&gt;      &#x2F;* printf *&#x2F;
#include &lt;math.h&gt;       &#x2F;* acos *&#x2F;

#define PI 3.14159265

int main ()
&#123;
  double param, result;
  param &#x3D; 0.5;
  result &#x3D; acos (param) * 180.0 &#x2F; PI;
  printf (&quot;The arc cosine of %f is %f degrees.\n&quot;, param, result);
  return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>输出</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">The arc cosine of <span class="token number">0.500000</span> is <span class="token number">60.000000</span> degrees.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="Exponential-and-logarithmic-functions"><a href="#Exponential-and-logarithmic-functions" class="headerlink" title="Exponential and logarithmic functions"></a>Exponential and logarithmic functions</h3><ul>
<li><code>exp</code>: Compute exponential function (function)</li>
</ul>
<h4 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h4><p><code>exp</code>: <a href="https://cplusplus.com/reference/cmath/exp/">https://cplusplus.com/reference/cmath/exp/</a> 。</p>
<p><code>double exp (double x);</code></p>
<p><strong><code>Compute exponential function</code></strong></p>
<p><code>Returns</code> the <code>base-e</code> exponential function of <code>x</code>, which is <code>e</code> raised to the power $x: e^x$.</p>
<p><strong><code>Parameters</code></strong></p>
<p><strong>x</strong></p>
<ol>
<li>Value of the exponent.</li>
</ol>
<p><strong><code>Return Value</code></strong></p>
<p>Exponential value of <code>x</code>.</p>
<p><strong><code>Example</code></strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;* exp example *&#x2F;
#include &lt;stdio.h&gt;      &#x2F;* printf *&#x2F;
#include &lt;math.h&gt;       &#x2F;* exp *&#x2F;

int main ()
&#123;
  double param, result;
  param &#x3D; 5.0;
  result &#x3D; exp (param);
  printf (&quot;The exponential value of %f is %f.\n&quot;, param, result );
  return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>输出</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">The exponential value of <span class="token number">5.000000</span> is <span class="token number">148.413159</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="Other-functions"><a href="#Other-functions" class="headerlink" title="Other functions"></a>Other functions</h3><ul>
<li><code>fabs</code>: Compute absolute value (function)</li>
</ul>
<h4 id="fabs"><a href="#fabs" class="headerlink" title="fabs"></a>fabs</h4><p><code>fabs</code>: <a href="https://cplusplus.com/reference/cmath/fabs/">https://cplusplus.com/reference/cmath/fabs/</a> 。</p>
<p><code>double fabs (double x);</code></p>
<p><strong><code>Compute absolute value</code></strong></p>
<p>Returns the <code>absolute value</code> of <code>x: |x|</code>.</p>
<p><strong><code>Parameters</code></strong></p>
<p><strong>x</strong></p>
<ol>
<li>Value whose absolute value is returned.</li>
</ol>
<p><strong><code>Return Value</code></strong></p>
<p>The absolute value of <code>x</code>.</p>
<p><strong><code>Example</code></strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;* fabs example *&#x2F;
#include &lt;stdio.h&gt;      &#x2F;* printf *&#x2F;
#include &lt;math.h&gt;       &#x2F;* fabs *&#x2F;

int main ()
&#123;
  printf (&quot;The absolute value of 3.1416 is %f\n&quot;, fabs (3.1416) );
  printf (&quot;The absolute value of -10.6 is %f\n&quot;, fabs (-10.6) );
  return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>输出</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">The absolute value of <span class="token number">3.1416</span> is <span class="token number">3.141600</span>
The absolute value of <span class="token parameter variable">-10.6</span> is <span class="token number">10.600000</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h2 id="stdio-h"><a href="#stdio-h" class="headerlink" title="&lt;cstdio&gt; (stdio.h)"></a><code>&lt;cstdio&gt;</code> (stdio.h)</h2><p><code>&lt;cstdio&gt; (stdio.h)</code>: <a href="https://cplusplus.com/reference/cstdio/">https://cplusplus.com/reference/cstdio/</a> 。</p>
<p><code>&lt;cstdio&gt; (stdio.h)</code>: C library to perform Input&#x2F;Output operations.</p>
<h3 id="File-access"><a href="#File-access" class="headerlink" title="File access"></a>File access</h3><ul>
<li><p><code>fopen</code>: Open file (function)</p>
</li>
<li><p><code>fclose</code>: Close file (function)</p>
</li>
</ul>
<h4 id="fopen"><a href="#fopen" class="headerlink" title="fopen"></a>fopen</h4><p><code>fopen</code>: <a href="https://cplusplus.com/reference/cstdio/fopen/">https://cplusplus.com/reference/cstdio/fopen/</a> 。</p>
<p><code>FILE * fopen ( const char * filename, const char * mode );</code></p>
<p><strong><code>打开文件</code></strong></p>
<p><code>Opens the file</code> whose name is specified in <code>the parameter filename</code> and <code>associates it with a stream</code> that can be identified in future operations by <code>the FILE pointer</code> returned.</p>
<p>The <code>operations</code> that are allowed on <code>the stream</code> and how these are performed are defined by <code>the mode parameter</code>.</p>
<p>The returned pointer can be <code>disassociated</code> from the file by calling <code>fclose</code> or <code>freopen</code>. <code>All opened files are automatically closed on normal program termination</code>.</p>
<p><strong><code>参数</code></strong></p>
<p><strong>filename</strong></p>
<ol>
<li><p><code>C string</code> containing <code>the name of the file to be opened</code>.</p>
</li>
<li><p>Its value can <code>include a path</code>.</p>
</li>
</ol>
<p><strong>mode</strong></p>
<p><code>C string</code> containing <code>a file access mode</code>. It can be:</p>
<ul>
<li><p><code>&quot;r&quot;</code> -&gt; <code>read</code>: <code>Open file</code> for <code>input operations</code>. The file must exist.</p>
</li>
<li><p><code>&quot;w&quot;</code> -&gt; <code>write</code>: <code>Create an empty file</code> for output operations. If a file with <code>the same name already exists</code>, its contents are <code>discarded</code> and the file is treated as a new empty file.</p>
</li>
<li><p><code>&quot;a&quot;</code> -&gt; <code>append</code>: Open file for <code>output at the end of a file</code>. <code>Output operations always write data at the end of the file</code>, expanding it. <code>Repositioning operations</code> (fseek, fsetpos, rewind) <code>are ignored</code>. <strong>The file is created if it does not exist</strong>.</p>
</li>
<li><p><code>&quot;r+&quot;</code> -&gt; <code>read/update</code>: <code>Open a file for update (both for input and output)</code>. <strong>The file must exist</strong>.</p>
</li>
<li><p><code>&quot;w+&quot;</code> -&gt; <code>write/update</code>: <code>Create an empty file</code> and open it for update (<code>both for input and output</code>). If a file with the same name already exists <code>its contents are discarded</code> and the file is treated as a new empty file.</p>
</li>
<li><p><code>&quot;a+&quot;</code> -&gt; <code>append/update</code>: Open a file for update (<code>both for input and output</code>) with <code>all output operations writing data at the end of the file</code>. Repositioning operations (fseek, fsetpos, rewind) affects <code>the next input operations</code>, but <code>output operations move the position back to the end of file</code>. <strong>The file is created if it does not exist</strong>.</p>
</li>
</ul>
<hr>
<p>With the mode specifiers above the file is open <code>as a text file</code>. In order to open a file as <code>a binary file</code>, a <code>&quot;b&quot;</code> character has to be included in the mode string. This additional <code>&quot;b&quot;</code> character can either be appended <code>at the end of the string</code> (thus making the following <code>compound modes</code>: “rb”, “wb”, “ab”, “r+b”, “w+b”, “a+b”) or be inserted between the letter and the “+” sign for the mixed modes (“rb+”, “wb+”, “ab+”).</p>
<hr>
<p>For files open for update (those which include a <code>&quot;+&quot;</code> sign), on which <code>both input and output operations are allowed</code>, <code>the stream shall be flushed (fflush) or repositioned (fseek, fsetpos, rewind) before a reading operation that follows a writing operation</code>. The stream shall <code>be repositioned (fseek, fsetpos, rewind) before a writing operation</code> that follows a <code>reading operation</code>(whenever that operation <code>did not reach the end-of-file</code>).</p>
<p><strong><code>返回值</code></strong></p>
<p>If the file is <code>successfully opened</code>, the function returns <code>a pointer to a FILE object</code> that can be used to identify the <code>stream</code> on future operations.</p>
<p>Otherwise, <code>a null pointer</code> is returned.</p>
<p><strong><code>例子</code></strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;* fopen example *&#x2F;
#include &lt;stdio.h&gt;
int main ()
&#123;
  FILE * pFile;
  pFile &#x3D; fopen (&quot;myfile.txt&quot;,&quot;w&quot;);
  if (pFile!&#x3D;NULL)
  &#123;
    fputs (&quot;fopen example&quot;,pFile);
    fclose (pFile);
  &#125;
  return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="fclose"><a href="#fclose" class="headerlink" title="fclose"></a>fclose</h4><p><code>fclose</code>: <a href="https://cplusplus.com/reference/cstdio/fclose/">https://cplusplus.com/reference/cstdio/fclose/</a> 。</p>
<p><code>int fclose ( FILE * stream );</code></p>
<p><strong><code>关闭文件</code></strong></p>
<p><code>Closes the file</code> associated with the <code>stream</code> and <code>disassociates</code> it.</p>
<p><code>All internal buffers associated with the stream</code> are disassociated from it and <code>flushed</code>: <code>the content of any unwritten output buffer is written</code> and <code>the content of any unread input buffer is discarded</code>.</p>
<p>Even if the call <code>fails</code>, the stream passed as parameter will <code>no longer be associated with the file</code> nor its buffers.</p>
<p><strong><code>参数</code></strong></p>
<p><strong>stream</strong></p>
<p><code>Pointer</code> to a <code>FILE</code> object that specifies the stream to be closed.</p>
<p><strong><code>返回值</code></strong></p>
<p>If the stream is <code>successfully closed</code>, a <code>zero value</code> is returned.</p>
<p>On <code>failure</code>, <code>EOF</code> is returned.</p>
<p><strong><code>例子</code></strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;* fclose example *&#x2F;
#include &lt;stdio.h&gt;
int main ()
&#123;
  FILE * pFile;
  pFile &#x3D; fopen (&quot;myfile.txt&quot;,&quot;wt&quot;);
  fprintf (pFile, &quot;fclose example&quot;);
  fclose (pFile);
  return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>This simple code <code>creates a new text file</code>, then <code>writes</code> a sentence to it, and then <code>closes</code> it.</p>
<h3 id="Formatted-input-output"><a href="#Formatted-input-output" class="headerlink" title="Formatted input&#x2F;output"></a>Formatted input&#x2F;output</h3><ul>
<li><p><code>fprintf</code>: Write formatted data to stream (function)</p>
</li>
<li><p><code>fscanf</code>: Read formatted data from stream (function)</p>
</li>
<li><p><code>scanf</code>: Read formatted data from stdin (function)</p>
</li>
</ul>
<h4 id="fprintf"><a href="#fprintf" class="headerlink" title="fprintf"></a>fprintf</h4><p><code>fprintf</code>: <a href="https://cplusplus.com/reference/cstdio/fprintf/">https://cplusplus.com/reference/cstdio/fprintf/</a> 。</p>
<p><code>int fprintf ( FILE * stream, const char * format, ... );</code></p>
<p><strong><code>Write formatted data to stream</code></strong></p>
<p>Writes the <code>C</code> string pointed by <code>format</code> to the <code>stream</code>. If <code>format</code> includes <code>format specifiers</code> (subsequences beginning with <code>%</code>), the additional arguments following format are <code>formatted</code> and inserted in the resulting string replacing their respective specifiers.</p>
<p>After the <code>format</code> parameter, the function expects at least as many additional arguments as specified by <code>format</code>.</p>
<p><strong><code>Parameters</code></strong></p>
<p><strong>stream</strong></p>
<ol>
<li><code>Pointer</code> to a <code>FILE</code> object that identifies <code>an output stream</code>.</li>
</ol>
<p><strong>format</strong></p>
<p><code>C string</code> that contains the text to be written to the stream.</p>
<p>It can optionally contain embedded <code>format specifiers</code> that are replaced by the values specified in subsequent additional arguments and formatted as requested.</p>
<p><code>A format specifier</code> follows this prototype:</p>
<p><code>%[flags][width][.precision][length]specifier</code></p>
<p><strong><code>Return Value</code></strong></p>
<p><code>On success</code>, <code>the total number of characters written</code> is returned.</p>
<p>If a writing error occurs, the <code>error indicator</code> (<code>ferror</code>) is set and <code>a negative number is returned</code>.</p>
<p>If a multibyte character encoding error occurs while writing wide characters, <code>errno</code> is set to EILSEQ and a negative number is returned.</p>
<p><strong><code>Example</code></strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;* fprintf example *&#x2F;
#include &lt;stdio.h&gt;

int main ()
&#123;
   FILE * pFile;
   int n;
   char name [100];

   pFile &#x3D; fopen (&quot;myfile.txt&quot;,&quot;w&quot;);
   for (n&#x3D;0 ; n&lt;3 ; n++)
   &#123;
     puts (&quot;please, enter a name: &quot;);
     gets (name);
     fprintf (pFile, &quot;Name %d [%-10.10s]\n&quot;,n+1,name);
   &#125;
   fclose (pFile);

   return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>This example prompts <code>3 times</code> the user for <code>a name</code> and then writes them to <code>myfile.txt</code> each one in a line with a fixed length (a total of 19 characters + newline).</p>
<p>Two format tags are used:</p>
<p><code>%d</code> : <code>Signed decimal integer</code></p>
<p><code>%-10.10s</code> : <code>left-justified (-)</code>, <code>minimum of ten characters (10)</code>, <code>maximum of ten characters (.10)</code>, <code>string (s)</code>.</p>
<p>Assuming that we have entered <code>John</code>, <code>Jean-Francois</code> and <code>Yoko</code> as the 3 names, <code>myfile.txt</code> would contain:</p>
<pre class="line-numbers language-none"><code class="language-none">Name 1 [John      ] 
Name 2 [Jean-Franc] 
Name 3 [Yoko      ]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h4 id="fscanf"><a href="#fscanf" class="headerlink" title="fscanf"></a>fscanf</h4><p><code>fscanf</code>: <a href="https://cplusplus.com/reference/cstdio/fscanf/">https://cplusplus.com/reference/cstdio/fscanf/</a> 。</p>
<p><code>int fscanf ( FILE * stream, const char * format, ... );</code></p>
<p><strong><code>Read formatted data from stream</code></strong></p>
<p>Reads data from the stream and <code>stores</code> them <code>according to the parameter format</code> into the locations pointed by the <code>additional arguments</code>.</p>
<p>The <code>additional arguments</code> should point to already <code>allocated objects</code> of the type specified by their corresponding format specifier within the format string.</p>
<p><strong><code>Parameters</code></strong></p>
<p><strong>stream</strong></p>
<ol>
<li><code>Pointer</code> to <code>a FILE object</code> that identifies <code>the input stream to read data from</code>.</li>
</ol>
<p><strong>format</strong></p>
<p><code>C string</code> that contains a sequence of characters that <code>control how characters extracted from the stream</code> are treated:</p>
<ul>
<li><p><code>Whitespace character</code>: the function will <code>read</code> and <code>ignore</code> <code>any whitespace characters</code> encountered before <code>the next non-whitespace character</code> (<code>whitespace characters</code> include <code>spaces</code>, <code>newline</code> and <code>tab characters</code>). <strong><code>A single whitespace in the format string validates any quantity of whitespace characters extracted from the stream (including none).</code></strong></p>
</li>
<li><p><code>Non-whitespace character, except format specifier (%)</code>: <code>Any character</code> that is not either <code>a whitespace character</code> (blank, newline or tab) or part of <code>a format specifier</code> (which begin with a % character) causes the function to <code>read the next character from the stream</code>, <code>compare it to this non-whitespace character and if it matches</code>, it is <code>discarded</code> and the function continues with the next character of format. <code>If the character does not match, the function fails, returning and leaving subsequent characters of the stream unread.</code></p>
</li>
<li><p><code>Format specifiers</code>: A sequence formed by <code>an initial percentage sign (%) indicates a format specifier</code>, which is used to specify <code>the type</code> and <code>format</code> of the data to be retrieved from the stream and <code>stored</code> into the locations pointed by the additional arguments.</p>
</li>
</ul>
<hr>
<p>A format specifier for <code>fscanf</code> follows this <code>prototype</code>:</p>
<p><code>%[*][width][length]specifier</code></p>
<p>Where <code>the specifier character</code> at the end is <code>the most significant component</code>, since it defines which characters are extracted, their <code>interpretation</code> and <code>the type of its corresponding argument</code>:</p>
<table>
<thead>
<tr>
<th align="center">specifier</th>
<th align="center">Description</th>
<th align="center">Characters extracted</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>i</code>, <code>u</code></td>
<td align="center"><code>Integer</code></td>
<td align="center">Any number of <code>digits</code>, optionally preceded by a sign (<code>+</code> or <code>-</code>). <code>Decimal digits</code> assumed by default (0-9), but a <code>0</code> prefix introduces <code>octal digits</code> (0-7), and <code>0x</code> <code>hexadecimal digits</code> (0-f).</td>
</tr>
<tr>
<td align="center"><code>d</code></td>
<td align="center"><code>Decimal integer</code></td>
<td align="center">Any number of decimal digits (0-9), optionally preceded by a sign (+ or -).</td>
</tr>
<tr>
<td align="center"><code>o</code></td>
<td align="center"><code>Octal integer</code></td>
<td align="center">Any number of <code>octal digits</code> (0-7), optionally preceded by a sign (+ or -).</td>
</tr>
<tr>
<td align="center"><code>x</code></td>
<td align="center"><code>Hexadecimal integer</code></td>
<td align="center">Any number of <code>hexadecimal digits</code> (0-9, a-f, A-F), optionally preceded by 0x or 0X, and all optionally preceded by a sign (+ or -).</td>
</tr>
<tr>
<td align="center"><code>f</code>, <code>e</code>, <code>g</code>, <code>a</code></td>
<td align="center"><code>Floating point number</code></td>
<td align="center"><code>A series of decimal digits</code>, <code>optionally containing a decimal point</code>, optionally preceeded by a sign (<code>+</code> or <code>-</code>) and optionally followed by the <code>e</code> or <code>E</code> character and <code>a decimal integer</code>. Implementations complying with <code>C99</code> also <code>support hexadecimal floating-point format</code> when preceded by <code>0x</code> or <code>0X</code>.</td>
</tr>
<tr>
<td align="center"><code>c</code></td>
<td align="center"><code>Character</code></td>
<td align="center"><code>The next character</code>. <code>If a width other than 1 is specified, the function reads exactly width characters </code>and stores them in the successive locations of the array passed as argument. <code>No null character is appended at the end.</code></td>
</tr>
<tr>
<td align="center"><code>s</code></td>
<td align="center"><code>String of characters</code></td>
<td align="center"><code>Any number of non-whitespace characters</code>, stopping at <code>the first whitespace character</code> found. <code>A terminating null character</code> is automatically added <code>at the end of the stored sequence</code>.</td>
</tr>
<tr>
<td align="center"><code>p</code></td>
<td align="center"><code>Pointer address</code></td>
<td align="center"><code>A sequence of characters</code> representing <code>a pointer</code>.</td>
</tr>
<tr>
<td align="center"><code>[characters]</code></td>
<td align="center">Scanset</td>
<td align="center"><code>Any number of the characters specified between the brackets</code>.</td>
</tr>
<tr>
<td align="center"><code>[^characters]</code></td>
<td align="center"><code>Negated</code> scanset</td>
<td align="center">Any number of characters <code>none</code> of them specified as characters between the brackets.</td>
</tr>
<tr>
<td align="center"><code>n</code></td>
<td align="center">Count</td>
<td align="center"><code>No input is consumed</code>. <code>The number of characters read so far from stream is stored in the pointed location.</code></td>
</tr>
<tr>
<td align="center"><code>%</code></td>
<td align="center"><code>%</code></td>
<td align="center">A <code>%</code> followed by another <code>%</code> matches a single <code>%</code>.</td>
</tr>
</tbody></table>
<p>Except for <code>n</code>, <code>at least one character</code> shall be <code>consumed</code> by any specifier. Otherwise the match fails, and the scan ends there.</p>
<p>The format specifier can also contain sub-specifiers: <code>asterisk (*)</code>, <code>width</code> and <code>length</code> (in that order), which are optional and follow these specifications:</p>
<table>
<thead>
<tr>
<th align="center">sub-specifier</th>
<th align="center">description</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>*</code></td>
<td align="center">An optional starting <code>asterisk</code> indicates that the data is to be read from the stream <code>but ignored</code> (i.e. it is not stored in the location pointed by an argument).</td>
</tr>
<tr>
<td align="center"><code>width</code></td>
<td align="center">Specifiesthe <code>maximum number of characters</code> to be read in the current reading operation (<code>optional</code>).</td>
</tr>
<tr>
<td align="center"><code>length</code></td>
<td align="center">One of <code>hh</code>, <code>h</code>, <code>l</code>, <code>ll</code>, <code>j</code>, <code>z</code>, <code>t</code>, <code>L</code> (optional). This <code>alters</code> the expected type of the storage pointed by the corresponding argument.</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center"><strong>length</strong><code>\</code><strong>specifiers</strong></th>
<th align="center">d i</th>
<th align="center">u o x</th>
<th align="center">f e g a</th>
<th align="center">c s [] [^]</th>
<th align="center">p</th>
<th align="center">n</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>(none)</code></td>
<td align="center"><code>int*</code></td>
<td align="center"><code>unsigned int*</code></td>
<td align="center"><code>float*</code></td>
<td align="center"><code>char*</code></td>
<td align="center"><code>void**</code></td>
<td align="center"><code>int*</code></td>
</tr>
<tr>
<td align="center"><code>hh</code></td>
<td align="center"><code>signed char*</code></td>
<td align="center"><code>unsigned char*</code></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"><code>signed char*</code></td>
</tr>
<tr>
<td align="center"><code>h</code></td>
<td align="center"><code>short int*</code></td>
<td align="center"><code>unsigned short int*</code></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"><code>short int*</code></td>
</tr>
<tr>
<td align="center"><code>l</code></td>
<td align="center"><code>long int*</code></td>
<td align="center"><code>unsigned long int*</code></td>
<td align="center"><code>double*</code></td>
<td align="center"><code>wchar_t*</code></td>
<td align="center"></td>
<td align="center"><code>long int*</code></td>
</tr>
<tr>
<td align="center"><code>ll</code></td>
<td align="center"><code>long long int*</code></td>
<td align="center"><code>unsigned long long int*</code></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"><code>long long int*</code></td>
</tr>
<tr>
<td align="center"><code>j</code></td>
<td align="center"><code>intmax_t*</code></td>
<td align="center"><code>uintmax_t*</code></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"><code>intmax_t*</code></td>
</tr>
<tr>
<td align="center"><code>z</code></td>
<td align="center"><code>size_t*</code></td>
<td align="center"><code>size_t*</code></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"><code>size_t*</code></td>
</tr>
<tr>
<td align="center"><code>t</code></td>
<td align="center"><code>ptrdiff_t*</code></td>
<td align="center"><code>ptrdiff_t*</code></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"><code>ptrdiff_t*</code></td>
</tr>
<tr>
<td align="center"><code>L</code></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"><code>long double*</code></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<p><strong>… (additional arguments)</strong></p>
<p>Depending on the format string, the function may expect a sequence of additional arguments, <code>each containing a pointer to allocated storage</code> where <code>the interpretation of the extracted characters is stored with the appropriate type</code>.</p>
<p>There should be at least <code>as many of these arguments as</code> the number of values stored by the format specifiers. <code>Additional arguments are ignored by the function.</code></p>
<p>These arguments are expected to be <code>pointers</code>: to store the result of a fscanf operation on <code>a regular variable</code>, its name should be preceded by <code>the reference operator (&amp;)</code>.</p>
<p><strong><code>Return Value</code></strong></p>
<p>On <code>success</code>, the function returns <code>the number of items of the argument list</code> successfully filled. This count can match the expected number of items or be less (even zero) due to a matching failure, a reading error, or the reach of the end-of-file.</p>
<p>If a reading error happens or the end-of-file is reached while reading, the proper indicator is set (<code>feof</code> or <code>ferror</code>). And, <code>if either happens before any data could be successfully read, EOF is returned</code>.</p>
<p><strong><code>Example</code></strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;* fscanf example *&#x2F;
#include &lt;stdio.h&gt;

int main ()
&#123;
  char str [80];
  float f;
  FILE * pFile;

  pFile &#x3D; fopen (&quot;myfile.txt&quot;,&quot;w+&quot;);
  fprintf (pFile, &quot;%f %s&quot;, 3.1416, &quot;PI&quot;);
  rewind (pFile);
  fscanf (pFile, &quot;%f&quot;, &amp;f);
  fscanf (pFile, &quot;%s&quot;, str);
  fclose (pFile);
  printf (&quot;I have read: %f and %s \n&quot;,f,str);
  return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>This sample code creates <code>a file called myfile.txt</code> and writes <code>a float number</code> and <code>a string</code> to it. Then, the stream is <code>rewinded</code> and both values are read with <code>fscanf</code>.</p>
<p>输出</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">I have read: <span class="token number">3.141600</span> and PI<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h4 id="scanf"><a href="#scanf" class="headerlink" title="scanf"></a>scanf</h4><p><code>scanf</code>: <a href="https://cplusplus.com/reference/cstdio/scanf/">https://cplusplus.com/reference/cstdio/scanf/</a> 。</p>
<p><code>int scanf ( const char * format, ... );</code></p>
<p><strong><code>Read formatted data from stdin</code></strong></p>
<p>Reads data from <code>stdin</code> and stores them according to the parameter <strong>format</strong> into the locations pointed by the additional arguments.</p>
<p>The additional arguments should point to already allocated objects of the type specified by their corresponding format specifier within <code>the format string</code>.</p>
<p><strong><code>Parameters</code></strong></p>
<p><strong>format</strong></p>
<p>A <code>format specifier</code> for scanf follows this prototype:</p>
<p><code>%[*][width][length]specifier</code></p>
<p><strong>… (additional arguments)</strong></p>
<p>Depending on the format string, the function may expect a sequence of additional arguments, each containing a <code>pointer</code> to allocated storage where the interpretation of the extracted characters is stored with the appropriate type.</p>
<p>There should be at least as many of these arguments as the number of values stored by the format specifiers. Additional arguments are ignored by the function.</p>
<p>These arguments are expected to be pointers: to store the result of a scanf operation on a regular variable, its name should be preceded by <code>the reference operator (&amp;)</code>.</p>
<p><strong><code>Return Value</code></strong></p>
<p>On success, the function returns <code>the number of items of the argument list successfully filled</code>. This count can match the expected number of items or be less (even zero) due to a matching failure, a reading error, or the reach of <code>the end-of-file</code>.</p>
<p>If a reading error happens or the end-of-file is reached while reading, the proper indicator is set (<code>feof</code> or <code>ferror</code>). And, if either happens before any data could be successfully read, <code>EOF</code> is returned.</p>
<p>If an encoding error happens interpreting wide characters, the function sets <code>errno</code> to EILSEQ.</p>
<p><strong><code>Example</code></strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;* scanf example *&#x2F;
#include &lt;stdio.h&gt;

int main ()
&#123;
  char str [80];
  int i;

  printf (&quot;Enter your family name: &quot;);
  scanf (&quot;%79s&quot;,str);  
  printf (&quot;Enter your age: &quot;);
  scanf (&quot;%d&quot;,&amp;i);
  printf (&quot;Mr. %s , %d years old.\n&quot;,str,i);
  printf (&quot;Enter a hexadecimal number: &quot;);
  scanf (&quot;%x&quot;,&amp;i);
  printf (&quot;You have entered %#x (%d).\n&quot;,i,i);
  
  return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>This example demonstrates some of the types that can be read with <code>scanf</code>:</p>
<pre class="line-numbers language-none"><code class="language-none">Enter your family name: Soulie
Enter your age: 29
Mr. Soulie , 29 years old.
Enter a hexadecimal number: ff
You have entered 0xff (255).<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="Character-input-output"><a href="#Character-input-output" class="headerlink" title="Character input&#x2F;output"></a>Character input&#x2F;output</h3><ul>
<li><p><code>fgetc</code>: Get character from stream (function)</p>
</li>
<li><p><code>fputc</code>: Write character to stream (function)</p>
</li>
<li><p><code>fputs</code>: Write string to stream (function)</p>
</li>
<li><p><code>puts</code>: Write string to stdout (function)</p>
</li>
</ul>
<h4 id="fgetc"><a href="#fgetc" class="headerlink" title="fgetc"></a>fgetc</h4><p><code>fgetc</code>: <a href="https://cplusplus.com/reference/cstdio/fgetc/">https://cplusplus.com/reference/cstdio/fgetc/</a> 。</p>
<p><code>int fgetc ( FILE * stream );</code></p>
<p><strong><code>Get character from stream</code></strong></p>
<p>Returns <code>the character</code> currently pointed by the internal file position indicator of the specified stream. <code>The internal file position indicator is then advanced to the next character</code>.</p>
<p>If the stream is at <code>the end-of-file</code> when called, the function returns <code>EOF</code> and <code>sets the end-of-file indicator</code> for the stream (<code>feof</code>).</p>
<p>If a read error occurs, the function returns <code>EOF</code> and sets <code>the error indicator</code> for the stream (<code>ferror</code>).</p>
<p><code>fgetc</code> and <code>getc</code> are equivalent, except that <code>getc</code> may be implemented as a <code>macro</code> in <code>some libraries</code>.</p>
<p><strong><code>Parameters</code></strong></p>
<p><strong>stream</strong></p>
<ol>
<li>Pointer to a <code>FILE</code> object that <code>identifies an input stream</code>.</li>
</ol>
<p><strong><code>Return Value</code></strong></p>
<p>On success, <code>the character read is returned</code> (promoted to <code>an int value</code>).</p>
<p><code>The return type</code> is int to accommodate for the special value <code>EOF</code>, which indicates failure:</p>
<ol>
<li><p>If the position indicator was at <code>the end-of-file</code>, the function returns <code>EOF</code> and <code>sets the eof indicator (feof) of stream</code>.</p>
</li>
<li><p>If <code>some other reading error happens</code>, the function also returns <code>EOF</code>, but <code>sets its error indicator (ferror)</code> instead.</p>
</li>
</ol>
<p><strong><code>Example</code></strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;* fgetc example: money counter *&#x2F;
#include &lt;stdio.h&gt;
int main ()
&#123;
  FILE * pFile;
  int c;
  int n &#x3D; 0;
  pFile&#x3D;fopen (&quot;myfile.txt&quot;,&quot;r&quot;);
  if (pFile&#x3D;&#x3D;NULL) perror (&quot;Error opening file&quot;);
  else
  &#123;
    do &#123;
      c &#x3D; fgetc (pFile);
      if (c &#x3D;&#x3D; &#39;$&#39;) n++;
    &#125; while (c !&#x3D; EOF);
    fclose (pFile);
    printf (&quot;The file contains %d dollar sign characters ($).\n&quot;,n);
  &#125;
  return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>This program reads an existing file called <code>myfile.txt</code> character by character and uses the <code>n</code> variable to <code>count</code> how many dollar characters (<code>$</code>) the file contains.</p>
<h4 id="fputc"><a href="#fputc" class="headerlink" title="fputc"></a>fputc</h4><p><code>fputc</code>: <a href="https://cplusplus.com/reference/cstdio/fputc/">https://cplusplus.com/reference/cstdio/fputc/</a> 。</p>
<p><code>int fputc ( int character, FILE * stream );</code></p>
<p><strong><code>将字符写入流</code></strong></p>
<p><code>Writes a character</code> to <code>the stream</code> and <code>advances</code> the position indicator.</p>
<p>The character is written <code>at the position indicated by the internal position indicator of the stream</code>, which is then automatically advanced by <code>one</code>.</p>
<p><strong><code>参数</code></strong></p>
<p><strong>character</strong></p>
<ol>
<li><p>The <code>int promotion of the character</code> to be written.</p>
</li>
<li><p>The value is internally converted to <code>an unsigned char</code> when written.</p>
</li>
</ol>
<p><strong>stream</strong></p>
<ol>
<li>Pointer to a <code>FILE</code> object that identifies <code>an output stream</code>.</li>
</ol>
<p><strong><code>返回值</code></strong></p>
<p>On success, the <code>character</code> written is <code>returned</code>.</p>
<p>If a writing <code>error</code> occurs, <code>EOF</code> is returned and the error indicator (ferror) is set.</p>
<p><strong><code>例子</code></strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;* fputc example: alphabet writer *&#x2F;
#include &lt;stdio.h&gt;

int main ()
&#123;
  FILE * pFile;
  char c;

  pFile &#x3D; fopen (&quot;alphabet.txt&quot;,&quot;w&quot;);
  if (pFile!&#x3D;NULL) &#123;

    for (c &#x3D; &#39;A&#39; ; c &lt;&#x3D; &#39;Z&#39; ; c++)
      fputc ( c , pFile );

    fclose (pFile);
  &#125;
  return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>This program <code>creates a file</code> called <code>alphabet.txt</code> and writes <code>ABCDEFGHIJKLMNOPQRSTUVWXYZ</code> to it.</p>
<h4 id="fputs"><a href="#fputs" class="headerlink" title="fputs"></a>fputs</h4><p><code>fputs</code>: <a href="https://cplusplus.com/reference/cstdio/fputs/">https://cplusplus.com/reference/cstdio/fputs/</a> 。</p>
<p><code>int fputs ( const char * str, FILE * stream );</code></p>
<p><strong><code>Write string to stream</code></strong></p>
<p>Writes the <code>C string</code> pointed by <code>str</code> to the stream.</p>
<p>The function begins <code>copying from the address</code> specified (<code>str</code>) until it reaches <code>the terminating null character</code> (‘\0’). <code>This terminating null-character is not copied to the stream.</code></p>
<p>Notice that <code>fputs</code> not only differs from <code>puts</code> in that the destination <code>stream</code> can be specified, but also <code>fputs</code> does not write additional characters, while <code>puts</code> appends <code>a newline character</code> at the end automatically.</p>
<p><strong><code>Parameters</code></strong></p>
<p><strong>str</strong></p>
<ol>
<li><code>C string</code> with the content to be written to <code>stream</code>.</li>
</ol>
<p><strong>stream</strong></p>
<ol start="2">
<li><code>Pointer to a FILE object</code> that identifies an output stream.</li>
</ol>
<p><strong><code>Return Value</code></strong></p>
<p>On <code>success</code>, a <code>non-negative</code> value is returned.</p>
<p>On <code>error</code>, the function returns <code>EOF</code> and sets the error indicator (<code>ferror</code>).</p>
<p><strong><code>Example</code></strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;* fputs example *&#x2F;
#include &lt;stdio.h&gt;

int main ()
&#123;
   FILE * pFile;
   char sentence [256];

   printf (&quot;Enter sentence to append: &quot;);
   fgets (sentence,256,stdin);
   pFile &#x3D; fopen (&quot;mylog.txt&quot;,&quot;a&quot;);
   fputs (sentence,pFile);
   fclose (pFile);
   return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>This program allows to <code>append a line</code> to a file called <code>mylog.txt</code> each time it is run.</p>
<h4 id="puts"><a href="#puts" class="headerlink" title="puts"></a>puts</h4><p><code>puts</code>: <a href="https://cplusplus.com/reference/cstdio/puts/">https://cplusplus.com/reference/cstdio/puts/</a> 。</p>
<p><code>int puts ( const char * str );</code></p>
<p><strong><code>Write string to stdout</code></strong></p>
<p>Writes the <code>C string</code> pointed by <code>str</code> to the standard output (<code>stdout</code>) and <code>appends a newline character (&#39;\n&#39;)</code>.</p>
<p>The function begins copying from the address specified (<code>str</code>) until it reaches the <code>terminating null character</code> (‘\0’). <code>This terminating null-character is not copied to the stream.</code></p>
<p>Notice that <code>puts</code> not only differs from <code>fputs</code> in that it uses <code>stdout as destination</code>, but <code>it also appends a newline character at the end automatically</code> (which <code>fputs</code> does not).</p>
<p><strong><code>Parameters</code></strong></p>
<p><strong>str</strong></p>
<ol>
<li><code>C string</code> to be printed.</li>
</ol>
<p><strong><code>Return Value</code></strong></p>
<p>On <code>success</code>, a <code>non-negative value</code> is returned.</p>
<p>On <code>error</code>, the function returns <code>EOF</code> and <code>sets the error indicator (ferror)</code>.</p>
<p><strong><code>Example</code></strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;* puts example : hello world! *&#x2F;
#include &lt;stdio.h&gt;

int main ()
&#123;
  char string [] &#x3D; &quot;Hello world!&quot;;
  puts (string);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>输出</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Hello world<span class="token operator">!</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="Direct-input-output"><a href="#Direct-input-output" class="headerlink" title="Direct input&#x2F;output"></a>Direct input&#x2F;output</h3><ul>
<li><p><code>fread</code>: Read block of data from stream (function)</p>
</li>
<li><p><code>fwrite</code>: Write block of data to stream (function)</p>
</li>
</ul>
<h4 id="fread"><a href="#fread" class="headerlink" title="fread"></a>fread</h4><p><code>fread</code>: <a href="https://cplusplus.com/reference/cstdio/fread/">https://cplusplus.com/reference/cstdio/fread/</a> 。</p>
<p><code>size_t fread ( void * ptr, size_t size, size_t count, FILE * stream );</code></p>
<p><strong><code>Read block of data from stream</code></strong></p>
<p><code>Reads an array of count elements</code>, each one with <code>a size of size bytes</code>, from the stream and <code>stores them in the block of memory specified by ptr</code>.</p>
<p>The position indicator of the stream is <code>advanced</code> by the <code>total amount of bytes read</code>.</p>
<p>The <code>total amount of bytes read</code> if successful is (<code>size*count</code>).</p>
<p><strong><code>Parameters</code></strong></p>
<p><strong>ptr</strong></p>
<ol>
<li><code>Pointer to a block of memory</code> with a size of at least (<code>size*count</code>) bytes, converted to a <code>void*</code>.</li>
</ol>
<p><strong>size</strong></p>
<ol>
<li><code>Size</code>, <code>in bytes</code>, of each element to be read. <code>size_t</code> is an unsigned integral type.</li>
</ol>
<p><strong>count</strong></p>
<ol>
<li><code>Number of elements</code>, each one with <code>a size of size bytes</code>. <code>size_t</code> is an unsigned integral type.</li>
</ol>
<p><strong>stream</strong></p>
<ol>
<li><code>Pointer</code> to a <code>FILE object</code> that specifies an input stream.</li>
</ol>
<p><strong><code>Return Value</code></strong></p>
<p><code>The total number of elements</code> successfully read is returned.</p>
<p>If this number <code>differs</code> from the <code>count</code> parameter, either a reading <code>error</code> occurred or the <code>end-of-file</code> was reached while reading. In both cases, the proper indicator is set, which can be checked with <code>ferror</code> and <code>feof</code>, respectively.</p>
<p>If either <code>size</code> or <code>count</code> is zero, the function returns <code>zero</code> and both the stream state and the content pointed by <code>ptr</code> remain <code>unchanged</code>.</p>
<p><code>size_t</code> is an unsigned integral type.</p>
<p><strong><code>Example</code></strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;* fread example: read an entire file *&#x2F;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main () &#123;
  FILE * pFile;
  long lSize;
  char * buffer;
  size_t result;

  pFile &#x3D; fopen ( &quot;myfile.bin&quot; , &quot;rb&quot; );
  if (pFile&#x3D;&#x3D;NULL) &#123;fputs (&quot;File error&quot;,stderr); exit (1);&#125;

  &#x2F;&#x2F; obtain file size:
  fseek (pFile , 0 , SEEK_END);
  lSize &#x3D; ftell (pFile);
  rewind (pFile);

  &#x2F;&#x2F; allocate memory to contain the whole file:
  buffer &#x3D; (char*) malloc (sizeof(char)*lSize);
  if (buffer &#x3D;&#x3D; NULL) &#123;fputs (&quot;Memory error&quot;,stderr); exit (2);&#125;

  &#x2F;&#x2F; copy the file into the buffer:
  result &#x3D; fread (buffer,1,lSize,pFile);
  if (result !&#x3D; lSize) &#123;fputs (&quot;Reading error&quot;,stderr); exit (3);&#125;

  &#x2F;* the whole file is now loaded in the memory buffer. *&#x2F;

  &#x2F;&#x2F; terminate
  fclose (pFile);
  free (buffer);
  return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>This code loads <code>myfile.bin</code> into a <code>dynamically</code> allocated <code>memory buffer</code>, which can be used to <code>manipulate</code> the content of a file as <code>an array</code>.</p>
<p>输出</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">File error <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h4 id="fwrite"><a href="#fwrite" class="headerlink" title="fwrite"></a>fwrite</h4><p><code>fwrite</code>: <a href="https://cplusplus.com/reference/cstdio/fwrite/">https://cplusplus.com/reference/cstdio/fwrite/</a> 。</p>
<p><code>size_t fwrite ( const void * ptr, size_t size, size_t count, FILE * stream );</code></p>
<p><strong><code>Write block of data to stream</code></strong></p>
<p>Writes <code>an array of count elements</code>, each one with <code>a size of size bytes</code>, from <code>the block of memory pointed by ptr</code> to <code>the current position in the stream</code>.</p>
<p>The <code>position indicator</code> of the stream is advanced by <code>the total number of bytes written</code>.</p>
<p>Internally, <code>the function interprets the block pointed by ptr as if it was an array of (size*count) elements of type unsigned char</code>, and <code>writes them sequentially to stream</code> as if <code>fputc was called for each byte</code>.</p>
<p><strong><code>Parameters</code></strong></p>
<p><strong>ptr</strong></p>
<ol>
<li><code>Pointer to the array of elements to be written</code>, converted to a const <code>void*</code>.</li>
</ol>
<p><strong>size</strong></p>
<ol>
<li><code>Size in bytes of each element</code> to be written. <code>size_t</code> is an unsigned integral type.</li>
</ol>
<p><strong>count</strong></p>
<ol>
<li><code>Number of elements</code>, each one with a <code>size</code> of size bytes. <code>size_t</code> is an unsigned integral type.</li>
</ol>
<p><strong>stream</strong></p>
<ol>
<li><code>Pointer</code> to <code>a FILE object</code> that specifies an output stream.</li>
</ol>
<p><strong><code>Return Value</code></strong></p>
<p>The <code>total number of elements</code> <strong>successfully</strong> written is returned.</p>
<p>If <code>this number</code> differs from the <code>count</code> parameter, <code>a writing error prevented the function from completing</code>. In this case, <code>the error indicator (ferror)</code> will be set for the stream.</p>
<p>If either <code>size</code> or <code>count</code> is <code>zero</code>, the function returns <code>zero</code> and <code>the error indicator remains unchanged.</code></p>
<p><code>size_t</code> is an unsigned integral type.</p>
<p><strong><code>Example</code></strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;* fwrite example : write buffer *&#x2F;
#include &lt;stdio.h&gt;

int main ()
&#123;
  FILE * pFile;
  char buffer[] &#x3D; &#123; &#39;x&#39; , &#39;y&#39; , &#39;z&#39; &#125;;
  pFile &#x3D; fopen (&quot;myfile.bin&quot;, &quot;wb&quot;);
  fwrite (buffer , sizeof(char), sizeof(buffer), pFile);
  fclose (pFile);
  return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>A file called <code>myfile.bin</code> is created and <code>the content of the buffer is stored into it</code>. For <code>simplicity</code>, the <code>buffer</code> contains <code>char elements</code> but <strong><code>it can contain any other type</code></strong>.</p>
<p><code>sizeof(buffer)</code> is the length of the array <code>in bytes</code> (in this case it is <code>three</code>, because the array has <code>three</code> elements of <code>one byte each</code>).</p>
<h3 id="File-positioning"><a href="#File-positioning" class="headerlink" title="File positioning"></a>File positioning</h3><ul>
<li><p><code>fseek</code>: Reposition stream position indicator (function)</p>
</li>
<li><p><code>rewind</code>: Set position of stream to the beginning (function)</p>
</li>
</ul>
<h4 id="fseek"><a href="#fseek" class="headerlink" title="fseek"></a>fseek</h4><p><code>fseek</code>: <a href="https://cplusplus.com/reference/cstdio/fseek/">https://cplusplus.com/reference/cstdio/fseek/</a> 。</p>
<p><code>int fseek ( FILE * stream, long int offset, int origin );</code></p>
<p><strong><code>Reposition stream position indicator</code></strong></p>
<p>Sets <code>the position indicator</code> associated with the stream to <code>a new position</code>.</p>
<p>For streams <code>open in binary mode</code>, the new position is defined by adding <code>offset</code> to a reference position specified by <code>origin</code>.</p>
<p>For streams <code>open in text mode</code>, offset shall either be <code>zero</code> or a value returned by a previous call to <code>ftell</code>, and origin shall necessarily be <code>SEEK_SET</code>.</p>
<p>If the function is called with other values for these arguments, support depends on <code>the particular system</code> and <code>library implementation</code> (non-portable).</p>
<p>The <code>end-of-file internal indicator</code> of the <code>stream</code> is cleared after a successful call to this function, and all effects from previous calls to <code>ungetc</code> on this <code>stream</code> are dropped.</p>
<p>On streams open for update (<code>read+write</code>), a call to <code>fseek</code> allows to switch between reading and writing.</p>
<p><strong><code>Parameters</code></strong></p>
<p><strong>stream</strong></p>
<ol>
<li><code>Pointer</code> to a <code>FILE</code> object that identifies the stream.</li>
</ol>
<p><strong>offset</strong></p>
<ol>
<li><p><code>Binary files</code>: Number of bytes to offset from <code>origin</code>.</p>
</li>
<li><p><code>Text files</code>: Either <code>zero</code>, or a <code>value</code> returned by <code>ftell</code>.</p>
</li>
</ol>
<p><strong>origin</strong></p>
<p>Position used as reference for the <code>offset</code>. It is specified by one of the following constants defined in <code>&lt;cstdio&gt;</code> exclusively to be used as arguments for this function:</p>
<table>
<thead>
<tr>
<th align="center">Constant</th>
<th align="center">Reference position</th>
</tr>
</thead>
<tbody><tr>
<td align="center">SEEK_SET</td>
<td align="center">Beginning of file</td>
</tr>
<tr>
<td align="center">SEEK_CUR</td>
<td align="center">Current position of the file pointer</td>
</tr>
<tr>
<td align="center">SEEK_END</td>
<td align="center"><code>End of file *</code></td>
</tr>
</tbody></table>
<p><code>* Library</code> implementations are allowed to not meaningfully support <code>SEEK_END</code> (therefore, code using it has no real standard portability).</p>
<p><strong><code>Return Value</code></strong></p>
<ol>
<li><p>If successful, the function returns <code>zero</code>.</p>
</li>
<li><p>Otherwise, it returns <code>non-zero</code> value.</p>
</li>
<li><p>If a read or write error occurs, the <code>error indicator</code> (<code>ferror</code>) is set.</p>
</li>
</ol>
<p><strong><code>Example</code></strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;* fseek example *&#x2F;
#include &lt;stdio.h&gt;

int main ()
&#123;
  FILE * pFile;
  pFile &#x3D; fopen ( &quot;example.txt&quot; , &quot;wb&quot; );
  fputs ( &quot;This is an apple.&quot; , pFile );
  fseek ( pFile , 9 , SEEK_SET );
  fputs ( &quot; sam&quot; , pFile );
  fclose ( pFile );
  return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>After this code is successfully executed, the file <code>example.txt</code> contains:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">This is a sample.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h4 id="rewind"><a href="#rewind" class="headerlink" title="rewind"></a>rewind</h4><p><code>rewind</code>: <a href="https://cplusplus.com/reference/cstdio/rewind/">https://cplusplus.com/reference/cstdio/rewind/</a> 。</p>
<p><code>void rewind ( FILE * stream );</code></p>
<p><strong><code>Set position of stream to the beginning</code></strong></p>
<p>Sets <code>the position indicator</code> associated with stream to <code>the beginning of the file</code>.</p>
<p>The <code>end-of-file</code> and <code>error</code> internal indicators associated to the <code>stream</code> are cleared after <code>a successful call</code> to this function, and all effects from previous calls to <code>ungetc</code> on this stream are dropped.</p>
<p>On streams open for <code>update (read+write)</code>, a call to <code>rewind</code> allows to <code>switch between reading and writing</code>.</p>
<p><strong><code>Parameters</code></strong></p>
<p><strong>stream</strong></p>
<ol>
<li><code>Pointer</code> to <code>a FILE object</code> that identifies the stream.</li>
</ol>
<p><strong><code>Return Value</code></strong></p>
<p><code>none</code></p>
<p><strong><code>Example</code></strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;* rewind example *&#x2F;
#include &lt;stdio.h&gt;

int main ()
&#123;
  int n;
  FILE * pFile;
  char buffer [27];

  pFile &#x3D; fopen (&quot;myfile.txt&quot;,&quot;w+&quot;);
  for ( n&#x3D;&#39;A&#39; ; n&lt;&#x3D;&#39;Z&#39; ; n++)
    fputc ( n, pFile);
  rewind (pFile);
  fread (buffer,1,26,pFile);
  fclose (pFile);
  buffer[26]&#x3D;&#39;\0&#39;;
  puts (buffer);
  return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>A file called <code>myfile.txt</code> is created for <code>reading and writing</code> and <code>filled with the alphabet</code>. The file is then <code>rewinded</code>, <code>read and its content is stored in a buffer</code>, that then is written to <code>the standard output</code>:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ABCDEFGHIJKLMNOPQRSTUVWXYZ<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="Error-handling"><a href="#Error-handling" class="headerlink" title="Error-handling"></a>Error-handling</h3><ul>
<li><code>feof</code>: Check end-of-file indicator (function)</li>
</ul>
<h4 id="feof"><a href="#feof" class="headerlink" title="feof"></a>feof</h4><p><code>feof</code>: <a href="https://cplusplus.com/reference/cstdio/feof/">https://cplusplus.com/reference/cstdio/feof/</a> 。</p>
<p><code>int feof ( FILE * stream );</code></p>
<p><strong><code>Check end-of-file indicator</code></strong></p>
<p>Checks whether the <code>end-of-File indicator</code> associated with <code>stream</code> is set, <code>returning a value different from zero</code> if it is.</p>
<p>This <code>indicator</code> is generally set by a previous operation on the <code>stream</code> that attempted to read at or past <code>the end-of-file</code>.</p>
<p>Notice that stream’s internal position indicator may point to the <code>end-of-file</code> for the next operation, but still, the <code>end-of-file</code> indicator may not be set until an operation attempts to read at that point.</p>
<p>This indicator is cleared by a call to <code>clearerr</code>, <code>rewind</code>, <code>fseek</code>, <code>fsetpos</code> or <code>freopen</code>. Although if <code>the position indicator</code> is not repositioned by such a call, the next i&#x2F;o operation is likely to set the indicator again.</p>
<p><strong><code>Parameters</code></strong></p>
<p><strong>stream</strong></p>
<ol>
<li><code>Pointer</code> to a <code>FILE</code> object that identifies the stream.</li>
</ol>
<p><strong><code>Return Value</code></strong></p>
<p><code>A non-zero value</code> is returned in the case that the <code>end-of-file</code> indicator associated with the stream is set.</p>
<p>Otherwise, <code>zero is returned</code>.</p>
<p><strong><code>Example</code></strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;* feof example: byte counter *&#x2F;
#include &lt;stdio.h&gt;

int main ()
&#123;
  FILE * pFile;
  int n &#x3D; 0;
  pFile &#x3D; fopen (&quot;myfile.txt&quot;,&quot;rb&quot;);
  if (pFile&#x3D;&#x3D;NULL) perror (&quot;Error opening file&quot;);
  else
  &#123;
    while (fgetc(pFile) !&#x3D; EOF) &#123;
      ++n;
    &#125;
    if (feof(pFile)) &#123;
      puts (&quot;End-of-File reached.&quot;);
      printf (&quot;Total number of bytes read: %d\n&quot;, n);
    &#125;
    else puts (&quot;End-of-File was not reached.&quot;);
    fclose (pFile);
  &#125;
  return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>This <code>code</code> opens the file called <code>myfile.txt</code>, and counts the number of characters that it contains by reading all of them one by one. The program <code>checks</code> whether <code>the end-of-file</code> was reached, and if so, <code>prints the total number of bytes read</code>.</p>
<h2 id="stdlib-h"><a href="#stdlib-h" class="headerlink" title="&lt;cstdlib&gt; (stdlib.h)"></a><code>&lt;cstdlib&gt;</code> (stdlib.h)</h2><p><code>&lt;cstdlib&gt; (stdlib.h)</code>: <a href="https://cplusplus.com/reference/cstdlib/">https://cplusplus.com/reference/cstdlib/</a> 。</p>
<p><code>&lt;cstdlib&gt; (stdlib.h)</code>: C Standard General Utilities Library.</p>
<h3 id="String-conversion"><a href="#String-conversion" class="headerlink" title="String conversion"></a>String conversion</h3><ul>
<li><p><code>atof</code>: Convert string to double (function)</p>
</li>
<li><p><code>atoi</code>: Convert string to integer (function)</p>
</li>
</ul>
<h4 id="atof"><a href="#atof" class="headerlink" title="atof"></a>atof</h4><p><code>atof</code>: <a href="https://cplusplus.com/reference/cstdlib/atof/">https://cplusplus.com/reference/cstdlib/atof/</a> 。</p>
<p><code>double atof (const char* str);</code></p>
<p><strong><code>Convert string to double</code></strong></p>
<p><code>Parses the C string str</code>, interpreting its content as <code>a floating point number</code> and returns its value as <code>a double</code>.</p>
<p>The function first <code>discards as many whitespace characters</code> (as in <code>isspace</code>) as necessary until <code>the first non-whitespace character is found</code>. Then, starting from this character, <code>takes as many characters as possible that are valid following a syntax resembling that of floating point literals</code>, and interprets them as <code>a numerical value</code>. <code>The rest of the string after the last valid character</code> is <code>ignored</code> and has no effect on the behavior of this function.</p>
<p>If <code>the first sequence of non-whitespace characters</code> in str <code>does not form a valid floating-point number</code> as just defined, or if <code>no such sequence exists</code> because either <code>str</code> is <code>empty</code> or contains only <code>whitespace characters</code>, no conversion is performed and <code>the function returns 0.0</code>.</p>
<p><strong><code>Parameters</code></strong></p>
<p><strong>str</strong></p>
<ol>
<li><code>C-string</code> beginning with the representation of <code>a floating-point number</code>.</li>
</ol>
<p><strong><code>Return Value</code></strong></p>
<p>On <code>success</code>, the function returns the converted floating point number as a <code>double value</code>.</p>
<p>If <code>no valid conversion</code> could be performed, the function returns <code>zero (0.0)</code>.</p>
<p>If the converted value would be out of the range of representable values by <code>a double</code>, it causes <code>undefined behavior</code>.</p>
<p>See <code>strtod</code> for a more <code>robust cross-platform alternative</code> when this is a possibility.</p>
<p><strong><code>Example</code></strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;* atof example: sine calculator *&#x2F;
#include &lt;stdio.h&gt;      &#x2F;* printf, fgets *&#x2F;
#include &lt;stdlib.h&gt;     &#x2F;* atof *&#x2F;
#include &lt;math.h&gt;       &#x2F;* sin *&#x2F;

int main ()
&#123;
  double n,m;
  double pi&#x3D;3.1415926535;
  char buffer[256];
  printf (&quot;Enter degrees: &quot;);
  fgets (buffer,256,stdin);
  n &#x3D; atof (buffer);
  m &#x3D; sin (n*pi&#x2F;180);
  printf (&quot;The sine of %f degrees is %f\n&quot; , n, m);
  return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>输出</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Enter degrees: <span class="token number">45</span>
The sine of <span class="token number">45.000000</span> degrees is <span class="token number">0.707101</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p><strong><code>Exceptions (C++)</code></strong></p>
<p><code>No-throw guarantee</code>: this function <code>never</code> throws exceptions.</p>
<p>If <code>str</code> does not point to <code>a valid C-string</code>, or if the converted value would be out of the range of values representable by <code>a double</code>, it causes <code>undefined behavior</code>.</p>
<h4 id="atoi"><a href="#atoi" class="headerlink" title="atoi"></a>atoi</h4><p><code>atoi</code>: <a href="https://cplusplus.com/reference/cstdlib/atoi/">https://cplusplus.com/reference/cstdlib/atoi/</a> 。</p>
<p><code>int atoi (const char * str);</code></p>
<p><strong><code>Convert string to integer</code></strong></p>
<p>Parses the C-string <code>str</code> interpreting its content as <code>an integral number</code>, which is returned as a value of type <code>int</code>.</p>
<p>The function first <code>discards as many whitespace characters</code> (as in <code>isspace</code>) as necessary until <code>the first non-whitespace character is found</code>. Then, starting from this character, takes an optional initial <code>plus</code> or <code>minus</code> sign followed by as <code>many base-10 digits</code> as possible, and interprets them as <code>a numerical value</code>.</p>
<p>The string can contain <code>additional characters</code> after those that <code>form the integral number</code>, which are <code>ignored</code> and <code>have no effect on the behavior of this function</code>.</p>
<p>If <code>the first sequence of non-whitespace characters</code> in <code>str</code> is <code>not a valid integral number</code>, or if <code>no such sequence</code> exists because either <code>str is empty</code> or it contains only <code>whitespace characters</code>, no conversion is performed and <code>zero is returned</code>.</p>
<p><strong><code>Parameters</code></strong></p>
<p><strong>str</strong></p>
<ol>
<li><code>C-string</code> beginning with the representation of an integral number.</li>
</ol>
<p><strong><code>Return Value</code></strong></p>
<p>On <code>success</code>, the function returns the converted integral number as an <code>int</code> value.</p>
<p>If the converted value would be out of the range of representable values by <code>an int</code>, it causes <code>undefined behavior</code>.</p>
<p>See <code>strtol</code> for a more <code>robust cross-platform alternative</code> when this is a possibility.</p>
<p><strong><code>Example</code></strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;* atoi example *&#x2F;
#include &lt;stdio.h&gt;      &#x2F;* printf, fgets *&#x2F;
#include &lt;stdlib.h&gt;     &#x2F;* atoi *&#x2F;

int main ()
&#123;
  int i;
  char buffer[256];
  printf (&quot;Enter a number: &quot;);
  fgets (buffer, 256, stdin);
  i &#x3D; atoi (buffer);
  printf (&quot;The value entered is %d. Its double is %d.\n&quot;,i,i*2);
  return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>输出</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Enter a number: <span class="token number">73</span>
The value entered is <span class="token number">73</span>. Its double is <span class="token number">146</span>.
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p><strong><code>Exceptions (C++)</code></strong></p>
<p><code>No-throw guarantee</code>: this function never throws exceptions.</p>
<p>If <code>str</code> does not point to a valid C-string, or if the converted value would be out of the range of values representable by an <code>int</code>, it causes <code>undefined behavior</code>.</p>
<h3 id="Pseudo-random-sequence-generation"><a href="#Pseudo-random-sequence-generation" class="headerlink" title="Pseudo-random sequence generation"></a>Pseudo-random sequence generation</h3><ul>
<li><code>rand</code>: Generate random number (function)</li>
</ul>
<h4 id="rand"><a href="#rand" class="headerlink" title="rand"></a>rand</h4><p><code>rand</code>: <a href="https://cplusplus.com/reference/cstdlib/rand/">https://cplusplus.com/reference/cstdlib/rand/</a> 。</p>
<p><code>int rand (void);</code></p>
<p><strong><code>Generate random number</code></strong></p>
<p>Returns a pseudo-random integral number in the range between <code>0</code> and <code>RAND_MAX</code>.</p>
<p>This number is generated by an algorithm that returns a sequence of apparently non-related numbers each time it is called. This algorithm uses a <code>seed</code> to generate the series, which should be initialized to some distinctive value using function <code>srand</code>.</p>
<p><code>RAND_MAX</code> is a constant defined in <code>&lt;cstdlib&gt;</code>.</p>
<p>A typical way to generate trivial pseudo-random numbers in a determined range using rand is to use the modulo of the returned value by the range span and add the initial value of the range:</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">v1 &#x3D; rand() % 100;         &#x2F;&#x2F; v1 in the range 0 to 99
v2 &#x3D; rand() % 100 + 1;     &#x2F;&#x2F; v2 in the range 1 to 100
v3 &#x3D; rand() % 30 + 1985;   &#x2F;&#x2F; v3 in the range 1985-2014<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>Notice though that <code>this modulo operation does not generate uniformly distributed random numbers in the span</code> (since in most cases this operation makes lower numbers slightly more likely).</p>
<p>C++ supports <code>a wide range of powerful tools</code> to generate random and pseudo-random numbers (see <code>&lt;random&gt;</code> for more info).</p>
<p><strong><code>Parameters</code></strong></p>
<p><strong>(none)</strong></p>
<p><strong><code>Return Value</code></strong></p>
<p><code>An integer value</code> between <code>0</code> and <code>RAND_MAX</code>.</p>
<p><strong><code>Example</code></strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;* rand example: guess the number *&#x2F;
#include &lt;stdio.h&gt;      &#x2F;* printf, scanf, puts, NULL *&#x2F;
#include &lt;stdlib.h&gt;     &#x2F;* srand, rand *&#x2F;
#include &lt;time.h&gt;       &#x2F;* time *&#x2F;

int main ()
&#123;
  int iSecret, iGuess;

  &#x2F;* initialize random seed: *&#x2F;
  srand (time(NULL));

  &#x2F;* generate secret number between 1 and 10: *&#x2F;
  iSecret &#x3D; rand() % 10 + 1;

  do &#123;
    printf (&quot;Guess the number (1 to 10): &quot;);
    scanf (&quot;%d&quot;,&amp;iGuess);
    if (iSecret&lt;iGuess) puts (&quot;The secret number is lower&quot;);
    else if (iSecret&gt;iGuess) puts (&quot;The secret number is higher&quot;);
  &#125; while (iSecret!&#x3D;iGuess);

  puts (&quot;Congratulations!&quot;);
  return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>In this example, <code>the random seed</code> is initialized to a value representing <code>the current time</code> (calling <code>time</code>) to generate a different value every time the program is run.</p>
<p>可能的输出</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Guess the number <span class="token punctuation">(</span><span class="token number">1</span> to <span class="token number">10</span><span class="token punctuation">)</span>: <span class="token number">5</span>
The secret number is higher
Guess the number <span class="token punctuation">(</span><span class="token number">1</span> to <span class="token number">10</span><span class="token punctuation">)</span>: <span class="token number">8</span>
The secret number is lower
Guess the number <span class="token punctuation">(</span><span class="token number">1</span> to <span class="token number">10</span><span class="token punctuation">)</span>: <span class="token number">7</span>
Congratulations<span class="token operator">!</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="Dynamic-memory-management"><a href="#Dynamic-memory-management" class="headerlink" title="Dynamic memory management"></a>Dynamic memory management</h3><ul>
<li><p><code>calloc</code>: Allocate and zero-initialize array (function)</p>
</li>
<li><p><code>free</code>: Deallocate memory block (function)</p>
</li>
</ul>
<h4 id="calloc"><a href="#calloc" class="headerlink" title="calloc"></a>calloc</h4><p><code>calloc</code>: <a href="https://cplusplus.com/reference/cstdlib/calloc/">https://cplusplus.com/reference/cstdlib/calloc/</a> 。</p>
<p><code>void* calloc (size_t num, size_t size);</code></p>
<p><strong><code>Allocate and zero-initialize array</code></strong></p>
<p><code>Allocates</code> a block of memory for <code>an array of num elements</code>, each of them <code>size</code> bytes long, and <code>initializes all its bits to zero</code>.</p>
<p><code>The effective result</code> is the <code>allocation</code> of <code>a zero-initialized memory block</code> of (<code>num*size</code>) bytes.</p>
<p>If <code>size</code> is <code>zero</code>, the return value depends on <code>the particular library implementation</code> (it may or may not be <code>a null pointer</code>), but <code>the returned pointer shall not be dereferenced</code>.</p>
<p><strong><code>Parameters</code></strong></p>
<p><strong>num</strong></p>
<ol>
<li>Number of elements to allocate.</li>
</ol>
<p><strong>size</strong></p>
<ol>
<li>Size of each element.</li>
</ol>
<p><code>size_t</code> is an unsigned integral type.</p>
<p><strong><code>Return Value</code></strong></p>
<p>On <code>success</code>, a <code>pointer</code> to <code>the memory block allocated by the function</code>.</p>
<p>The type of <code>this pointer</code> is always <code>void*</code>, which can be cast to <code>the desired type of data pointer</code> in order to be <code>dereferenceable</code>.</p>
<p>If the function <code>failed</code> to <code>allocate the requested block of memory</code>, <code>a null pointer</code> is returned.</p>
<p><strong><code>Example</code></strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;* calloc example *&#x2F;
#include &lt;stdio.h&gt;      &#x2F;* printf, scanf, NULL *&#x2F;
#include &lt;stdlib.h&gt;     &#x2F;* calloc, exit, free *&#x2F;

int main ()
&#123;
  int i,n;
  int * pData;
  printf (&quot;Amount of numbers to be entered: &quot;);
  scanf (&quot;%d&quot;,&amp;i);
  pData &#x3D; (int*) calloc (i,sizeof(int));
  if (pData&#x3D;&#x3D;NULL) exit (1);
  for (n&#x3D;0;n&lt;i;n++)
  &#123;
    printf (&quot;Enter number #%d: &quot;,n+1);
    scanf (&quot;%d&quot;,&amp;pData[n]);
  &#125;
  printf (&quot;You have entered: &quot;);
  for (n&#x3D;0;n&lt;i;n++) printf (&quot;%d &quot;,pData[n]);
  free (pData);
  return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>This program simply <code>stores numbers</code> and then <code>prints them out</code>. But the number of items it stores can be adapted each time the program is executed because it allocates the needed memory during runtime.</p>
<p><strong><code>Data races</code></strong></p>
<p><code>Only the storage referenced by the returned pointer is modified.</code> No other storage locations are accessed by the call.</p>
<p>If the function <code>reuses the same unit of storage released</code> by <code>a deallocation function</code> (such as <code>free</code> or <code>realloc</code>), the functions are synchronized <code>in such a way that the deallocation happens entirely before the next allocation</code>.</p>
<h4 id="free"><a href="#free" class="headerlink" title="free"></a>free</h4><p><code>free</code>: <a href="https://cplusplus.com/reference/cstdlib/free/">https://cplusplus.com/reference/cstdlib/free/</a> 。</p>
<p><code>void free (void* ptr);</code></p>
<p><strong><code>Deallocate memory block</code></strong></p>
<p><code>A block of memory</code> previously <code>allocated</code> by a call to <code>malloc</code>, <code>calloc</code> or <code>realloc</code> is <code>deallocated</code>, making it available again for <code>further allocations</code>.</p>
<p>If <code>ptr</code> does not point to <code>a block of memory allocated with the above functions</code>, it causes <code>undefined behavior</code>.</p>
<p>If <code>ptr</code> is a <code>null pointer</code>, the function <code>does nothing</code>.</p>
<p>Notice that <code>this function does not change the value of ptr itself</code>, hence it still points to <code>the same (now invalid) location</code>.</p>
<p><strong><code>Parameters</code></strong></p>
<p><strong>ptr</strong></p>
<ol>
<li><code>Pointer</code> to a memory block previously allocated with <code>malloc</code>, <code>calloc</code> or <code>realloc</code>.</li>
</ol>
<p><strong><code>Return Value</code></strong></p>
<p>none</p>
<p><strong><code>Example</code></strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;* free example *&#x2F;
#include &lt;stdlib.h&gt;     &#x2F;* malloc, calloc, realloc, free *&#x2F;

int main ()
&#123;
  int * buffer1, * buffer2, * buffer3;
  buffer1 &#x3D; (int*) malloc (100*sizeof(int));
  buffer2 &#x3D; (int*) calloc (100,sizeof(int));
  buffer3 &#x3D; (int*) realloc (buffer2,500*sizeof(int));
  free (buffer1);
  free (buffer3);
  return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>This program has no output</code>. It just demonstrates some ways to <code>allocate and free dynamic memory</code> using the <code>C stdlib</code> functions.</p>
<p><strong><code>Data races</code></strong></p>
<p>Only the storage referenced by <code>ptr</code> is modified. <code>No other storage locations are accessed by the call</code>.</p>
<p>If the function releases <code>a unit of storage</code> that is <code>reused</code> by a call to <code>allocation functions</code> (such as <code>calloc</code> or <code>malloc</code>), the functions are synchronized <code>in such a way</code> that <code>the deallocation happens entirely before the next allocation</code>.</p>
<p><strong><code>Exceptions (C++)</code></strong></p>
<p><code>No-throw guarantee</code>: this function never throws exceptions.</p>
<p>If <code>ptr</code> does not point to a memory block previously allocated with <code>malloc</code>, <code>calloc</code> or <code>realloc</code>, and is not a <code>null pointer</code>, it causes <code>undefined behavior</code>.</p>
<h2 id="string-h"><a href="#string-h" class="headerlink" title="&lt;cstring&gt; (string.h)"></a><code>&lt;cstring&gt;</code> (string.h)</h2><p><code>&lt;cstring&gt; (string.h)</code>: <a href="https://cplusplus.com/reference/cstring/">https://cplusplus.com/reference/cstring/</a> 。</p>
<p><code>&lt;cstring&gt; (string.h)</code>: C Strings.</p>
<h3 id="Copying"><a href="#Copying" class="headerlink" title="Copying"></a>Copying</h3><ul>
<li><code>memcpy</code>: Copy block of memory (function)</li>
</ul>
<h4 id="memcpy"><a href="#memcpy" class="headerlink" title="memcpy"></a>memcpy</h4><p><code>memcpy</code>: <a href="https://cplusplus.com/reference/cstring/memcpy/">https://cplusplus.com/reference/cstring/memcpy/</a> 。</p>
<p><code>void * memcpy ( void * destination, const void * source, size_t num );</code></p>
<p><strong><code>Copy block of memory</code></strong></p>
<p><code>Copies</code> the values of <code>num</code> bytes from the location pointed to by <code>source</code> directly to the memory block pointed to by <code>destination</code>.</p>
<p>The underlying type of the objects pointed to by both the <code>source</code> and <code>destination</code> pointers are irrelevant for this function; <code>The result is a binary copy of the data</code>.</p>
<p>The function does not check for any terminating null character <code>in source</code> - it always copies exactly <code>num</code> bytes.</p>
<p>To avoid <code>overflows</code>, the size of the arrays pointed to by both the <code>destination</code> and <code>source</code> parameters, shall be at least <code>num</code> bytes, and should not overlap (for <code>overlapping memory blocks</code>, <code>memmove</code> is a safer approach).</p>
<p><strong><code>Parameters</code></strong></p>
<p><strong>destination</strong></p>
<ol>
<li><code>Pointer to the destination array</code> where the content is to be copied, type-casted to a pointer of type <code>void*</code>.</li>
</ol>
<p><strong>source</strong></p>
<ol>
<li><code>Pointer to the source of data</code> to be copied, type-casted to a pointer of type const <code>void*</code>.</li>
</ol>
<p><strong>num</strong></p>
<ol>
<li><p><code>Number</code> of bytes to copy.</p>
</li>
<li><p><code>size_t</code> is an unsigned integral type.</p>
</li>
</ol>
<p><strong><code>Return Value</code></strong></p>
<p><code>destination</code> is returned.</p>
<p><strong><code>Example</code></strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;* memcpy example *&#x2F;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

struct &#123;
  char name[40];
  int age;
&#125; person, person_copy;

int main ()
&#123;
  char myname[] &#x3D; &quot;Pierre de Fermat&quot;;

  &#x2F;* using memcpy to copy string: *&#x2F;
  memcpy ( person.name, myname, strlen(myname)+1 );
  person.age &#x3D; 46;

  &#x2F;* using memcpy to copy structure: *&#x2F;
  memcpy ( &amp;person_copy, &amp;person, sizeof(person) );

  printf (&quot;person_copy: %s, %d \n&quot;, person_copy.name, person_copy.age );

  return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>输出</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">person_copy: Pierre de Fermat, <span class="token number">46</span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="Comparison"><a href="#Comparison" class="headerlink" title="Comparison"></a>Comparison</h3><ul>
<li><p><code>memcmp</code>: Compare two blocks of memory (function)</p>
</li>
<li><p><code>strcmp</code>: Compare two strings (function)</p>
</li>
</ul>
<h4 id="memcmp"><a href="#memcmp" class="headerlink" title="memcmp"></a>memcmp</h4><p><code>memcmp</code>: <a href="https://cplusplus.com/reference/cstring/memcmp/">https://cplusplus.com/reference/cstring/memcmp/</a> 。</p>
<p><code>int memcmp ( const void * ptr1, const void * ptr2, size_t num );</code></p>
<p><strong><code>Compare two blocks of memory</code></strong></p>
<p>Compares the <code>first num bytes</code> of <code>the block of memory</code> pointed by <code>ptr1</code> to <code>the first num bytes</code> pointed by <code>ptr2</code>, returning <code>zero</code> if they all <code>match</code> or <code>a value different from zero representing which is greater if they do not</code>.</p>
<p>Notice that, unlike <code>strcmp</code>, <code>the function does not stop comparing after finding a null character</code>.</p>
<p><strong><code>Parameters</code></strong></p>
<p><strong>ptr1</strong></p>
<ol>
<li><code>Pointer</code> to block of memory.</li>
</ol>
<p><strong>ptr2</strong></p>
<ol>
<li><code>Pointer</code> to block of memory.</li>
</ol>
<p><strong>num</strong></p>
<ol>
<li><code>Number of bytes</code> to compare.</li>
</ol>
<p><strong><code>Return Value</code></strong></p>
<p>Returns an <code>integral value</code> indicating <code>the relationship between the content of the memory blocks</code>:</p>
<table>
<thead>
<tr>
<th align="center"><strong>return value</strong></th>
<th align="center"><strong>indicates</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>&lt;0</code></td>
<td align="center"><code>the first byte</code> that does not match in both memory blocks <code>has a lower value</code> in <code>ptr1</code> than in <code>ptr2</code> (if evaluated as <code>unsigned char</code> values)</td>
</tr>
<tr>
<td align="center"><code>0</code></td>
<td align="center"><code>the contents of both memory blocks</code> are <code>equal</code></td>
</tr>
<tr>
<td align="center"><code>&gt;0</code></td>
<td align="center"><code>the first byte</code> that does not match in both memory blocks <code>has a greater value</code> in <code>ptr1</code> than in <code>ptr2</code> (if evaluated as <code>unsigned char</code> values)</td>
</tr>
</tbody></table>
<p><strong><code>Example</code></strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;* memcmp example *&#x2F;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main ()
&#123;
  char buffer1[] &#x3D; &quot;DWgaOtP12df0&quot;;
  char buffer2[] &#x3D; &quot;DWGAOTP12DF0&quot;;

  int n;

  n&#x3D;memcmp ( buffer1, buffer2, sizeof(buffer1) );

  if (n&gt;0) printf (&quot;&#39;%s&#39; is greater than &#39;%s&#39;.\n&quot;,buffer1,buffer2);
  else if (n&lt;0) printf (&quot;&#39;%s&#39; is less than &#39;%s&#39;.\n&quot;,buffer1,buffer2);
  else printf (&quot;&#39;%s&#39; is the same as &#39;%s&#39;.\n&quot;,buffer1,buffer2);

  return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>输出</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token string">'DWgaOtP12df0'</span> is greater than <span class="token string">'DWGAOTP12DF0'</span><span class="token builtin class-name">.</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><code>DWgAOtp12Df0</code> is <code>greater</code> than <code>DWGAOTP12DF0</code> because <code>the first non-matching character</code> in both words are <code>&#39;g&#39;</code> and <code>&#39;G&#39;</code> respectively, and <code>&#39;g&#39; (103) evaluates as greater than &#39;G&#39; (71)</code>.</p>
<h4 id="strcmp"><a href="#strcmp" class="headerlink" title="strcmp"></a>strcmp</h4><p><code>strcmp</code>: <a href="https://cplusplus.com/reference/cstring/strcmp/">https://cplusplus.com/reference/cstring/strcmp/</a> 。</p>
<p><code>int strcmp ( const char * str1, const char * str2 );</code></p>
<p><strong><code>Compare two strings</code></strong></p>
<p>Compares the <code>C string str1</code> to the <code>C string str2</code>.</p>
<p>This function starts comparing the <code>first character</code> of each string. If they <code>are equal to</code> each other, it <code>continues</code> with the following pairs until <code>the characters differ</code> or until a <code>terminating null-character</code> is reached.</p>
<p>This function performs <code>a binary comparison of the characters</code>.</p>
<p><strong><code>Parameters</code></strong></p>
<p><strong>str1</strong></p>
<ol>
<li><code>C string</code> to be compared.</li>
</ol>
<p><strong>str2</strong></p>
<ol start="2">
<li><code>C string</code> to be compared.</li>
</ol>
<p><strong><code>Return Value</code></strong></p>
<p>Returns an <code>integral value</code> indicating the <code>relationship</code> between the strings:</p>
<table>
<thead>
<tr>
<th align="center"><strong>return value</strong></th>
<th align="center"><strong>indicates</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>&lt;0</code></td>
<td align="center">the <code>first character</code> that does not match has a lower value in <code>ptr1</code> than in <code>ptr2</code></td>
</tr>
<tr>
<td align="center"><code>0</code></td>
<td align="center">the contents of both strings are <code>equal</code></td>
</tr>
<tr>
<td align="center"><code>&gt;0</code></td>
<td align="center">the first character that does not match has a <code>greater value</code> in <code>ptr1</code> than in <code>ptr2</code></td>
</tr>
</tbody></table>
<p><strong><code>Example</code></strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main ()
&#123;
  char key[] &#x3D; &quot;apple&quot;;
  char buffer[80];
  do &#123;
     printf (&quot;Guess my favorite fruit? &quot;);
     fflush (stdout);
     scanf (&quot;%79s&quot;,buffer);
  &#125; while (strcmp (key,buffer) !&#x3D; 0);
  puts (&quot;Correct answer!&quot;);
  return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>输出</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Guess my favourite fruit? orange
Guess my favourite fruit? apple
Correct answer<span class="token operator">!</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h3 id="Searching"><a href="#Searching" class="headerlink" title="Searching"></a>Searching</h3><ul>
<li><code>strtok</code>: Split string into tokens (function)</li>
</ul>
<h4 id="strtok"><a href="#strtok" class="headerlink" title="strtok"></a>strtok</h4><p><code>strtok</code>: <a href="https://cplusplus.com/reference/cstring/strtok/">https://cplusplus.com/reference/cstring/strtok/</a> 。</p>
<p><code>char * strtok ( char * str, const char * delimiters );</code></p>
<p><strong><code>Split string into tokens</code></strong></p>
<p>A sequence of calls to this function <code>split str into tokens</code>, which are sequences of contiguous characters separated by any of the characters that are part of <code>delimiters</code>.</p>
<p>On a first call, the function expects <code>a C string</code> as argument for <code>str</code>, <code>whose first character is used as the starting location to scan for tokens</code>. In subsequent calls, the function <code>expects a null pointer</code> and <code>uses the position right after the end of the last token as the new starting location for scanning</code>.</p>
<p>To determine <code>the beginning and the end of a token</code>, <code>the function first scans from the starting location for the first character not contained in delimiters</code> (which becomes the beginning of the token). And then <code>scans starting from this beginning of the token for the first character contained in delimiters, which becomes the end of the token</code>. The scan also stops if the terminating null character is found.</p>
<p>This <code>end of the token</code> is automatically replaced by a null-character, and the <code>beginning of the token</code> is returned by the function.</p>
<p>Once the terminating null character of <code>str</code> is found in a call to <code>strtok</code>, all subsequent calls to this function (<code>with a null pointer as the first argument</code>) return <code>a null pointer</code>.</p>
<p>The point where <code>the last token</code> was found is kept internally by the function to be used on the next call (particular library implementations are not required to avoid data races).</p>
<p><strong><code>Parameters</code></strong></p>
<p><strong>str</strong></p>
<ol>
<li><p><code>C string</code> to truncate.</p>
</li>
<li><p>Notice that this string is modified by being broken into smaller strings (tokens).</p>
</li>
<li><p>Alternativelly, <code>a null pointer</code> may be specified, in which case the function continues scanning where a previous successful call to the function ended.</p>
</li>
</ol>
<p><strong>delimiters</strong></p>
<ol>
<li><p><code>C string</code> containing <code>the delimiter characters</code>.</p>
</li>
<li><p>These can be different from one call to another.</p>
</li>
</ol>
<p><strong><code>Return Value</code></strong></p>
<ol>
<li><p>If <code>a token</code> is found, <code>a pointer to the beginning of the token.</code></p>
</li>
<li><p>Otherwise, <code>a null pointer</code>.</p>
</li>
<li><p><code>A null pointer</code> is always returned when the end of the string (i.e., <code>a null character</code>) is reached in the string being scanned.</p>
</li>
</ol>
<p><strong><code>Example</code></strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;* strtok example *&#x2F;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main ()
&#123;
  char str[] &#x3D;&quot;- This, a sample string.&quot;;
  char * pch;
  printf (&quot;Splitting string \&quot;%s\&quot; into tokens:\n&quot;,str);
  pch &#x3D; strtok (str,&quot; ,.-&quot;);
  while (pch !&#x3D; NULL)
  &#123;
    printf (&quot;%s\n&quot;,pch);
    pch &#x3D; strtok (NULL, &quot; ,.-&quot;);
  &#125;
  return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>输出</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Splitting string <span class="token string">"- This, a sample string."</span> into tokens:
This
a
sample
string<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h3><ul>
<li><code>memset</code>: Fill block of memory (function)</li>
</ul>
<h4 id="memset"><a href="#memset" class="headerlink" title="memset"></a>memset</h4><p><code>memset</code>: <a href="https://cplusplus.com/reference/cstring/memset/">https://cplusplus.com/reference/cstring/memset/</a> 。</p>
<p><code>void * memset ( void * ptr, int value, size_t num );</code></p>
<p><strong><code>Fill block of memory</code></strong></p>
<p>Sets the first <code>num</code> bytes of the block of memory pointed by <code>ptr</code> to the specified <code>value</code> (interpreted as an <code>unsigned char</code>).</p>
<p><strong><code>Parameters</code></strong></p>
<p><strong>ptr</strong></p>
<ol>
<li><code>Pointer</code> to the block of memory to fill.</li>
</ol>
<p><strong>value</strong></p>
<ol>
<li><code>Value to be set</code>. The value is passed as an <code>int</code>, but the function <code>fills</code> the block of memory using the <code>unsigned char</code> conversion of this <code>value</code>.</li>
</ol>
<p><strong>num</strong></p>
<ol>
<li><p><code>Number of bytes</code> to be set to the <code>value</code>.</p>
</li>
<li><p><code>size_t</code> is an <code>unsigned integral type</code>.</p>
</li>
</ol>
<p><strong><code>Return Value</code></strong></p>
<p><code>ptr</code> is returned.</p>
<p><strong><code>Example</code></strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;* memset example *&#x2F;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main ()
&#123;
  char str[] &#x3D; &quot;almost every programmer should know memset!&quot;;
  memset (str,&#39;-&#39;,6);
  puts (str);
  return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>输出</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">------ every programmer should know memset<span class="token operator">!</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<div id = "2"></div>

<h1 id="Containers"><a href="#Containers" class="headerlink" title="Containers"></a><code>Containers</code></h1><h2 id=""><a href="#" class="headerlink" title="&lt;array&gt;"></a><code>&lt;array&gt;</code></h2><p><code>&lt;array&gt;</code>: <a href="https://cplusplus.com/reference/array/">https://cplusplus.com/reference/array/</a> 。</p>
<p><code>&lt;array&gt;</code>: Array header (header).</p>
<h3 id="array"><a href="#array" class="headerlink" title="array"></a>array</h3><p><strong>Iterators:</strong></p>
<ul>
<li><code>begin</code>: Return iterator to beginning (public member function)</li>
</ul>
<h4 id="std-array-begin"><a href="#std-array-begin" class="headerlink" title="std::array::begin"></a><code>std::array::begin</code></h4><p><code>std::array::begin</code>: <a href="https://cplusplus.com/reference/array/array/begin/">https://cplusplus.com/reference/array/array/begin/</a> 。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">iterator begin() noexcept;const_iterator begin() const noexcept;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><strong><code>Return iterator to beginning</code></strong></p>
<p>Returns <strong>an iterator pointing to the first element</strong> in the array container.</p>
<p>Notice that, unlike member <code>array::front</code>, which returns a <code>reference</code> to the first element, this function returns a random access iterator pointing to it.</p>
<p>In zero-sized arrays, this function returns the same as <code>array::end</code>, but the returned iterator should <code>not be dereferenced</code>.</p>
<p><strong><code>Parameters</code></strong></p>
<p><strong>none</strong></p>
<p><strong><code>Return Value</code></strong></p>
<p><strong>An iterator to the beginning of the sequence.</strong></p>
<p>If the array object is <code>const-qualified</code>, the function returns a <code>const_iterator</code>. Otherwise, it returns an iterator.</p>
<p>Member types iterator and const_iterator are random access iterator types (<strong>pointing to an element and to a const element, respectively</strong>).</p>
<p><strong><code>Example</code></strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; array::begin example
#include &lt;iostream&gt;
#include &lt;array&gt;

int main ()
&#123;
  std::array&lt;int,5&gt; myarray &#x3D; &#123; 2, 16, 77, 34, 50 &#125;;

  std::cout &lt;&lt; &quot;myarray contains:&quot;;
  for ( auto it &#x3D; myarray.begin(); it !&#x3D; myarray.end(); ++it )
    std::cout &lt;&lt; &#39; &#39; &lt;&lt; *it;
  std::cout &lt;&lt; &#39;\n&#39;;

  return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>输出</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">myarray contains: <span class="token number">2</span> <span class="token number">16</span> <span class="token number">77</span> <span class="token number">34</span> <span class="token number">50</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><strong><code>Complexity</code></strong></p>
<p>Constant.</p>
<p><strong><code>Iterator validity</code></strong></p>
<p>No changes.</p>
<p><strong><code>Data races</code></strong></p>
<p>No contained elements are accessed by the call, but <strong>the iterator returned can be used to access or modify elements.</strong> Concurrently accessing or modifying different elements is safe.</p>
<p><strong><code>Exception safety</code></strong></p>
<p>No-throw guarantee: this member function never throws exceptions.</p>
<p>The copy construction or assignment of the returned iterator is also guaranteed to never throw.</p>
<h2 id="-1"><a href="#-1" class="headerlink" title="&lt;map&gt;"></a><code>&lt;map&gt;</code></h2><p><code>&lt;map&gt;</code>: <a href="https://cplusplus.com/reference/map/">https://cplusplus.com/reference/map/</a> 。</p>
<p><code>&lt;map&gt;</code>: Map header (header).</p>
<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p><strong>Capacity:</strong></p>
<ul>
<li><code>size</code>: Return container size (public member function)</li>
</ul>
<p><strong>Element access:</strong></p>
<ul>
<li><code>operator[]</code>: Access element (public member function)</li>
</ul>
<p><strong>Modifiers:</strong></p>
<ul>
<li><code>clear</code>: Clear content (public member function)</li>
</ul>
<p><strong>Operations:</strong></p>
<ul>
<li><code>count</code>: Count elements with a specific key (public member function)</li>
</ul>
<h4 id="std-map-size"><a href="#std-map-size" class="headerlink" title="std::map::size"></a><code>std::map::size</code></h4><p><code>std::map::size</code>: <a href="https://cplusplus.com/reference/map/map/size/">https://cplusplus.com/reference/map/map/size/</a> 。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">size_type size() const noexcept;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><strong><code>Return container size</code></strong></p>
<p>Returns <code>the number of elements</code> in the map container.</p>
<p><strong><code>Parameters</code></strong></p>
<p><strong>none</strong></p>
<p><strong><code>Return Value</code></strong></p>
<p><code>The number of elements</code> in the container.</p>
<p>Member type <code>size_type</code> is <code>an unsigned integral type</code>.</p>
<p><strong><code>Example</code></strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; map::size
#include &lt;iostream&gt;
#include &lt;map&gt;

int main ()
&#123;
  std::map&lt;char,int&gt; mymap;
  mymap[&#39;a&#39;]&#x3D;101;
  mymap[&#39;b&#39;]&#x3D;202;
  mymap[&#39;c&#39;]&#x3D;302;

  std::cout &lt;&lt; &quot;mymap.size() is &quot; &lt;&lt; mymap.size() &lt;&lt; &#39;\n&#39;;

  return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>输出</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mymap.size<span class="token punctuation">(</span><span class="token punctuation">)</span> is <span class="token number">3</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><strong><code>Complexity</code></strong></p>
<p>Constant.</p>
<p><strong><code>Iterator validity</code></strong></p>
<p>No changes.</p>
<p><strong><code>Data races</code></strong></p>
<ol>
<li><p>The container is <code>accessed</code>.</p>
</li>
<li><p>No elements are accessed: concurrently accessing or modifying them is safe.</p>
</li>
</ol>
<p><strong><code>Exception safety</code></strong></p>
<p><code>No-throw guarantee</code>: this member function <code>never throws exceptions</code>.</p>
<h4 id="std-map-operator"><a href="#std-map-operator" class="headerlink" title="std::map::operator[]"></a><code>std::map::operator[]</code></h4><p><code>std::map::operator[]</code>: <a href="https://cplusplus.com/reference/map/map/operator[]/">https://cplusplus.com/reference/map/map/operator[]/</a> 。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">mapped_type&amp; operator[] (const key_type&amp; k);mapped_type&amp; operator[] (key_type&amp;&amp; k);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><strong><code>Access element</code></strong></p>
<p>If <code>k</code> matches <code>the key of an element</code> in the container, the function returns <code>a reference to its mapped value</code>.</p>
<p><code>If k does not match the key of any element in the container, the function inserts a new element with that key and returns a reference to its mapped value.</code> Notice that this always <code>increases the container size by one</code>, even if <code>no mapped value is assigned to the element</code> (<code>the element is constructed using its default constructor</code>).</p>
<p>A similar member function, <code>map::at</code>, has <code>the same behavior when an element with the key exists</code>, but <code>throws an exception when it does not</code>.</p>
<p>A call to this function is equivalent to:</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">(*((this-&gt;insert(make_pair(k,mapped_type()))).first)).<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><strong><code>Parameters</code></strong></p>
<p><strong>k</strong></p>
<ol>
<li><p><code>Key value of the element</code> whose mapped value is accessed.</p>
</li>
<li><p>Member type <code>key_type</code> is the type of the keys for the elements stored in the container, defined in map as an alias of its first template parameter (<code>Key</code>).</p>
</li>
<li><p>If an <code>rvalue (second version)</code>, the key is <code>moved instead of copied</code> when a new element is inserted.</p>
</li>
</ol>
<p><strong><code>Return Value</code></strong></p>
<p>A <code>reference</code> to the mapped value of the element with a <code>key</code> value equivalent to <code>k</code>.</p>
<p>Member type <code>mapped_type</code> is the type of the mapped values in the container, defined in <code>map</code> as an alias of its <code>second template parameter</code> (<code>T</code>).</p>
<p><strong><code>Example</code></strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; accessing mapped values
#include &lt;iostream&gt;
#include &lt;map&gt;
#include &lt;string&gt;

int main ()
&#123;
  std::map&lt;char,std::string&gt; mymap;

  mymap[&#39;a&#39;]&#x3D;&quot;an element&quot;;
  mymap[&#39;b&#39;]&#x3D;&quot;another element&quot;;
  mymap[&#39;c&#39;]&#x3D;mymap[&#39;b&#39;];

  std::cout &lt;&lt; &quot;mymap[&#39;a&#39;] is &quot; &lt;&lt; mymap[&#39;a&#39;] &lt;&lt; &#39;\n&#39;;
  std::cout &lt;&lt; &quot;mymap[&#39;b&#39;] is &quot; &lt;&lt; mymap[&#39;b&#39;] &lt;&lt; &#39;\n&#39;;
  std::cout &lt;&lt; &quot;mymap[&#39;c&#39;] is &quot; &lt;&lt; mymap[&#39;c&#39;] &lt;&lt; &#39;\n&#39;;
  std::cout &lt;&lt; &quot;mymap[&#39;d&#39;] is &quot; &lt;&lt; mymap[&#39;d&#39;] &lt;&lt; &#39;\n&#39;;

  std::cout &lt;&lt; &quot;mymap now contains &quot; &lt;&lt; mymap.size() &lt;&lt; &quot; elements.\n&quot;;

  return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>Notice how <code>the last access</code> (to element <code>&#39;d&#39;</code>) inserts a new element in the <code>map</code> with that key and <code>initialized to its default value</code> (an empty string) even though it is accessed only to retrieve its value. <code>Member function map::find does not produce this effect</code>.</p>
<p>输出</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mymap<span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">]</span> is an element
mymap<span class="token punctuation">[</span><span class="token string">'b'</span><span class="token punctuation">]</span> is another element
mymap<span class="token punctuation">[</span><span class="token string">'c'</span><span class="token punctuation">]</span> is another element
mymap<span class="token punctuation">[</span><span class="token string">'d'</span><span class="token punctuation">]</span> is
mymap now contains <span class="token number">4</span> elements.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong><code>Complexity</code></strong></p>
<p><code>Logarithmic</code> in size.</p>
<p><strong><code>Iterator validity</code></strong></p>
<p>No changes.</p>
<p><strong><code>Data races</code></strong></p>
<ol>
<li><p>The container is <code>accessed</code>, and <code>potentially modified</code>.</p>
</li>
<li><p>The function accesses an element and returns a reference that can be used to modify its mapped value. Concurrently accessing other elements is safe.</p>
</li>
<li><p>If the function inserts <code>a new element</code>, concurrently iterating ranges in the container is not safe.</p>
</li>
</ol>
<p><strong><code>Exception safety</code></strong></p>
<ol>
<li><p>Strong guarantee: <code>if an exception is thrown, there are no changes in the container</code>.</p>
</li>
<li><p>If a new element is inserted and <code>allocator_traits::construct</code> cannot construct an element with <code>k</code> and a default-constructed <code>mapped_type</code> (or if <code>mapped_type</code> is not <code>default constructible</code>), it causes <code>undefined behavior</code>.</p>
</li>
</ol>
<h4 id="std-map-clear"><a href="#std-map-clear" class="headerlink" title="std::map::clear"></a><code>std::map::clear</code></h4><p><code>std::map::clear</code>: <a href="https://cplusplus.com/reference/map/map/clear/">https://cplusplus.com/reference/map/map/clear/</a> 。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void clear() noexcept;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><strong><code>Clear content</code></strong></p>
<p><code>Removes</code> all elements from <code>the map container</code> (which are destroyed), <code>leaving the container with a size of 0</code>.</p>
<p><strong><code>Parameters</code></strong></p>
<p><strong>none</strong></p>
<p><strong><code>Return Value</code></strong></p>
<p><strong>none</strong></p>
<p><strong><code>Example</code></strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; map::clear
#include &lt;iostream&gt;
#include &lt;map&gt;

int main ()
&#123;
  std::map&lt;char,int&gt; mymap;

  mymap[&#39;x&#39;]&#x3D;100;
  mymap[&#39;y&#39;]&#x3D;200;
  mymap[&#39;z&#39;]&#x3D;300;

  std::cout &lt;&lt; &quot;mymap contains:\n&quot;;
  for (std::map&lt;char,int&gt;::iterator it&#x3D;mymap.begin(); it!&#x3D;mymap.end(); ++it)
    std::cout &lt;&lt; it-&gt;first &lt;&lt; &quot; &#x3D;&gt; &quot; &lt;&lt; it-&gt;second &lt;&lt; &#39;\n&#39;;

  mymap.clear();
  mymap[&#39;a&#39;]&#x3D;1101;
  mymap[&#39;b&#39;]&#x3D;2202;

  std::cout &lt;&lt; &quot;mymap contains:\n&quot;;
  for (std::map&lt;char,int&gt;::iterator it&#x3D;mymap.begin(); it!&#x3D;mymap.end(); ++it)
    std::cout &lt;&lt; it-&gt;first &lt;&lt; &quot; &#x3D;&gt; &quot; &lt;&lt; it-&gt;second &lt;&lt; &#39;\n&#39;;

  return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>输出</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mymap contains:
x <span class="token operator">=</span><span class="token operator">></span> <span class="token number">100</span>
y <span class="token operator">=</span><span class="token operator">></span> <span class="token number">200</span>
z <span class="token operator">=</span><span class="token operator">></span> <span class="token number">300</span>
mymap contains:
a <span class="token operator">=</span><span class="token operator">></span> <span class="token number">1101</span>
b <span class="token operator">=</span><span class="token operator">></span> <span class="token number">2202</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong><code>Complexity</code></strong></p>
<p><code>Linear</code> in size (destructions).</p>
<p><strong><code>Iterator validity</code></strong></p>
<p><code>All iterators, pointers and references</code> related to this container are <code>invalidated</code>.</p>
<p><strong><code>Data races</code></strong></p>
<ol>
<li><p>The container is modified.</p>
</li>
<li><p><code>All contained elements are modified</code>.</p>
</li>
</ol>
<p><strong><code>Exception safety</code></strong></p>
<p><code>No-throw guarantee</code>: this member function <code>never throws</code> exceptions.</p>
<h4 id="std-map-count"><a href="#std-map-count" class="headerlink" title="std::map::count"></a><code>std::map::count</code></h4><p><code>std::map::count</code>: <a href="https://cplusplus.com/reference/map/map/count/">https://cplusplus.com/reference/map/map/count/</a> 。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">size_type count (const key_type&amp; k) const;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><strong><code>Count elements with a specific key</code></strong></p>
<p>Searches the container for elements with <code>a key equivalent to k</code> and <code>returns the number of matches</code>.</p>
<p>Because all elements in a map container are <code>unique</code>, <code>the function can only return 1</code> (if the element is found) or <code>zero</code> (otherwise).</p>
<p>Two keys are considered equivalent if the container’s <code>comparison object</code> returns false reflexively (i.e., no matter the order in which the keys are passed as arguments).</p>
<p><strong><code>Parameters</code></strong></p>
<p><strong>k</strong></p>
<ol>
<li><p><code>Key</code> to search for.</p>
</li>
<li><p>Member type <code>key_type</code> is the type of the element keys in the container, defined in <code>map</code> as an alias of <code>its first template parameter</code> (Key).</p>
</li>
</ol>
<p><strong><code>Return Value</code></strong></p>
<p><code>1</code> if the container contains an element whose key is equivalent to <code>k</code>, or <code>zero</code> otherwise.</p>
<p>Member type <code>size_type</code> is <code>an unsigned integral type</code>.</p>
<p><strong><code>Example</code></strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; map::count
#include &lt;iostream&gt;
#include &lt;map&gt;

int main ()
&#123;
  std::map&lt;char,int&gt; mymap;
  char c;

  mymap [&#39;a&#39;]&#x3D;101;
  mymap [&#39;c&#39;]&#x3D;202;
  mymap [&#39;f&#39;]&#x3D;303;

  for (c&#x3D;&#39;a&#39;; c&lt;&#39;h&#39;; c++)
  &#123;
    std::cout &lt;&lt; c;
    if (mymap.count(c)&gt;0)
      std::cout &lt;&lt; &quot; is an element of mymap.\n&quot;;
    else 
      std::cout &lt;&lt; &quot; is not an element of mymap.\n&quot;;
  &#125;

  return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>输出</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">a is an element of mymap.
b is not an element of mymap.
c is an element of mymap.
d is not an element of mymap.
e is not an element of mymap.
f is an element of mymap.
g is not an element of mymap.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong><code>Complexity</code></strong></p>
<p><code>Logarithmic</code> in size.</p>
<p><strong><code>Iterator validity</code></strong></p>
<p>No changes.</p>
<p><strong><code>Data races</code></strong></p>
<ol>
<li><p>The container is accessed.</p>
</li>
<li><p>No mapped values are accessed: concurrently accessing or modifying elements is <code>safe</code>.</p>
</li>
</ol>
<p><strong><code>Exception safety</code></strong></p>
<p><code>Strong guarantee</code>: if an exception is thrown, there are <code>no changes</code> in the container.</p>
<h2 id="-2"><a href="#-2" class="headerlink" title="&lt;vector&gt;"></a><code>&lt;vector&gt;</code></h2><p><code>&lt;vector&gt;</code>: <a href="https://cplusplus.com/reference/vector/">https://cplusplus.com/reference/vector/</a> 。</p>
<p><code>&lt;vector&gt;</code>: Vector header (header).</p>
<h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><ul>
<li><code>operator=</code>: Assign content (public member function)</li>
</ul>
<p><strong>Capacity:</strong></p>
<ul>
<li><p><code>size</code>: Return size (public member function)</p>
</li>
<li><p><code>resize</code>: Change size (public member function)</p>
</li>
</ul>
<p><strong>Element access:</strong></p>
<ul>
<li><code>operator[]</code>: Access element (public member function)</li>
</ul>
<p><strong>Modifiers:</strong></p>
<ul>
<li><p><code>push_back</code>: Add element at the end (public member function)</p>
</li>
<li><p><code>clear</code>: Clear content (public member function)</p>
</li>
</ul>
<h4 id="std-vector-operator"><a href="#std-vector-operator" class="headerlink" title="std::vector::operator="></a><code>std::vector::operator=</code></h4><p><code>std::vector::operator=</code>: <a href="https://cplusplus.com/reference/vector/vector/operator=/">https://cplusplus.com/reference/vector/vector/operator=/</a> 。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">copy (1)	
vector&amp; operator&#x3D; (const vector&amp; x);
move (2)	
vector&amp; operator&#x3D; (vector&amp;&amp; x);
initializer list (3)	
vector&amp; operator&#x3D; (initializer_list&lt;value_type&gt; il);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong><code>Assign content</code></strong></p>
<p><code>Assigns</code> new contents to the container, replacing its current contents, and modifying its <code>size</code> accordingly.</p>
<p>C++11</p>
<p>The <code>copy assignment (1)</code> copies all the elements from <code>x</code> into the container (with <code>x</code> preserving its contents).</p>
<p>The <code>move assignment (2)</code> moves the elements of <code>x</code> into the container (<code>x</code> is left in an unspecified but valid state).</p>
<p>The <code>initializer list assignment (3)</code> copies the elements of <code>il</code> into the container.</p>
<p>The container preserves its <code>current allocator</code>, except if the <code>allocator traits</code> indicate that x’s allocator should <code>propagate</code>. This <code>allocator</code> is used (through its <code>traits</code>) to <code>allocate</code> and <code>deallocate</code> storage if a reallocation happens, and to <code>construct</code> or <code>destroy</code> elements, if needed.</p>
<p>Any elements held in the container before the call are either <code>assigned</code> to or <code>destroyed</code>.</p>
<p><strong><code>Parameters</code></strong></p>
<p><strong>x</strong></p>
<ol>
<li>A <code>vector</code> object of the same type (i.e., with the same template parameters, <code>T</code> and <code>Alloc</code>).</li>
</ol>
<p><strong>il</strong></p>
<ol>
<li><p>An <code>initializer_list</code> object. The compiler will automatically construct such objects from <code>initializer list</code> declarators.</p>
</li>
<li><p>Member type <code>value_type</code> is the type of the elements in the container, defined in <code>vector</code> as an alias of its first template parameter (<code>T</code>).</p>
</li>
</ol>
<p><strong><code>Return Value</code></strong></p>
<p>*this</p>
<p><strong><code>Example</code></strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; vector assignment
#include &lt;iostream&gt;
#include &lt;vector&gt;

int main ()
&#123;
  std::vector&lt;int&gt; foo (3,0);
  std::vector&lt;int&gt; bar (5,0);

  bar &#x3D; foo;
  foo &#x3D; std::vector&lt;int&gt;();

  std::cout &lt;&lt; &quot;Size of foo: &quot; &lt;&lt; int(foo.size()) &lt;&lt; &#39;\n&#39;;
  std::cout &lt;&lt; &quot;Size of bar: &quot; &lt;&lt; int(bar.size()) &lt;&lt; &#39;\n&#39;;
  return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>输出</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Size of foo: <span class="token number">0</span>
Size of bar: <span class="token number">3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p><strong><code>Complexity</code></strong></p>
<p><code>Linear</code> in size.</p>
<p><strong><code>Iterator validity</code></strong></p>
<p>All <code>iterators</code>, <code>references</code> and <code>pointers</code> related to this container before the call are invalidated.</p>
<p>In the <code>move assignment</code>, iterators, pointers and references referring to elements in <code>x</code> are also invalidated.</p>
<p><strong><code>Data races</code></strong></p>
<ol>
<li><p><code>All copied elements</code> are accessed.</p>
</li>
<li><p>The <code>move assignment (2)</code> modifies x.</p>
</li>
<li><p>The container and all its elements are modified.</p>
</li>
</ol>
<p><strong><code>Exception safety</code></strong></p>
<ol>
<li><p><code>Basic guarantee</code>: if an exception is thrown, the container is in a valid state.</p>
</li>
<li><p>If <code>allocator_traits::construct</code> is not supported with the appropriate arguments for the element constructions, or if <code>value_type</code> is <code>not copy assignable</code> (or <code>move assignable</code> for (2)), it causes <code>undefined behavior</code>.</p>
</li>
</ol>
<h4 id="std-vector-size"><a href="#std-vector-size" class="headerlink" title="std::vector::size"></a><code>std::vector::size</code></h4><p><code>std::vector::size</code>: <a href="https://cplusplus.com/reference/vector/vector/size/">https://cplusplus.com/reference/vector/vector/size/</a> 。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">size_type size() const noexcept;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><strong><code>Return size</code></strong></p>
<p>Returns <code>the number of elements</code> in the <code>vector</code>.</p>
<p>This is <code>the number of actual objects</code> held in the <code>vector</code>, which is not necessarily equal to its storage <code>capacity</code>.</p>
<p><strong><code>Parameters</code></strong></p>
<p>none</p>
<p><strong><code>Return Value</code></strong></p>
<ol>
<li><p><code>The number of elements</code> in the container.</p>
</li>
<li><p>Member type <code>size_type</code> is <code>an unsigned integral type</code>.</p>
</li>
</ol>
<p><strong><code>Example</code></strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; vector::size
#include &lt;iostream&gt;
#include &lt;vector&gt;

int main ()
&#123;
  std::vector&lt;int&gt; myints;
  std::cout &lt;&lt; &quot;0. size: &quot; &lt;&lt; myints.size() &lt;&lt; &#39;\n&#39;;

  for (int i&#x3D;0; i&lt;10; i++) myints.push_back(i);
  std::cout &lt;&lt; &quot;1. size: &quot; &lt;&lt; myints.size() &lt;&lt; &#39;\n&#39;;

  myints.insert (myints.end(),10,100);
  std::cout &lt;&lt; &quot;2. size: &quot; &lt;&lt; myints.size() &lt;&lt; &#39;\n&#39;;

  myints.pop_back();
  std::cout &lt;&lt; &quot;3. size: &quot; &lt;&lt; myints.size() &lt;&lt; &#39;\n&#39;;

  return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>输出</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">0</span>. size: <span class="token number">0</span>
<span class="token number">1</span>. size: <span class="token number">10</span>
<span class="token number">2</span>. size: <span class="token number">20</span>
<span class="token number">3</span>. size: <span class="token number">19</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong><code>Complexity</code></strong></p>
<p>Constant.</p>
<p><strong><code>Iterator validity</code></strong></p>
<p>No changes.</p>
<p><strong><code>Data races</code></strong></p>
<ol>
<li><p>The container is <code>accessed</code>.</p>
</li>
<li><p>No contained elements are accessed: concurrently accessing or modifying them is <code>safe</code>.</p>
</li>
</ol>
<p><strong><code>Exception safety</code></strong></p>
<p><code>No-throw guarantee</code>: this member function <code>never</code> throws exceptions.</p>
<h4 id="std-vector-resize"><a href="#std-vector-resize" class="headerlink" title="std::vector::resize"></a><code>std::vector::resize</code></h4><p><code>std::vector::resize</code>: <a href="https://cplusplus.com/reference/vector/vector/resize/">https://cplusplus.com/reference/vector/vector/resize/</a> 。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void resize (size_type n);void resize (size_type n, const value_type&amp; val);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><strong><code>Change size</code></strong></p>
<p><code>Resizes</code> the container so that it contains <code>n</code> elements.</p>
<p>If <code>n</code> is smaller than the current container size, the content is <code>reduced to its first n element</code>s, removing those beyond (and destroying them).</p>
<p>If <code>n</code> is greater than the current container size, the content is expanded by inserting at the end as many elements as needed to reach a size of n. <code>If val is specified, the new elements are initialized as copies of val</code>, <code>otherwise, they are value-initialized</code>.</p>
<p>If <code>n</code> is also greater than the current container <code>capacity</code>, an <code>automatic reallocation</code> of the allocated storage space takes place.</p>
<p>Notice that this function changes the actual content of the container by inserting or erasing elements from it.</p>
<p><strong><code>Parameters</code></strong></p>
<p><strong>n</strong></p>
<ol>
<li><p>New container size, expressed in number of elements.</p>
</li>
<li><p>Member type <code>size_type</code> is an unsigned integral type.</p>
</li>
</ol>
<p><strong>val</strong></p>
<ol>
<li><p><code>Object</code> whose content is copied to the added elements in case that <code>n</code> is greater than <code>the current container size</code>.</p>
</li>
<li><p>If <code>not specified</code>, <code>the default constructor</code> is used instead.</p>
</li>
<li><p>Member type <code>value_type</code> is the type of the elements in the container, defined in <code>vector</code> as an alias of the first template parameter (<code>T</code>).</p>
</li>
</ol>
<p><strong><code>Return Value</code></strong></p>
<p>none</p>
<p>If a <code>reallocation</code> happens, the storage is allocated using the container’s <code>allocator</code>, which may throw exceptions on failure (for the default <code>allocator</code>, <code>bad_alloc</code> is thrown if the allocation request does not succeed).</p>
<p><strong><code>Example</code></strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; resizing vector
#include &lt;iostream&gt;
#include &lt;vector&gt;

int main ()
&#123;
  std::vector&lt;int&gt; myvector;

  &#x2F;&#x2F; set some initial content:
  for (int i&#x3D;1;i&lt;10;i++) myvector.push_back(i);

  myvector.resize(5);
  myvector.resize(8,100);
  myvector.resize(12);

  std::cout &lt;&lt; &quot;myvector contains:&quot;;
  for (int i&#x3D;0;i&lt;myvector.size();i++)
    std::cout &lt;&lt; &#39; &#39; &lt;&lt; myvector[i];
  std::cout &lt;&lt; &#39;\n&#39;;

  return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>输出</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">myvector contains: <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span> <span class="token number">5</span> <span class="token number">100</span> <span class="token number">100</span> <span class="token number">100</span> <span class="token number">0</span> <span class="token number">0</span> <span class="token number">0</span> <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><strong><code>Complexity</code></strong></p>
<ol>
<li><p><code>Linear</code> on the number of elements inserted&#x2F;erased (<code>constructions/destructions</code>).</p>
</li>
<li><p>If a <code>reallocation</code> happens, the reallocation is itself up to linear in <code>the entire vector size</code>.</p>
</li>
</ol>
<p><strong><code>Iterator validity</code></strong></p>
<ol>
<li><p>In case the container <code>shrinks</code>, <code>all iterators</code>, <code>pointers</code> and <code>references</code> to elements that have not been removed remain valid after the resize and <code>refer to the same elements</code> they were referring to before the call.</p>
</li>
<li><p>If the container <code>expands</code>, <code>the end iterator</code> is <code>invalidated</code> and, if it has to <code>reallocate storage</code>, all <code>iterators</code>, <code>pointers</code> and <code>references</code> related to this container are also <code>invalidated</code>.</p>
</li>
</ol>
<p><strong><code>Data races</code></strong></p>
<ol>
<li><p>The container is <code>modified</code>.</p>
</li>
<li><p>If a reallocation happens, all contained elements are modified.</p>
</li>
<li><p>Otherwise, none of the elements before <code>n</code> is accessed, and concurrently accessing or modifying them is <code>safe</code>.</p>
</li>
</ol>
<p><strong><code>Exception safety</code></strong></p>
<ol>
<li><p>If <code>n</code> is less than or equal to the size of the container, the function <code>never</code> throws exceptions (<code>no-throw guarantee</code>).</p>
</li>
<li><p>If <code>n</code> is greater and a reallocation happens, there are <code>no changes</code> in the container <code>in case of exception</code> (<code>strong guarantee</code>) if the type of the elements is either copyable or no-throw moveable.</p>
</li>
<li><p>Otherwise, if an exception is thrown, the container is left with a valid state (basic guarantee).</p>
</li>
</ol>
<h4 id="std-vector-operator-1"><a href="#std-vector-operator-1" class="headerlink" title="std::vector::operator[]"></a><code>std::vector::operator[]</code></h4><p><code>std::vector::operator[]</code>: <a href="https://cplusplus.com/reference/vector/vector/operator[]/">https://cplusplus.com/reference/vector/vector/operator[]/</a> 。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">reference operator[] (size_type n);const_reference operator[] (size_type n) const;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><strong><code>Access element</code></strong></p>
<p>Returns a reference to the element at position <code>n</code> in the <code>vector</code> container.</p>
<p>A similar member function, <code>vector::at</code>, has the same behavior as this operator function, except that <code>vector::at</code> is <code>bound-checked</code> and signals <code>if the requested position is out of range by throwing an out_of_range exception</code>.</p>
<p>Portable programs should never call this function with an argument <code>n</code> that is out of range, since this causes <code>undefined behavior</code>.</p>
<p><strong><code>Parameters</code></strong></p>
<p><strong>n</strong></p>
<ol>
<li><p><code>Position of an element</code> in the container.</p>
</li>
<li><p>Notice that <code>the first element</code> has a position of <code>0</code> (not <code>1</code>).</p>
</li>
<li><p>Member type <code>size_type</code> is an <code>unsigned integral type</code>.</p>
</li>
</ol>
<p><strong><code>Return Value</code></strong></p>
<ol>
<li><p><code>The element at the specified position</code> in the <code>vector</code>.</p>
</li>
<li><p>If the <code>vector</code> object is <code>const-qualified</code>, the function returns a <code>const_reference</code>. Otherwise, it returns a <code>reference</code>.</p>
</li>
<li><p>Member types <code>reference</code> and <code>const_reference</code> are the reference types to the elements of the container (see <code>vector member types</code>).</p>
</li>
</ol>
<p><strong><code>Example</code></strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; vector::operator[]
#include &lt;iostream&gt;
#include &lt;vector&gt;

int main ()
&#123;
  std::vector&lt;int&gt; myvector (10);   &#x2F;&#x2F; 10 zero-initialized elements

  std::vector&lt;int&gt;::size_type sz &#x3D; myvector.size();

  &#x2F;&#x2F; assign some values:
  for (unsigned i&#x3D;0; i&lt;sz; i++) myvector[i]&#x3D;i;

  &#x2F;&#x2F; reverse vector using operator[]:
  for (unsigned i&#x3D;0; i&lt;sz&#x2F;2; i++)
  &#123;
    int temp;
    temp &#x3D; myvector[sz-1-i];
    myvector[sz-1-i]&#x3D;myvector[i];
    myvector[i]&#x3D;temp;
  &#125;

  std::cout &lt;&lt; &quot;myvector contains:&quot;;
  for (unsigned i&#x3D;0; i&lt;sz; i++)
    std::cout &lt;&lt; &#39; &#39; &lt;&lt; myvector[i];
  std::cout &lt;&lt; &#39;\n&#39;;

  return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>输出</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">myvector contains: <span class="token number">9</span> <span class="token number">8</span> <span class="token number">7</span> <span class="token number">6</span> <span class="token number">5</span> <span class="token number">4</span> <span class="token number">3</span> <span class="token number">2</span> <span class="token number">1</span> <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><strong><code>Complexity</code></strong></p>
<p><code>Constant</code>.</p>
<p><strong><code>Iterator validity</code></strong></p>
<p>No changes.</p>
<p><strong><code>Data races</code></strong></p>
<ol>
<li><p>The <code>container</code> is <code>accessed</code> (neither the <code>const</code> nor the <code>non-const</code> versions modify the container).</p>
</li>
<li><p>The reference returned can be used to <code>access</code> or <code>modify elements</code>. Concurrently accessing or modifying different elements is <code>safe</code>.</p>
</li>
</ol>
<p><strong><code>Exception safety</code></strong></p>
<ol>
<li><p>If the container size is greater than <code>n</code>, the function <code>never throws exceptions</code> (no-throw guarantee).</p>
</li>
<li><p>Otherwise, the behavior is undefined.</p>
</li>
</ol>
<h4 id="std-vector-push-back"><a href="#std-vector-push-back" class="headerlink" title="std::vector::push_back"></a><code>std::vector::push_back</code></h4><p><code>std::vector::push_back</code>: <a href="https://cplusplus.com/reference/vector/vector/push_back/">https://cplusplus.com/reference/vector/vector/push_back/</a> 。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void push_back (const value_type&amp; val);
void push_back (value_type&amp;&amp; val);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p><strong><code>Add element at the end</code></strong></p>
<p><code>Adds a new element at the end of the vector</code>, after its current <code>last</code> element. The content of val is <code>copied</code> (or <code>moved</code>) to the new element.</p>
<p>This effectively increases the container <code>size</code> by one, <code>which causes an automatic reallocation of the allocated storage space if -and only if- the new vector size surpasses the current vector capacity</code>.</p>
<p><strong><code>Parameters</code></strong></p>
<p><strong>val</strong></p>
<ol>
<li><p><code>Value</code> to be <code>copied</code> (or <code>moved</code>) to the new element.</p>
</li>
<li><p>Member type <code>value_type</code> is the type of the elements in the container, defined in vector as an alias of <code>its first template parameter (T)</code>.</p>
</li>
</ol>
<p><strong><code>Return Value</code></strong></p>
<p>none</p>
<p>If a <code>reallocation</code> happens, the storage is <code>allocated</code> <code>using the container&#39;s allocator</code>, which may throw exceptions on failure (for the default allocator, <code>bad_alloc</code> is thrown if the allocation request does not succeed).</p>
<p><strong><code>Example</code></strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; vector::push_back
#include &lt;iostream&gt;
#include &lt;vector&gt;

int main ()
&#123;
  std::vector&lt;int&gt; myvector;
  int myint;

  std::cout &lt;&lt; &quot;Please enter some integers (enter 0 to end):\n&quot;;

  do &#123;
    std::cin &gt;&gt; myint;
    myvector.push_back (myint);
  &#125; while (myint);

  std::cout &lt;&lt; &quot;myvector stores &quot; &lt;&lt; int(myvector.size()) &lt;&lt; &quot; numbers.\n&quot;;

  return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>The example uses <code>push_back</code> to add a new element to the vector each time a new integer is read.</p>
<p><strong><code>Complexity</code></strong></p>
<p><code>Constant</code> (amortized time, <code>reallocation</code> may happen).</p>
<p>If a <code>reallocation</code> happens, the reallocation is itself up to linear <code>in the entire size</code>.</p>
<p><strong><code>Iterator validity</code></strong></p>
<ol>
<li><p>If a <code>reallocation</code> happens, all iterators, pointers and references related to the container are <code>invalidated</code>.</p>
</li>
<li><p><code>Otherwise</code>, only <code>the end iterator</code> is <code>invalidated</code>, and all iterators, pointers and references to elements are guaranteed to keep referring to the same elements they were referring to before the call.</p>
</li>
</ol>
<p><strong><code>Data races</code></strong></p>
<ol>
<li><p>The container is <code>modified</code>.</p>
</li>
<li><p>If a <code>reallocation</code> happens, all contained elements are modified.</p>
</li>
<li><p>Otherwise, no existing element is accessed, and concurrently accessing or modifying them is safe.</p>
</li>
</ol>
<p><strong><code>Exception safety</code></strong></p>
<ol>
<li><p>If <code>no reallocations</code> happen, there are <code>no changes</code> in the container in case of exception (strong guarantee).</p>
</li>
<li><p>If a <code>reallocation</code> happens, the strong guarantee is also given if the type of the elements is either <code>copyable</code> or <code>no-throw moveable</code>.</p>
</li>
<li><p>Otherwise, the <code>container</code> is guaranteed to <code>end in a valid state</code> (basic guarantee).</p>
</li>
<li><p>If <code>allocator_traits::construct</code> is not supported with <code>val</code> as argument, it causes <code>undefined behavior</code>.</p>
</li>
</ol>
<h4 id="std-vector-clear"><a href="#std-vector-clear" class="headerlink" title="std::vector::clear"></a><code>std::vector::clear</code></h4><p><code>std::vector::clear</code>: <a href="https://cplusplus.com/reference/vector/vector/clear/">https://cplusplus.com/reference/vector/vector/clear/</a> 。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void clear() noexcept;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><strong><code>Clear content</code></strong></p>
<p><code>Removes all elements from the vector</code> (which are destroyed), leaving the container with <code>a size of 0</code>.</p>
<p><code>A reallocation is not guaranteed to happen</code>, and the <code>vector capacity</code> is not guaranteed to change due to calling this function. A typical alternative that <code>forces a reallocation</code> is to use swap:</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">vector&lt;T&gt;().swap(x);   &#x2F;&#x2F; clear x reallocating<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><strong><code>Parameters</code></strong></p>
<p>none</p>
<p><strong><code>Return Value</code></strong></p>
<p>none</p>
<p><strong><code>Example</code></strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; clearing vectors
#include &lt;iostream&gt;
#include &lt;vector&gt;

int main ()
&#123;
  std::vector&lt;int&gt; myvector;
  myvector.push_back (100);
  myvector.push_back (200);
  myvector.push_back (300);

  std::cout &lt;&lt; &quot;myvector contains:&quot;;
  for (unsigned i&#x3D;0; i&lt;myvector.size(); i++)
    std::cout &lt;&lt; &#39; &#39; &lt;&lt; myvector[i];
  std::cout &lt;&lt; &#39;\n&#39;;

  myvector.clear();
  myvector.push_back (1101);
  myvector.push_back (2202);

  std::cout &lt;&lt; &quot;myvector contains:&quot;;
  for (unsigned i&#x3D;0; i&lt;myvector.size(); i++)
    std::cout &lt;&lt; &#39; &#39; &lt;&lt; myvector[i];
  std::cout &lt;&lt; &#39;\n&#39;;

  return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>输出</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">myvector contains: <span class="token number">100</span> <span class="token number">200</span> <span class="token number">300</span>
myvector contains: <span class="token number">1101</span> <span class="token number">2202</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p><strong><code>Complexity</code></strong></p>
<ol>
<li><p><code>Linear</code> in size (destructions).</p>
</li>
<li><p>This may be optimized to constant complexity for <code>trivially-destructible types</code> (such as scalar or PODs), where elements need not be destroyed.</p>
</li>
</ol>
<p><strong><code>Iterator validity</code></strong></p>
<p><code>All iterators</code>, <code>pointers</code> and <code>references</code> related to this container are <code>invalidated</code>.</p>
<p><strong><code>Data races</code></strong></p>
<ol>
<li><p>The container is modified.</p>
</li>
<li><p>All contained elements are modified.</p>
</li>
</ol>
<p><strong><code>Exception safety</code></strong></p>
<p><code>No-throw guarantee</code>: this member function <code>never</code> throws exceptions.</p>
<div id = "3"></div>

<h1 id="Input-Output-Stream-Library"><a href="#Input-Output-Stream-Library" class="headerlink" title="Input/Output Stream Library"></a><code>Input/Output Stream Library</code></h1><h2 id="-3"><a href="#-3" class="headerlink" title="&lt;iostream&gt;"></a><code>&lt;iostream&gt;</code></h2><p><code>&lt;iostream&gt;</code>: <a href="https://cplusplus.com/reference/iostream/">https://cplusplus.com/reference/iostream/</a> 。</p>
<p><code>&lt;iostream&gt;</code>: Standard Input &#x2F; Output Streams Library.</p>
<h3 id="Narrow-characters-char"><a href="#Narrow-characters-char" class="headerlink" title="Narrow characters (char)"></a>Narrow characters (char)</h3><ul>
<li><p><code>cout</code>: Standard output stream (object)</p>
</li>
<li><p><code>cerr</code>: Standard output stream for errors (object)</p>
</li>
</ul>
<h4 id="std-cout"><a href="#std-cout" class="headerlink" title="std::cout"></a><code>std::cout</code></h4><p><code>std::cout</code>: <a href="https://cplusplus.com/reference/iostream/cout/">https://cplusplus.com/reference/iostream/cout/</a> 。</p>
<p><code>extern ostream cout;</code></p>
<p><strong><code>Standard output stream</code></strong></p>
<p>Object of class <code>ostream</code> that represents <code>the standard output stream</code> oriented to <code>narrow characters</code> (of <code>type char</code>). It corresponds to <code>the C stream stdout</code>.</p>
<p>The <code>standard output stream</code> is <code>the default destination</code> of characters determined by the environment. <code>This destination may be shared with more standard objects</code> (such as <code>cerr</code> or <code>clog</code>).</p>
<p>As an object of class <code>ostream</code>, characters can be written to it either as formatted data using the insertion operator (<code>operator&lt;&lt;</code>) or as unformatted data, using member functions such as <code>write</code>.</p>
<p>The object is declared in header <strong><code>&lt;iostream&gt;</code></strong> with <code>external linkage</code> and <code>static duration</code>: <code>it lasts the entire duration of the program</code>.</p>
<hr>
<p><code>cout</code> is not tied to any other output stream.</p>
<p>By default, <code>cout</code> is synchronized with <code>stdout</code>.</p>
<p>A program should not mix output operations on <code>cout</code> with output operations on <code>wcout</code> (or with other wide-oriented output operations on <code>stdout</code>): <code>Once an output operation has been performed on either, the standard output stream acquires an orientation (either narrow or wide) that can only be safely changed by calling freopen on stdout</code>.</p>
<h4 id="std-cerr"><a href="#std-cerr" class="headerlink" title="std::cerr"></a><code>std::cerr</code></h4><p><code>std::cerr</code>: <a href="https://cplusplus.com/reference/iostream/cerr/">https://cplusplus.com/reference/iostream/cerr/</a> 。</p>
<p><code>extern ostream cerr;</code></p>
<p><strong><code>Standard output stream for errors</code></strong></p>
<p>Object of class <code>ostream</code> that represents <code>the standard error stream</code> oriented to <code>narrow characters</code> (of type <code>char</code>). It corresponds to the C stream stderr.</p>
<p><code>The standard error stream</code> is a destination of characters determined by the environment. This destination may be shared by <code>more than one standard object</code> (such as <code>cout</code> or <code>clog</code>).</p>
<p>As an object of class <code>ostream</code>, characters can be written to it either as formatted data using the insertion operator (<code>operator&lt;&lt;</code>) or as unformatted data, using member functions such as <code>write</code>.</p>
<p>The object is declared in header <code>&lt;iostream&gt;</code> with <code>external linkage</code> and <code>static duration</code>: it lasts the entire duration of the program.</p>
<hr>
<p><code>cerr</code> is not <code>tied</code> to any other output stream.</p>
<p>By default, <code>cerr</code> is <code>synchronized</code> with <code>stderr</code>.</p>
<p>A program should not <code>mix</code> output operations on <code>cerr</code> with output operations on <code>wcerr</code> or <code>wclog</code> (or with other wide-oriented output operations on <code>stderr</code>): <code>Once an output operation has been performed on either, the standard error stream acquires an orientation (either narrow or wide) that can only be safely changed by calling freopen on stderr</code>.</p>
<div id = "4"></div>

<h1 id="Atomics-and-threading-library"><a href="#Atomics-and-threading-library" class="headerlink" title="Atomics and threading library"></a><code>Atomics and threading library</code></h1><div id = "5"></div>

<h1 id="Miscellaneous-headers"><a href="#Miscellaneous-headers" class="headerlink" title="Miscellaneous headers"></a><code>Miscellaneous headers</code></h1><h2 id="-4"><a href="#-4" class="headerlink" title="&lt;algorithm&gt;"></a><code>&lt;algorithm&gt;</code></h2><p><code>&lt;algorithm&gt;</code>: <a href="https://cplusplus.com/reference/algorithm/">https://cplusplus.com/reference/algorithm/</a> 。</p>
<p><code>&lt;algorithm&gt;</code>: Standard Template Library: Algorithms.</p>
<h3 id="Modifying-sequence-operations"><a href="#Modifying-sequence-operations" class="headerlink" title="Modifying sequence operations"></a>Modifying sequence operations</h3><ul>
<li><code>transform</code>: Transform range (function template)</li>
</ul>
<h4 id="std-transform"><a href="#std-transform" class="headerlink" title="std::transform"></a><code>std::transform</code></h4><p><code>std::transform</code>: <a href="https://cplusplus.com/reference/algorithm/transform/">https://cplusplus.com/reference/algorithm/transform/</a> 。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">unary operation(1)	
template &lt;class InputIterator, class OutputIterator, class UnaryOperation&gt;  OutputIterator transform (InputIterator first1, InputIterator last1,                            OutputIterator result, UnaryOperation op);
binary operation(2)	
template &lt;class InputIterator1, class InputIterator2,          class OutputIterator, class BinaryOperation&gt;  OutputIterator transform (InputIterator1 first1, InputIterator1 last1,                            InputIterator2 first2, OutputIterator result,                            BinaryOperation binary_op);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong><code>Transform range</code></strong></p>
<p>Applies an operation sequentially to the elements of one (1) or two (2) ranges and stores the result in the range that begins at <code>result</code>.</p>
<p>(1) <code>unary operation</code>:</p>
<p>Applies op to each of the elements in the range <code>[first1,last1)</code> and stores the value returned by each operation in the range that begins at <code>result</code>.</p>
<p>(2) <code>binary operation</code>:</p>
<p>Calls binary_op using each of the elements in the range <code>[first1,last1)</code> as first argument, and the respective argument in the range that begins at <code>first2</code> as second argument. The value returned by each call is stored in the range that begins at <code>result</code>.</p>
<p>The behavior of this function template is equivalent to:</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;class InputIterator, class OutputIterator, class UnaryOperator&gt;
  OutputIterator transform (InputIterator first1, InputIterator last1,
                            OutputIterator result, UnaryOperator op)
&#123;
  while (first1 !&#x3D; last1) &#123;
    *result &#x3D; op(*first1);  &#x2F;&#x2F; or: *result&#x3D;binary_op(*first1,*first2++);
    ++result; ++first1;
  &#125;
  return result;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>The function allows for the destination range to be the same as one of the input ranges to make transformations in place.</code></p>
<p><strong><code>Parameters</code></strong></p>
<p><strong>first1, last1</strong></p>
<p><code>Input iterators</code> to the initial and final positions of the first sequence. The range used is <code>[first1,last1)</code>, which contains all the elements between first1 and last1, including the element pointed to by first1 but not the element pointed to by last1.</p>
<p><strong>first2</strong></p>
<p><code>Input iterator</code> to the initial position of the second range.<code> The range includes as many elements as [first1,last1).</code></p>
<p><strong>result</strong></p>
<p><code>Output iterator</code> to the initial position of the range where the operation results are stored. <code>The range includes as many elements as [first1,last1).</code></p>
<p><strong>op</strong></p>
<p><code>Unary function</code> that accepts one element of the type pointed to by InputIterator as argument, and returns some result value convertible to the type pointed to by <code>OutputIterator</code>.</p>
<p>This can either be <code>a function pointer</code> or <code>a function object</code>.</p>
<p><strong>binary_op</strong></p>
<p><code>Binary function</code> that accepts two elements as argument (one of each of the two sequences), and returns some result value convertible to the type pointed to by OutputIterator.</p>
<p>This can either be <code>a function pointer</code> or <code>a function object</code>.</p>
<hr>
<p>Neither <code>op</code> nor <code>binary_op</code> should directly modify the elements passed as its arguments: These are indirectly modified by the algorithm (using the return value) if the same range is specified for result.</p>
<p><strong><code>Return Value</code></strong></p>
<p>An iterator pointing to the element that follows the last element written in the result sequence.</p>
<p><strong><code>Example</code></strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; transform algorithm example
#include &lt;iostream&gt;     &#x2F;&#x2F; std::cout
#include &lt;algorithm&gt;    &#x2F;&#x2F; std::transform
#include &lt;vector&gt;       &#x2F;&#x2F; std::vector
#include &lt;functional&gt;   &#x2F;&#x2F; std::plus

int op_increase (int i) &#123; return ++i; &#125;

int main () &#123;
  std::vector&lt;int&gt; foo;
  std::vector&lt;int&gt; bar;

  &#x2F;&#x2F; set some values:
  for (int i&#x3D;1; i&lt;6; i++)
    foo.push_back (i*10);                         &#x2F;&#x2F; foo: 10 20 30 40 50

  bar.resize(foo.size());                         &#x2F;&#x2F; allocate space

  std::transform (foo.begin(), foo.end(), bar.begin(), op_increase);
                                                  &#x2F;&#x2F; bar: 11 21 31 41 51

  &#x2F;&#x2F; std::plus adds together its two arguments:
  std::transform (foo.begin(), foo.end(), bar.begin(), foo.begin(), std::plus&lt;int&gt;());
                                                  &#x2F;&#x2F; foo: 21 41 61 81 101

  std::cout &lt;&lt; &quot;foo contains:&quot;;
  for (std::vector&lt;int&gt;::iterator it&#x3D;foo.begin(); it!&#x3D;foo.end(); ++it)
    std::cout &lt;&lt; &#39; &#39; &lt;&lt; *it;
  std::cout &lt;&lt; &#39;\n&#39;;

  return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>输出</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">foo contains: <span class="token number">21</span> <span class="token number">41</span> <span class="token number">61</span> <span class="token number">81</span> <span class="token number">101</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><strong><code>Complexity</code></strong></p>
<p><code>Linear</code> in the distance between first1 and last1: Performs one assignment and one application of op (or binary_op) per element.</p>
<p><strong><code>Data races</code></strong></p>
<p>The objects in the range <code>[first1,last1)</code> (and eventually those in the range beginning at first2) are accessed (each object is accessed exactly once).</p>
<p>The objects in the range beginning at <code>result</code> are <code>modified</code>.</p>
<p><strong><code>Exceptions</code></strong></p>
<p>Throws if any of the function calls, the assignments or the operations on iterators throws.</p>
<p>Note that invalid arguments cause undefined behavior.</p>
<h3 id="Sorting"><a href="#Sorting" class="headerlink" title="Sorting"></a>Sorting</h3><ul>
<li><code>sort</code>: Sort elements in range (function template)</li>
</ul>
<h4 id="std-sort"><a href="#std-sort" class="headerlink" title="std::sort"></a><code>std::sort</code></h4><p><code>std::sort</code>: <a href="https://cplusplus.com/reference/algorithm/sort/">https://cplusplus.com/reference/algorithm/sort/</a> 。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">default (1)	
template &lt;class RandomAccessIterator&gt;  void sort (RandomAccessIterator first, RandomAccessIterator last);
custom (2)	
template &lt;class RandomAccessIterator, class Compare&gt;  void sort (RandomAccessIterator first, RandomAccessIterator last, Compare comp);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong><code>Sort elements in range</code></strong></p>
<p><code>Sorts</code> the elements in the range <code>[first,last)</code> into <code>ascending order</code>.</p>
<p>The elements are compared using <code>operator&lt;</code> for the <code>first</code> version, and <code>comp</code> for the <code>second</code>.</p>
<p>Equivalent elements <code>are not guaranteed to keep their original relative order</code> (see <code>stable_sort</code>).</p>
<p><strong><code>Parameters</code></strong></p>
<p><strong>first, last</strong></p>
<ol>
<li><p><code>Random-access iterators</code> to the initial and final positions of the sequence to be sorted. The range used is <code>[first,last)</code>, which contains all the elements between <code>first</code> and <code>last</code>, including the element pointed by <code>first</code> but not the element pointed by <code>last</code>.</p>
</li>
<li><p><code>RandomAccessIterator</code> shall point to a type for which <code>swap</code> is properly defined and which is both <code>move-constructible</code> and <code>move-assignable</code>.</p>
</li>
</ol>
<p><strong>comp</strong></p>
<ol>
<li><p>Binary function that accepts <code>two elements</code> in the range as arguments, and returns a value convertible to <code>bool</code>. <code>The value returned indicates whether the element passed as first argument is considered to go before the second in the specific strict weak ordering it defines</code>.</p>
</li>
<li><p>The function <code>shall not modify any of its arguments</code>.</p>
</li>
<li><p>This can either be <code>a function pointer or a function object</code>.</p>
</li>
</ol>
<p><strong><code>Return Value</code></strong></p>
<p>none.</p>
<p><strong><code>Example</code></strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; sort algorithm example
#include &lt;iostream&gt;     &#x2F;&#x2F; std::cout
#include &lt;algorithm&gt;    &#x2F;&#x2F; std::sort
#include &lt;vector&gt;       &#x2F;&#x2F; std::vector

bool myfunction (int i,int j) &#123; return (i&lt;j); &#125;

struct myclass &#123;
  bool operator() (int i,int j) &#123; return (i&lt;j);&#125;
&#125; myobject;

int main () &#123;
  int myints[] &#x3D; &#123;32,71,12,45,26,80,53,33&#125;;
  std::vector&lt;int&gt; myvector (myints, myints+8);               &#x2F;&#x2F; 32 71 12 45 26 80 53 33

  &#x2F;&#x2F; using default comparison (operator &lt;):
  std::sort (myvector.begin(), myvector.begin()+4);           &#x2F;&#x2F;(12 32 45 71)26 80 53 33

  &#x2F;&#x2F; using function as comp
  std::sort (myvector.begin()+4, myvector.end(), myfunction); &#x2F;&#x2F; 12 32 45 71(26 33 53 80)

  &#x2F;&#x2F; using object as comp
  std::sort (myvector.begin(), myvector.end(), myobject);     &#x2F;&#x2F;(12 26 32 33 45 53 71 80)

  &#x2F;&#x2F; print out content:
  std::cout &lt;&lt; &quot;myvector contains:&quot;;
  for (std::vector&lt;int&gt;::iterator it&#x3D;myvector.begin(); it!&#x3D;myvector.end(); ++it)
    std::cout &lt;&lt; &#39; &#39; &lt;&lt; *it;
  std::cout &lt;&lt; &#39;\n&#39;;

  return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>可能的输出</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">myvector contains: <span class="token number">12</span> <span class="token number">26</span> <span class="token number">32</span> <span class="token number">33</span> <span class="token number">45</span> <span class="token number">53</span> <span class="token number">71</span> <span class="token number">80</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><strong><code>Complexity</code></strong></p>
<p>On average, <code>linearithmic</code> in the distance between <code>first</code> and <code>last</code>: <code>Performs approximately N*log2(N) (where N is this distance) comparisons of elements, and up to that many element swaps (or moves)</code>.</p>
<p><strong><code>Data races</code></strong></p>
<p>The objects in the range <code>[first,last)</code> are <code>modified</code>.</p>
<h3 id="Min-max"><a href="#Min-max" class="headerlink" title="Min&#x2F;max"></a>Min&#x2F;max</h3><ul>
<li><code>min</code>: Return the smallest (function template)</li>
</ul>
<h4 id="std-min"><a href="#std-min" class="headerlink" title="std::min"></a><code>std::min</code></h4><p><code>std::min</code>: <a href="https://cplusplus.com/reference/algorithm/min/">https://cplusplus.com/reference/algorithm/min/</a> 。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">default (1)	
template &lt;class T&gt; const T&amp; min (const T&amp; a, const T&amp; b);
custom (2)	
template &lt;class T, class Compare&gt;  const T&amp; min (const T&amp; a, const T&amp; b, Compare comp);
initializer list (3)	
template &lt;class T&gt; T min (initializer_list&lt;T&gt; il);template &lt;class T, class Compare&gt;  T min (initializer_list&lt;T&gt; il, Compare comp);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong><code>Return the smallest</code></strong></p>
<p>Returns the smallest of <code>a</code> and <code>b</code>. If both are equivalent, <code>a</code> is returned.</p>
<p>The versions for <code>initializer lists (3)</code> return <code>the smallest</code> of all the elements in the list. Returning the first of them if these are more than one.</p>
<p>The function uses <code>operator&lt;</code> (or <code>comp</code>, if provided) to compare the values.</p>
<p>The behavior of this function template (C++98) is equivalent to:</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;class T&gt; const T&amp; min (const T&amp; a, const T&amp; b) &#123;
  return !(b&lt;a)?a:b;     &#x2F;&#x2F; or: return !comp(b,a)?a:b; for version (2)
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p><strong><code>Parameters</code></strong></p>
<p><strong>a, b</strong></p>
<ol>
<li><code>Values</code> to compare.</li>
</ol>
<p><strong>comp</strong></p>
<ol>
<li><p><code>Binary function</code> that accepts <code>two values</code> of type <code>T</code> as arguments, and returns <code>a value convertible to bool</code>. The value returned <code>indicates</code> whether the element passed as <code>first argument</code> is considered <code>less than</code> the second.</p>
</li>
<li><p>The function <code>shall not modify</code> any of its arguments.</p>
</li>
<li><p>This can either be <code>a function pointer</code> or <code>a function object</code>.</p>
</li>
</ol>
<p><strong>il</strong></p>
<ol>
<li><p>An <code>initializer_list</code> object.</p>
</li>
<li><p>These objects are automatically constructed from <code>initializer list</code> declarators.</p>
</li>
</ol>
<p><code>T</code> shall support being compared with <code>operator&lt;</code>.</p>
<p><strong><code>Return Value</code></strong></p>
<p>The <code>lesser</code> of the values passed as arguments.</p>
<p><strong><code>Example</code></strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; min example
#include &lt;iostream&gt;     &#x2F;&#x2F; std::cout
#include &lt;algorithm&gt;    &#x2F;&#x2F; std::min

int main () &#123;
  std::cout &lt;&lt; &quot;min(1,2)&#x3D;&#x3D;&quot; &lt;&lt; std::min(1,2) &lt;&lt; &#39;\n&#39;;
  std::cout &lt;&lt; &quot;min(2,1)&#x3D;&#x3D;&quot; &lt;&lt; std::min(2,1) &lt;&lt; &#39;\n&#39;;
  std::cout &lt;&lt; &quot;min(&#39;a&#39;,&#39;z&#39;)&#x3D;&#x3D;&quot; &lt;&lt; std::min(&#39;a&#39;,&#39;z&#39;) &lt;&lt; &#39;\n&#39;;
  std::cout &lt;&lt; &quot;min(3.14,2.72)&#x3D;&#x3D;&quot; &lt;&lt; std::min(3.14,2.72) &lt;&lt; &#39;\n&#39;;
  return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>输出</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">min<span class="token punctuation">(</span><span class="token number">1,2</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">1</span>
min<span class="token punctuation">(</span><span class="token number">2,1</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">1</span>
min<span class="token punctuation">(</span><span class="token string">'a'</span>,<span class="token string">'z'</span><span class="token punctuation">)</span><span class="token operator">==</span>a
min<span class="token punctuation">(</span><span class="token number">3.14</span>,2.72<span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">2.72</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong><code>Complexity</code></strong></p>
<p><code>Linear</code> in one less than the number of elements compared (constant for <code>(1)</code> and <code>(2)</code>).</p>
<h2 id="-5"><a href="#-5" class="headerlink" title="&lt;iterator&gt;"></a><code>&lt;iterator&gt;</code></h2><p><code>&lt;iterator&gt;</code>: <a href="https://cplusplus.com/reference/iterator/">https://cplusplus.com/reference/iterator/</a> 。</p>
<p><code>&lt;iterator&gt;</code>: Iterator definitions (header).</p>
<h3 id="Iterator-operations"><a href="#Iterator-operations" class="headerlink" title="Iterator operations"></a>Iterator operations</h3><ul>
<li><code>begin</code>: Iterator to beginning (function template)</li>
</ul>
<h4 id="std-begin"><a href="#std-begin" class="headerlink" title="std::begin"></a><code>std::begin</code></h4><p><code>std::begin</code>: <a href="https://cplusplus.com/reference/iterator/begin/">https://cplusplus.com/reference/iterator/begin/</a> 。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">container (1)	
template &lt;class Container&gt;  auto begin (Container&amp; cont) -&gt; decltype (cont.begin());template &lt;class Container&gt;  auto begin (const Container&amp; cont) -&gt; decltype (cont.begin());
array (2)	
template &lt;class T, size_t N&gt;  T* begin (T(&amp;arr)[N]);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong><code>Iterator to beginning</code></strong></p>
<p>Returns <code>an iterator pointing</code> to <code>the first element</code> in the sequence:</p>
<p><strong>(1) Container</strong></p>
<p>The function returns <code>cont.begin().</code></p>
<p><strong>(2) Array</strong></p>
<p>The function returns <code>the array-to-pointer conversion</code> of its argument.</p>
<p>If the sequence is <code>empty</code>, the returned value <code>shall not be dereferenced</code>.</p>
<p>These function templates <code>are defined in multiple headers</code>: Each of these headers includes the generic templates for all container and array types and not simply a specific overload. The headers are: <code>&lt;iterator&gt;</code>, <code>&lt;array&gt;</code>, <code>&lt;deque&gt;</code>, <code>&lt;forward_list&gt;</code>, <code>&lt;list&gt;</code>, <code>&lt;map&gt;</code>, <code>&lt;regex&gt;</code>, <code>&lt;set&gt;</code>, <code>&lt;string&gt;</code>, <code>&lt;unordered_map&gt;</code>, <code>&lt;unordered_set&gt;</code> and <code>&lt;vector&gt;</code>.</p>
<p>Conversely, <code>begin</code> is <code>overloaded</code> (with a different definition) in headers <code>&lt;initializer_list&gt;</code> and <code>&lt;valarray&gt;</code>.</p>
<p><strong><code>Parameters</code></strong></p>
<p><strong>cont</strong></p>
<ol>
<li>An object of a class type for which member <code>begin</code> is defined.</li>
</ol>
<p><strong>arr</strong></p>
<ol>
<li>An array.</li>
</ol>
<p><strong><code>Return Value</code></strong></p>
<p>For <code>(1)</code>, the same as returned by <code>cont.begin()</code>.</p>
<p>For <code>(2)</code>, <code>a pointer to the first element in the array</code>.</p>
<p><strong><code>Example</code></strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; std::begin &#x2F; std::end example
#include &lt;iostream&gt;     &#x2F;&#x2F; std::cout
#include &lt;vector&gt;       &#x2F;&#x2F; std::vector, std::begin, std::end

int main () &#123;
  int foo[] &#x3D; &#123;10,20,30,40,50&#125;;
  std::vector&lt;int&gt; bar;

  &#x2F;&#x2F; iterate foo: inserting into bar
  for (auto it &#x3D; std::begin(foo); it!&#x3D;std::end(foo); ++it)
    bar.push_back(*it);

  &#x2F;&#x2F; iterate bar: print contents:
  std::cout &lt;&lt; &quot;bar contains:&quot;;
  for (auto it &#x3D; std::begin(bar); it!&#x3D;std::end(bar); ++it)
    std::cout &lt;&lt; &#39; &#39; &lt;&lt; *it;
  std::cout &lt;&lt; &#39;\n&#39;;

  return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>输出</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">bar contains: <span class="token number">10</span> <span class="token number">20</span> <span class="token number">30</span> <span class="token number">40</span> <span class="token number">50</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><strong><code>Data races</code></strong></p>
<p>The argument is <code>accessed</code> but <code>not modified</code>.</p>
<p><code>None of the elements</code> in the sequence are accessed by the call, but <code>the iterator returned</code> can be used to <code>access or modify them</code>.</p>
<h2 id="-6"><a href="#-6" class="headerlink" title="&lt;string&gt;"></a><code>&lt;string&gt;</code></h2><p><code>&lt;string&gt;</code>: <a href="https://cplusplus.com/reference/string/">https://cplusplus.com/reference/string/</a> 。</p>
<p><code>&lt;string&gt;</code>: Strings.</p>
<h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><ul>
<li><code>c_str</code>: Get C string equivalent (public member function)</li>
</ul>
<h4 id="std-string-c-str"><a href="#std-string-c-str" class="headerlink" title="std::string::c_str"></a><code>std::string::c_str</code></h4><p><code>std::string::c_str</code>: <a href="https://cplusplus.com/reference/string/string/c_str/">https://cplusplus.com/reference/string/string/c_str/</a> 。</p>
<p><code>const char* c_str() const;</code></p>
<p><strong><code>Get C string equivalent</code></strong></p>
<p>Returns <code>a pointer</code> to <code>an array</code> that contains <code>a null-terminated sequence of characters</code> (i.e., a C-string) representing the current value of the string object.</p>
<p>This array includes the same sequence of characters that make up <code>the value of the string object plus an additional terminating null-character (&#39;\0&#39;) at the end</code>.</p>
<p><strong><code>Parameters</code></strong></p>
<p><strong>none</strong></p>
<p><strong><code>Return Value</code></strong></p>
<p><code>A pointer</code> to <code>the c-string representation</code> of the string object’s value.</p>
<p><strong><code>Example</code></strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; strings and c-strings
#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;string&gt;

int main ()
&#123;
  std::string str (&quot;Please split this sentence into tokens&quot;);

  char * cstr &#x3D; new char [str.length()+1];
  std::strcpy (cstr, str.c_str());

  &#x2F;&#x2F; cstr now contains a c-string copy of str

  char * p &#x3D; std::strtok (cstr,&quot; &quot;);
  while (p!&#x3D;0)
  &#123;
    std::cout &lt;&lt; p &lt;&lt; &#39;\n&#39;;
    p &#x3D; std::strtok(NULL,&quot; &quot;);
  &#125;

  delete[] cstr;
  return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>输出</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Please
<span class="token function">split</span>
this
sentence
into
tokens<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="Convert-to-strings"><a href="#Convert-to-strings" class="headerlink" title="Convert to strings"></a>Convert to strings</h3><ul>
<li><code>to_string</code>: Convert numerical value to string (function)</li>
</ul>
<h4 id="std-to-string"><a href="#std-to-string" class="headerlink" title="std::to_string"></a><code>std::to_string</code></h4><p><code>std::to_string</code>: <a href="https://cplusplus.com/reference/string/to_string/">https://cplusplus.com/reference/string/to_string/</a> 。</p>
<p><code>string to_string (int val);string to_string (long val);string to_string (long long val);string to_string (unsigned val);string to_string (unsigned long val);string to_string (unsigned long long val);string to_string (float val);string to_string (double val);string to_string (long double val);</code></p>
<p><strong><code>Convert numerical value to string</code></strong></p>
<p>Returns a <code>string</code> with <code>the representation of val</code>.</p>
<p><strong><code>Parameters</code></strong></p>
<p><strong>val</strong></p>
<ol>
<li>Numerical value.</li>
</ol>
<p><strong><code>Return Value</code></strong></p>
<p>A <code>string object</code> containing the representation of <code>val</code> as <code>a sequence of characters</code>.</p>
<p><strong><code>Example</code></strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; to_string example
#include &lt;iostream&gt;   &#x2F;&#x2F; std::cout
#include &lt;string&gt;     &#x2F;&#x2F; std::string, std::to_string

int main ()
&#123;
  std::string pi &#x3D; &quot;pi is &quot; + std::to_string(3.1415926);
  std::string perfect &#x3D; std::to_string(1+2+4+7+14) + &quot; is a perfect number&quot;;
  std::cout &lt;&lt; pi &lt;&lt; &#39;\n&#39;;
  std::cout &lt;&lt; perfect &lt;&lt; &#39;\n&#39;;
  return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>可能的输出</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pi is <span class="token number">3.141593</span>
<span class="token number">28</span> is a perfect number<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h2 id="-7"><a href="#-7" class="headerlink" title="&lt;utility&gt;"></a><code>&lt;utility&gt;</code></h2><p><code>&lt;utility&gt;</code>: <a href="https://cplusplus.com/reference/utility/">https://cplusplus.com/reference/utility/</a> 。</p>
<p><code>&lt;utility&gt;</code>: Utility components (header).</p>
<h3 id="Types"><a href="#Types" class="headerlink" title="Types"></a>Types</h3><ul>
<li><code>pair</code>: Pair of values (class template)</li>
</ul>
<h4 id="std-pair"><a href="#std-pair" class="headerlink" title="std::pair"></a><code>std::pair</code></h4><p><code>std::pair</code>: <a href="https://cplusplus.com/reference/utility/pair/">https://cplusplus.com/reference/utility/pair/</a> 。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;class T1, class T2&gt; struct pair;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><strong><code>Pair of values</code></strong></p>
<p>This class <code>couples</code> together <code>a pair of values</code>, which may <code>be of different types</code> (<code>T1</code> and <code>T2</code>). The individual values can be <code>accessed</code> through its public members <code>first</code> and <code>second</code>.</p>
<p><code>Pairs</code> are <code>a particular case</code> of <code>tuple</code>.</p>
<p><strong><code>Template parameters</code></strong></p>
<p><strong>T1</strong></p>
<p>Type of member <code>first</code>, aliased as <code>first_type</code>.</p>
<p><strong>T2</strong></p>
<p>Type of member <code>second</code>, aliased as <code>second_type</code>.</p>
<p><strong><code>Member types</code></strong></p>
<table>
<thead>
<tr>
<th align="center">member type</th>
<th align="center">definition</th>
<th align="center">notes</th>
</tr>
</thead>
<tbody><tr>
<td align="center">first_type</td>
<td align="center">The first template parameter (T1)</td>
<td align="center">Type of member first.</td>
</tr>
<tr>
<td align="center">second_type</td>
<td align="center">The second template parameter (T2)</td>
<td align="center">Type of member second.</td>
</tr>
</tbody></table>
<p><strong><code>Member variables</code></strong></p>
<table>
<thead>
<tr>
<th align="center">member variable</th>
<th align="center">definition</th>
</tr>
</thead>
<tbody><tr>
<td align="center">first</td>
<td align="center">The first value in the pair</td>
</tr>
<tr>
<td align="center">second</td>
<td align="center">The second value in the pair</td>
</tr>
</tbody></table>
<div id = "6"></div>

<h1 id="C-语法"><a href="#C-语法" class="headerlink" title="C++ 语法"></a>C++ 语法</h1><h2 id="移位运算符"><a href="#移位运算符" class="headerlink" title="移位运算符"></a>移位运算符</h2><p>在 <code>C++</code> 中，<code>移位运算符</code>有双目移位运算符：<code>&lt;&lt;</code>（左移）和 <code>&gt;&gt;</code>（右移）。</p>
<p><code>左移运算</code>是将一个<code>二进制位的操作数</code>按指定<code>移动的位数</code>向<code>左移位</code>，<code>移出位被丢弃</code>，右边的空位一律<code>补 0</code>。</p>
<p><code>右移运算</code>是将一个<code>二进制位的操作数</code>按指定<code>移动的位数</code>向<code>右移动</code>，<code>移出位被丢弃</code>，左边移出的空位或者<code>一律补 0</code>，或者<code>补符号位</code>，这<code>由不同的机器而定</code>。在使用<code>补码</code>作为<code>机器数</code>的机器中，正数的符号位为 <code>0</code>，负数的符号位为 <code>1</code>。<code>右移</code>对于<code>无符号类型</code>强制补 <code>0</code>，对于<code>有符号类型</code>续补<code>符号位</code>。</p>
<h2 id="常函数和常对象"><a href="#常函数和常对象" class="headerlink" title="常函数和常对象"></a>常函数和常对象</h2><p>源教程链接: <a href="https://blog.csdn.net/qq_63610563/article/details/124088619">https://blog.csdn.net/qq_63610563/article/details/124088619</a> .</p>
<ul>
<li><p>常函数: 成员函数后加 const 后, 称这个函数为常函数.</p>
<ul>
<li><p>常函数内不可以修改成员属性;</p>
</li>
<li><p>成员属性声明时加关键字 mutable 后, 在常函数中可以修改.</p>
</li>
</ul>
</li>
<li><p>常对象: 声明对象前加 const, 称该对象为常对象.</p>
<ul>
<li>常对象只能调用常函数.</li>
</ul>
</li>
</ul>
<hr>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
using namespace std;
 
class person
&#123;
public:
	void show()const
	&#123;
		m_A &#x3D; 100;
	&#125;
	int m_A;
&#125;;
 
int main()
&#123;
	person p;
	p.show();
	system(&quot;pause&quot;);
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>第7行报错, 因为 <code>m_A</code> 其实为 <code>this-&gt;m_A</code>, <code>this</code> 指针的本质是<code>指针常量</code>, <code>指向是不可改的, 包括 this=NULL 也是不行的</code>. 要变成可修改的值, 需要把第 11 行改为 <code>mutable int m_A</code>.</p>
<blockquote>
<p>不加 const, this 的本意：<code>person* const this</code>, 不可以改 this 的指向，可以改指向的变量的值.</p>
<p>第 7 行加 const, this 的本意：<code>const person* const this</code>, 不可以修改 this 的指向, 也不可以修改指向的变量的值.</p>
</blockquote>
<hr>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
using namespace std;
 
class person
&#123;
public:
	void show()const
	&#123;
		this-&gt;m_B &#x3D; 100;
	&#125;
	int m_A;
	mutable int m_B;
&#125;;
 
int main()
&#123;
	const person p&#x2F;&#x2F;在对象前加const，变常对象
	p.m_A &#x3D; 100;&#x2F;&#x2F;报错
	p.m_B &#x3D; 100;&#x2F;&#x2F;正确
	system(&quot;pause&quot;);
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>第 18 行报错的原因如上例所说，常对象的<code>成员属性</code>也不可以修改，要加 <code>mutable</code>.</p>
<hr>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
using namespace std;
 
class person
&#123;
public:
	void show()
	&#123; &#125;
&#125;;
 
int main()
&#123;
	const person p&#x2F;&#x2F;在对象前加const，变常对象
	p.show();
	system(&quot;pause&quot;);
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>第 14 行报错, 因为<code>常对象只能调用常函数</code>, 而 <code>show()</code> 不是常函数.</p>
<div id = "7"></div>

<h1 id="计算机基础"><a href="#计算机基础" class="headerlink" title="计算机基础"></a>计算机基础</h1><h2 id="ASCII"><a href="#ASCII" class="headerlink" title="ASCII"></a>ASCII</h2><p><code>ASCII</code> (American Standard Code for Information Interchange)：<code>美国信息交换标准代码</code>是基于拉丁字母的一套电脑编码系统，主要用于显示<code>现代英语</code>和<code>其他西欧语言</code>。它是<code>最通用的信息交换标准</code>，并等同于国际标准 ISO&#x2F;IEC 646。ASCII第一次以规范标准的类型发表是在 <code>1967</code> 年，最后一次更新则是在 <code>1986</code> 年，到目前为止共定义了 <code>128</code> 个字符。</p>
<p><img src="https://cos.luyf-lemon-love.space/images/20221126225117.png"></p>
<h2 id="ASCII-码表"><a href="#ASCII-码表" class="headerlink" title="ASCII 码表"></a>ASCII 码表</h2><p>原教程地址: <a href="https://zh.cppreference.com/w/cpp/language/ascii">https://zh.cppreference.com/w/cpp/language/ascii</a> .</p>
<p>下列码表含有全部 128 个 ASCII 十进制 (<strong>dec</strong>) 、八进制 (<strong>oct</strong>) 、十六进制 (<strong>hex</strong>) 及字符 (<strong>ch</strong>) 编码。</p>
<table class="wikitable" style="text-align: left;">

<tr>
<th> <code>dec</code> </th>
<th> <code>oct</code> </th>
<th> <code>hex</code>
</th>
<th style="text-align: left;"> <code>ch</code>
</th>
<td rowspan="33">
</td>
<th> <code>dec</code> </th>
<th> <code>oct</code> </th>
<th> <code>hex</code>
</th>
<th style="text-align: left;"> <code>ch</code>
</th>
<td rowspan="33">
</td>
<th> <code>dec</code> </th>
<th> <code>oct</code> </th>
<th> <code>hex</code>
</th>
<th style="text-align: left;"> <code>ch</code>
</th>
<td rowspan="33">
</td>
<th> <code>dec</code> </th>
<th> <code>oct</code> </th>
<th> <code>hex</code>
</th>
<th style="text-align: left;"> <code>ch</code>
</th></tr>
<tr>
<td> <code> 0</code></td>
<td> <code>0</code></td>
<td><code>00</code></td>
<td><code><b>NUL</b></code> (空) </td>
<td> <code>32</code></td>
<td><code>40</code></td>
<td><code>20</code></td>
<td>(空格) </td>
<td> <code>64</code></td>
<td><code>100</code></td>
<td><code>40</code></td>
<td><code><b>@</b></code> </td>
<td> <code> 96</code></td>
<td><code>140</code></td>
<td><code>60</code></td>
<td><code><b>`</b></code>
</td></tr>
<tr>
<td> <code> 1</code></td>
<td> <code>1</code></td>
<td><code>01</code></td>
<td><code><b>SOH</b></code> (标题开始) </td>
<td> <code>33</code></td>
<td><code>41</code></td>
<td><code>21</code></td>
<td><code><b>!</b></code> </td>
<td> <code>65</code></td>
<td><code>101</code></td>
<td><code>41</code></td>
<td><code><b>A</b></code> </td>
<td> <code> 97</code></td>
<td><code>141</code></td>
<td><code>61</code></td>
<td><code><b>a</b></code>
</td></tr>
<tr>
<td> <code> 2</code></td>
<td> <code>2</code></td>
<td><code>02</code></td>
<td><code><b>STX</b></code> (正文开始) </td>
<td> <code>34</code></td>
<td><code>42</code></td>
<td><code>22</code></td>
<td><code><b>"</b></code> </td>
<td> <code>66</code></td>
<td><code>102</code></td>
<td><code>42</code></td>
<td><code><b>B</b></code> </td>
<td> <code> 98</code></td>
<td><code>142</code></td>
<td><code>62</code></td>
<td><code><b>b</b></code>
</td></tr>
<tr>
<td> <code> 3</code></td>
<td> <code>3</code></td>
<td><code>03</code></td>
<td><code><b>ETX</b></code> (正文结束) </td>
<td> <code>35</code></td>
<td><code>43</code></td>
<td><code>23</code></td>
<td><code><b>#</b></code> </td>
<td> <code>67</code></td>
<td><code>103</code></td>
<td><code>43</code></td>
<td><code><b>C</b></code> </td>
<td> <code> 99</code></td>
<td><code>143</code></td>
<td><code>63</code></td>
<td><code><b>c</b></code>
</td></tr>
<tr>
<td> <code> 4</code></td>
<td> <code>4</code></td>
<td><code>04</code></td>
<td><code><b>EOT</b></code> (传送结束) </td>
<td> <code>36</code></td>
<td><code>44</code></td>
<td><code>24</code></td>
<td><code><b>$</b></code> </td>
<td> <code>68</code></td>
<td><code>104</code></td>
<td><code>44</code></td>
<td><code><b>D</b></code> </td>
<td> <code>100</code></td>
<td><code>144</code></td>
<td><code>64</code></td>
<td><code><b>d</b></code>
</td></tr>
<tr>
<td> <code> 5</code></td>
<td> <code>5</code></td>
<td><code>05</code></td>
<td><code><b>ENQ</b></code> (询问) </td>
<td> <code>37</code></td>
<td><code>45</code></td>
<td><code>25</code></td>
<td><code><b>%</b></code> </td>
<td> <code>69</code></td>
<td><code>105</code></td>
<td><code>45</code></td>
<td><code><b>E</b></code> </td>
<td> <code>101</code></td>
<td><code>145</code></td>
<td><code>65</code></td>
<td><code><b>e</b></code>
</td></tr>
<tr>
<td> <code> 6</code></td>
<td> <code>6</code></td>
<td><code>06</code></td>
<td><code><b>ACK</b></code> (确认) </td>
<td> <code>38</code></td>
<td><code>46</code></td>
<td><code>26</code></td>
<td><code><b>&amp;</b></code> </td>
<td> <code>70</code></td>
<td><code>106</code></td>
<td><code>46</code></td>
<td><code><b>F</b></code> </td>
<td> <code>102</code></td>
<td><code>146</code></td>
<td><code>66</code></td>
<td><code><b>f</b></code>
</td></tr>
<tr>
<td> <code> 7</code></td>
<td> <code>7</code></td>
<td><code>07</code></td>
<td><code><b>BEL</b></code> (响铃) </td>
<td> <code>39</code></td>
<td><code>47</code></td>
<td><code>27</code></td>
<td><code><b>'</b></code> </td>
<td> <code>71</code></td>
<td><code>107</code></td>
<td><code>47</code></td>
<td><code><b>G</b></code> </td>
<td> <code>103</code></td>
<td><code>147</code></td>
<td><code>67</code></td>
<td><code><b>g</b></code>
</td></tr>
<tr>
<td> <code> 8</code></td>
<td><code>10</code></td>
<td><code>08</code></td>
<td><code><b>BS</b></code> (退格) </td>
<td> <code>40</code></td>
<td><code>50</code></td>
<td><code>28</code></td>
<td><code><b>(</b></code> </td>
<td> <code>72</code></td>
<td><code>110</code></td>
<td><code>48</code></td>
<td><code><b>H</b></code> </td>
<td> <code>104</code></td>
<td><code>150</code></td>
<td><code>68</code></td>
<td><code><b>h</b></code>
</td></tr>
<tr>
<td> <code> 9</code></td>
<td><code>11</code></td>
<td><code>09</code></td>
<td><code><b>HT</b></code> (横向制表) </td>
<td> <code>41</code></td>
<td><code>51</code></td>
<td><code>29</code></td>
<td><code><b>)</b></code> </td>
<td> <code>73</code></td>
<td><code>111</code></td>
<td><code>49</code></td>
<td><code><b>I</b></code> </td>
<td> <code>105</code></td>
<td><code>151</code></td>
<td><code>69</code></td>
<td><code><b>i</b></code>
</td></tr>
<tr>
<td> <code>10</code></td>
<td><code>12</code></td>
<td><code>0a</code></td>
<td><code><b>LF</b></code> (换行) </td>
<td> <code>42</code></td>
<td><code>52</code></td>
<td><code>2a</code></td>
<td><code><b>*</b></code> </td>
<td> <code>74</code></td>
<td><code>112</code></td>
<td><code>4a</code></td>
<td><code><b>J</b></code> </td>
<td> <code>106</code></td>
<td><code>152</code></td>
<td><code>6a</code></td>
<td><code><b>j</b></code>
</td></tr>
<tr>
<td> <code>11</code></td>
<td><code>13</code></td>
<td><code>0b</code></td>
<td><code><b>VT</b></code> (纵向制表) </td>
<td> <code>43</code></td>
<td><code>53</code></td>
<td><code>2b</code></td>
<td><code><b>+</b></code> </td>
<td> <code>75</code></td>
<td><code>113</code></td>
<td><code>4b</code></td>
<td><code><b>K</b></code> </td>
<td> <code>107</code></td>
<td><code>153</code></td>
<td><code>6b</code></td>
<td><code><b>k</b></code>
</td></tr>
<tr>
<td> <code>12</code></td>
<td><code>14</code></td>
<td><code>0c</code></td>
<td><code><b>FF</b></code> (换页) </td>
<td> <code>44</code></td>
<td><code>54</code></td>
<td><code>2c</code></td>
<td><code><b>,</b></code> </td>
<td> <code>76</code></td>
<td><code>114</code></td>
<td><code>4c</code></td>
<td><code><b>L</b></code> </td>
<td> <code>108</code></td>
<td><code>154</code></td>
<td><code>6c</code></td>
<td><code><b>l</b></code>
</td></tr>
<tr>
<td> <code>13</code></td>
<td><code>15</code></td>
<td><code>0d</code></td>
<td><code><b>CR</b></code> (回车) </td>
<td> <code>45</code></td>
<td><code>55</code></td>
<td><code>2d</code></td>
<td><code><b>-</b></code> </td>
<td> <code>77</code></td>
<td><code>115</code></td>
<td><code>4d</code></td>
<td><code><b>M</b></code> </td>
<td> <code>109</code></td>
<td><code>155</code></td>
<td><code>6d</code></td>
<td><code><b>m</b></code>
</td></tr>
<tr>
<td> <code>14</code></td>
<td><code>16</code></td>
<td><code>0e</code></td>
<td><code><b>SO</b></code> (移出) </td>
<td> <code>46</code></td>
<td><code>56</code></td>
<td><code>2e</code></td>
<td><code><b>.</b></code> </td>
<td> <code>78</code></td>
<td><code>116</code></td>
<td><code>4e</code></td>
<td><code><b>N</b></code> </td>
<td> <code>110</code></td>
<td><code>156</code></td>
<td><code>6e</code></td>
<td><code><b>n</b></code>
</td></tr>
<tr>
<td> <code>15</code></td>
<td><code>17</code></td>
<td><code>0f</code></td>
<td><code><b>SI</b></code> (移入) </td>
<td> <code>47</code></td>
<td><code>57</code></td>
<td><code>2f</code></td>
<td><code><b>/</b></code> </td>
<td> <code>79</code></td>
<td><code>117</code></td>
<td><code>4f</code></td>
<td><code><b>O</b></code> </td>
<td> <code>111</code></td>
<td><code>157</code></td>
<td><code>6f</code></td>
<td><code><b>o</b></code>
</td></tr>
<tr>
<td> <code>16</code></td>
<td><code>20</code></td>
<td><code>10</code></td>
<td><code><b>DLE</b></code> (退出数据链) </td>
<td> <code>48</code></td>
<td><code>60</code></td>
<td><code>30</code></td>
<td><code><b>0</b></code> </td>
<td> <code>80</code></td>
<td><code>120</code></td>
<td><code>50</code></td>
<td><code><b>P</b></code> </td>
<td> <code>112</code></td>
<td><code>160</code></td>
<td><code>70</code></td>
<td><code><b>p</b></code>
</td></tr>
<tr>
<td> <code>17</code></td>
<td><code>21</code></td>
<td><code>11</code></td>
<td><code><b>DC1</b></code> (设备控制1) </td>
<td> <code>49</code></td>
<td><code>61</code></td>
<td><code>31</code></td>
<td><code><b>1</b></code> </td>
<td> <code>81</code></td>
<td><code>121</code></td>
<td><code>51</code></td>
<td><code><b>Q</b></code> </td>
<td> <code>113</code></td>
<td><code>161</code></td>
<td><code>71</code></td>
<td><code><b>q</b></code>
</td></tr>
<tr>
<td> <code>18</code></td>
<td><code>22</code></td>
<td><code>12</code></td>
<td><code><b>DC2</b></code> (设备控制2) </td>
<td> <code>50</code></td>
<td><code>62</code></td>
<td><code>32</code></td>
<td><code><b>2</b></code> </td>
<td> <code>82</code></td>
<td><code>122</code></td>
<td><code>52</code></td>
<td><code><b>R</b></code> </td>
<td> <code>114</code></td>
<td><code>162</code></td>
<td><code>72</code></td>
<td><code><b>r</b></code>
</td></tr>
<tr>
<td> <code>19</code></td>
<td><code>23</code></td>
<td><code>13</code></td>
<td><code><b>DC3</b></code> (设备控制3) </td>
<td> <code>51</code></td>
<td><code>63</code></td>
<td><code>33</code></td>
<td><code><b>3</b></code> </td>
<td> <code>83</code></td>
<td><code>123</code></td>
<td><code>53</code></td>
<td><code><b>S</b></code> </td>
<td> <code>115</code></td>
<td><code>163</code></td>
<td><code>73</code></td>
<td><code><b>s</b></code>
</td></tr>
<tr>
<td> <code>20</code></td>
<td><code>24</code></td>
<td><code>14</code></td>
<td><code><b>DC4</b></code> (设备控制4) </td>
<td> <code>52</code></td>
<td><code>64</code></td>
<td><code>34</code></td>
<td><code><b>4</b></code> </td>
<td> <code>84</code></td>
<td><code>124</code></td>
<td><code>54</code></td>
<td><code><b>T</b></code> </td>
<td> <code>116</code></td>
<td><code>164</code></td>
<td><code>74</code></td>
<td><code><b>t</b></code>
</td></tr>
<tr>
<td> <code>21</code></td>
<td><code>25</code></td>
<td><code>15</code></td>
<td><code><b>NAK</b></code> (反确认) </td>
<td> <code>53</code></td>
<td><code>65</code></td>
<td><code>35</code></td>
<td><code><b>5</b></code> </td>
<td> <code>85</code></td>
<td><code>125</code></td>
<td><code>55</code></td>
<td><code><b>U</b></code> </td>
<td> <code>117</code></td>
<td><code>165</code></td>
<td><code>75</code></td>
<td><code><b>u</b></code>
</td></tr>
<tr>
<td> <code>22</code></td>
<td><code>26</code></td>
<td><code>16</code></td>
<td><code><b>SYN</b></code> (同步空闲) </td>
<td> <code>54</code></td>
<td><code>66</code></td>
<td><code>36</code></td>
<td><code><b>6</b></code> </td>
<td> <code>86</code></td>
<td><code>126</code></td>
<td><code>56</code></td>
<td><code><b>V</b></code> </td>
<td> <code>118</code></td>
<td><code>166</code></td>
<td><code>76</code></td>
<td><code><b>v</b></code>
</td></tr>
<tr>
<td> <code>23</code></td>
<td><code>27</code></td>
<td><code>17</code></td>
<td><code><b>ETB</b></code> (传输块结束) </td>
<td> <code>55</code></td>
<td><code>67</code></td>
<td><code>37</code></td>
<td><code><b>7</b></code> </td>
<td> <code>87</code></td>
<td><code>127</code></td>
<td><code>57</code></td>
<td><code><b>W</b></code> </td>
<td> <code>119</code></td>
<td><code>167</code></td>
<td><code>77</code></td>
<td><code><b>w</b></code>
</td></tr>
<tr>
<td> <code>24</code></td>
<td><code>30</code></td>
<td><code>18</code></td>
<td><code><b>CAN</b></code> (取消) </td>
<td> <code>56</code></td>
<td><code>70</code></td>
<td><code>38</code></td>
<td><code><b>8</b></code> </td>
<td> <code>88</code></td>
<td><code>130</code></td>
<td><code>58</code></td>
<td><code><b>X</b></code> </td>
<td> <code>120</code></td>
<td><code>170</code></td>
<td><code>78</code></td>
<td><code><b>x</b></code>
</td></tr>
<tr>
<td> <code>25</code></td>
<td><code>31</code></td>
<td><code>19</code></td>
<td><code><b>EM</b></code> (媒介结束) </td>
<td> <code>57</code></td>
<td><code>71</code></td>
<td><code>39</code></td>
<td><code><b>9</b></code> </td>
<td> <code>89</code></td>
<td><code>131</code></td>
<td><code>59</code></td>
<td><code><b>Y</b></code> </td>
<td> <code>121</code></td>
<td><code>171</code></td>
<td><code>79</code></td>
<td><code><b>y</b></code>
</td></tr>
<tr>
<td> <code>26</code></td>
<td><code>32</code></td>
<td><code>1a</code></td>
<td><code><b>SUB</b></code> (替换) </td>
<td> <code>58</code></td>
<td><code>72</code></td>
<td><code>3a</code></td>
<td><code><b>:</b></code> </td>
<td> <code>90</code></td>
<td><code>132</code></td>
<td><code>5a</code></td>
<td><code><b>Z</b></code> </td>
<td> <code>122</code></td>
<td><code>172</code></td>
<td><code>7a</code></td>
<td><code><b>z</b></code>
</td></tr>
<tr>
<td> <code>27</code></td>
<td><code>33</code></td>
<td><code>1b</code></td>
<td><code><b>ESC</b></code> (退出) </td>
<td> <code>59</code></td>
<td><code>73</code></td>
<td><code>3b</code></td>
<td><code><b>;</b></code> </td>
<td> <code>91</code></td>
<td><code>133</code></td>
<td><code>5b</code></td>
<td><code><b>[</b></code> </td>
<td> <code>123</code></td>
<td><code>173</code></td>
<td><code>7b</code></td>
<td><code><b>&#123;</b></code>
</td></tr>
<tr>
<td> <code>28</code></td>
<td><code>34</code></td>
<td><code>1c</code></td>
<td><code><b>FS</b></code> (文件分隔符) </td>
<td> <code>60</code></td>
<td><code>74</code></td>
<td><code>3c</code></td>
<td><code><b>&lt;</b></code> </td>
<td> <code>92</code></td>
<td><code>134</code></td>
<td><code>5c</code></td>
<td><code><b>\ </b></code> </td>
<td> <code>124</code></td>
<td><code>174</code></td>
<td><code>7c</code></td>
<td><code><b>&#124;</b></code>
</td></tr>
<tr>
<td> <code>29</code></td>
<td><code>35</code></td>
<td><code>1d</code></td>
<td><code><b>GS</b></code> (组分隔符) </td>
<td> <code>61</code></td>
<td><code>75</code></td>
<td><code>3d</code></td>
<td><code><b>=</b></code> </td>
<td> <code>93</code></td>
<td><code>135</code></td>
<td><code>5d</code></td>
<td><code><b>]</b></code> </td>
<td> <code>125</code></td>
<td><code>175</code></td>
<td><code>7d</code></td>
<td><code><b>&#125;</b></code>
</td></tr>
<tr>
<td> <code>30</code></td>
<td><code>36</code></td>
<td><code>1e</code></td>
<td><code><b>RS</b></code> (记录分隔符) </td>
<td> <code>62</code></td>
<td><code>76</code></td>
<td><code>3e</code></td>
<td><code><b>&gt;</b></code> </td>
<td> <code>94</code></td>
<td><code>136</code></td>
<td><code>5e</code></td>
<td><code><b>^</b></code> </td>
<td> <code>126</code></td>
<td><code>176</code></td>
<td><code>7e</code></td>
<td><code><b>~</b></code>
</td></tr>
<tr>
<td> <code>31</code></td>
<td><code>37</code></td>
<td><code>1f</code></td>
<td><code><b>US</b></code> (单元分隔符) </td>
<td> <code>63</code></td>
<td><code>77</code></td>
<td><code>3f</code></td>
<td><code><b>?</b></code> </td>
<td> <code>95</code></td>
<td><code>137</code></td>
<td><code>5f</code></td>
<td><code><b>_</b></code> </td>
<td> <code>127</code></td>
<td><code>177</code></td>
<td><code>7f</code></td>
<td><code><b>DEL</b></code> (删除)
</td></tr></table>

<p>注意：在 Unicode 中， ASCII 字符块被称作 U+0000..U+007F 基础拉丁（ Basic Latin ）。</p>
<p>example:</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
int main()
&#123;
    std::cout &lt;&lt; &quot;Printable ASCII:\n&quot;;
    for (char i &#x3D; 32; i &lt; 127; ++i) &#123;
        std::cout &lt;&lt; i &lt;&lt; &#39; &#39;;
        if (i % 16 &#x3D;&#x3D; 15)
            std::cout &lt;&lt; &#39;\n&#39;;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>可能的输出：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Printable ASCII:
  <span class="token operator">!</span> " <span class="token comment"># $ % &amp; ' ( ) * + , - . / </span>
<span class="token number">0</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span> <span class="token number">5</span> <span class="token number">6</span> <span class="token number">7</span> <span class="token number">8</span> <span class="token number">9</span> <span class="token builtin class-name">:</span> <span class="token punctuation">;</span> <span class="token operator">&lt;</span> <span class="token operator">=</span> <span class="token operator">></span> ? 
@ A B C D E F G H I J K L M N O 
P Q R S T U V W X Y Z <span class="token punctuation">[</span> <span class="token punctuation">\</span> <span class="token punctuation">]</span> ^ _ 
` a b c d e f g h i j k l m n o 
p q r s t u <span class="token function">v</span> w x y z <span class="token punctuation">&#123;</span> <span class="token operator">|</span> <span class="token punctuation">&#125;</span> ~<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<div id = "8"></div>

<h1 id="常用的-C-内置函数"><a href="#常用的-C-内置函数" class="headerlink" title="常用的 C++ 内置函数"></a>常用的 C++ 内置函数</h1><h2 id="std-numeric-limits-infinity"><a href="#std-numeric-limits-infinity" class="headerlink" title="std::numeric_limits&lt;T&gt;::infinity"></a><code>std::numeric_limits&lt;T&gt;::infinity</code></h2><p>API 地址: <a href="https://en.cppreference.com/w/cpp/types/numeric_limits/infinity">https://en.cppreference.com/w/cpp/types/numeric_limits/infinity</a> .</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">static T infinity() throw();
(until C++11)
static constexpr T infinity() noexcept;
(since C++11)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>Returns the special value “positive infinity”, as represented by the floating-point type T. Only meaningful if <code>std::numeric_limits&lt;T&gt;::has_infinity</code> &#x3D;&#x3D; true. In IEEE 754, the most common binary representation of floating-point numbers, the positive infinity is the value with all bits of the exponent set and all bits of the fraction cleared.</p>
</blockquote>
<p><strong>Return value</strong></p>
<table class="t-dsc-begin">
<tr class="t-dsc-hitem">
<td>  <code>T</code>
</td>
<td>  <span class="t-c"><span class="mw-geshi cpp source-cpp"><a href="http://en.cppreference.com/w/cpp/types/numeric_limits"><span class="kw350">std::<span class="me2">numeric_limits</span></span></a><span class="sy1">&lt;</span>T<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">infinity</span><span class="br0">&#40;</span><span class="br0">&#41;</span></span></span>
</td></tr>
<tr class="t-dsc">
<td>  /* non-specialized */
</td>
<td>  <code>T()</code>
</td></tr>
<tr class="t-dsc">
<td>  <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="kw4">bool</span></span></span>
</td>
<td>  <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="kw2">false</span></span></span>
</td></tr>
<tr class="t-dsc">
<td>  <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="kw4">char</span></span></span>
</td>
<td>  <span class="t-c"><span class="mw-geshi cpp source-cpp">​<span class="nu0">0</span>​</span></span>
</td></tr>
<tr class="t-dsc">
<td>  <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="kw4">signed</span> <span class="kw4">char</span></span></span>
</td>
<td>  <span class="t-c"><span class="mw-geshi cpp source-cpp">​<span class="nu0">0</span>​</span></span>
</td></tr>
<tr class="t-dsc">
<td>  <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="kw4">unsigned</span> <span class="kw4">char</span></span></span>
</td>
<td>  <span class="t-c"><span class="mw-geshi cpp source-cpp">​<span class="nu0">0</span>​</span></span>
</td></tr>
<tr class="t-dsc">
<td>  <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="kw4">wchar_t</span></span></span>
</td>
<td>  <span class="t-c"><span class="mw-geshi cpp source-cpp">​<span class="nu0">0</span>​</span></span>
</td></tr>
<tr class="t-dsc">
<td>  <span class="t-c"><span class="mw-geshi cpp source-cpp">char8_t</span></span> <span class="t-mark-rev t-since-cxx20">(C++20)</span>
</td>
<td>  <span class="t-c"><span class="mw-geshi cpp source-cpp">​<span class="nu0">0</span>​</span></span>
</td></tr>
<tr class="t-dsc">
<td>  <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="kw4">char16_t</span></span></span> <span class="t-mark-rev t-since-cxx11">(C++11)</span>
</td>
<td>  <span class="t-c"><span class="mw-geshi cpp source-cpp">​<span class="nu0">0</span>​</span></span>
</td></tr>
<tr class="t-dsc">
<td>  <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="kw4">char32_t</span></span></span> <span class="t-mark-rev t-since-cxx11">(C++11)</span>
</td>
<td>  <span class="t-c"><span class="mw-geshi cpp source-cpp">​<span class="nu0">0</span>​</span></span>
</td></tr>
<tr class="t-dsc">
<td>  <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="kw4">short</span></span></span>
</td>
<td>  <span class="t-c"><span class="mw-geshi cpp source-cpp">​<span class="nu0">0</span>​</span></span>
</td></tr>
<tr class="t-dsc">
<td>  <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="kw4">unsigned</span> <span class="kw4">short</span></span></span>
</td>
<td>  <span class="t-c"><span class="mw-geshi cpp source-cpp">​<span class="nu0">0</span>​</span></span>
</td></tr>
<tr class="t-dsc">
<td>  <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="kw4">int</span></span></span>
</td>
<td>  <span class="t-c"><span class="mw-geshi cpp source-cpp">​<span class="nu0">0</span>​</span></span>
</td></tr>
<tr class="t-dsc">
<td>  <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="kw4">unsigned</span> <span class="kw4">int</span></span></span>
</td>
<td>  <span class="t-c"><span class="mw-geshi cpp source-cpp">​<span class="nu0">0</span>​</span></span>
</td></tr>
<tr class="t-dsc">
<td>  <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="kw4">long</span></span></span>
</td>
<td>  <span class="t-c"><span class="mw-geshi cpp source-cpp">​<span class="nu0">0</span>​</span></span>
</td></tr>
<tr class="t-dsc">
<td>  <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="kw4">unsigned</span> <span class="kw4">long</span></span></span>
</td>
<td>  <span class="t-c"><span class="mw-geshi cpp source-cpp">​<span class="nu0">0</span>​</span></span>
</td></tr>
<tr class="t-dsc">
<td>  <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="kw4">long</span> <span class="kw4">long</span></span></span> <span class="t-mark-rev t-since-cxx11">(C++11)</span>
</td>
<td>  <span class="t-c"><span class="mw-geshi cpp source-cpp">​<span class="nu0">0</span>​</span></span>
</td></tr>
<tr class="t-dsc">
<td>  <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="kw4">unsigned</span> <span class="kw4">long</span> <span class="kw4">long</span></span></span> <span class="t-mark-rev t-since-cxx11">(C++11)</span>
</td>
<td>  <span class="t-c"><span class="mw-geshi cpp source-cpp">​<span class="nu0">0</span>​</span></span>
</td></tr>
<tr class="t-dsc">
<td>  <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="kw4">float</span></span></span>
</td>
<td>  <span class="t-lc">HUGE_VALF</span>
</td></tr>
<tr class="t-dsc">
<td>  <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="kw4">double</span></span></span>
</td>
<td>  <span class="t-lc">HUGE_VAL</span>
</td></tr>
<tr class="t-dsc">
<td>  <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="kw4">long</span> <span class="kw4">double</span></span></span>
</td>
<td>  <span class="t-lc">HUGE_VALL</span>
</td></tr>
</table>

<p><strong>Example</strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
#include &lt;limits&gt;
int main()
&#123;
    double max &#x3D; std::numeric_limits&lt;double&gt;::max();
    double inf &#x3D; std::numeric_limits&lt;double&gt;::infinity();
 
    if(inf &gt; max)
        std::cout &lt;&lt; inf &lt;&lt; &quot; is greater than &quot; &lt;&lt; max &lt;&lt; &#39;\n&#39;;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>Output:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">inf is greater than <span class="token number">1</span>.79769e+308<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="std-is-same"><a href="#std-is-same" class="headerlink" title="std::is_same"></a><code>std::is_same</code></h2><p>API 地址: <a href="https://zh.cppreference.com/w/cpp/types/is_same">https://zh.cppreference.com/w/cpp/types/is_same</a> .</p>
<blockquote>
<p>在标头 <code>&lt;type_traits&gt;</code> 定义</p>
<p>(C++11 起)</p>
</blockquote>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template&lt; class T, class U &gt;
struct is_same;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<blockquote>
<p>若 <code>T</code> 与 <code>U</code> 指名同一类型（考虑 <code>const/volatile</code> 限定），则提供等于 <code>true</code> 的成员常量 <code>value</code> 。否则 <code>value</code> 为 <code>false</code> 。</p>
<p>满足交换律，即对于任何二个类型 <code>T</code> 与 <code>U</code> ， <code>is_same&lt;T, U&gt;::value == true</code> 当且仅当 <code>is_same&lt;U, T&gt;::value == true</code> 。</p>
<p>添加 <code>is_same</code> 或 <code>is_same_v</code> (C++17 起) 的特化的程序行为未定义。</p>
</blockquote>
<p><strong>辅助变量模板</strong></p>
<blockquote>
<p>(C++17 起)</p>
</blockquote>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template&lt; class T, class U &gt;
inline constexpr bool is_same_v &#x3D; is_same&lt;T, U&gt;::value;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<blockquote>
<p>继承自 <code>std::integral_constant</code></p>
</blockquote>
<p><strong>成员常量</strong></p>
<ul>
<li><code>value</code>[静态]: 若 <code>T</code> 与 <code>U</code> 是同一类型则为 <code>true</code> ，否则为 <code>false</code> (公开静态成员常量)</li>
</ul>
<p><strong>成员函数</strong></p>
<ul>
<li><p><code>operator bool</code>: 转换对象为 <code>bool</code> ，返回 <code>value</code> (公开成员函数)</p>
</li>
<li><p><code>operator()</code>: (C++14), 返回 <code>value</code> (公开成员函数)</p>
</li>
</ul>
<p><strong>成员类型</strong></p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">定义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">value_type</td>
<td align="center"><code>bool</code></td>
</tr>
<tr>
<td align="center">type</td>
<td align="center"><code>std::integral_constant&lt;bool, value&gt;</code></td>
</tr>
</tbody></table>
<p><strong>可能的实现</strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template&lt;class T, class U&gt;
struct is_same : std::false_type &#123;&#125;;
 
template&lt;class T&gt;
struct is_same&lt;T, T&gt; : std::true_type &#123;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>示例</strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
#include &lt;type_traits&gt;
#include &lt;cstdint&gt;
 
void print_separator()
&#123;
    std::cout &lt;&lt; &quot;-----\n&quot;;
&#125;
 
int main()
&#123;
    std::cout &lt;&lt; std::boolalpha;
 
    &#x2F;&#x2F; 一些实现定义状况
    std::cout &lt;&lt; std::is_same&lt;int, std::int32_t&gt;::value &lt;&lt; &#39;\n&#39;;
    &#x2F;&#x2F; 若 &#39;int&#39; 为 32 位则通常为 true
    std::cout &lt;&lt; std::is_same&lt;int, std::int64_t&gt;::value &lt;&lt; &#39;\n&#39;;
    &#x2F;&#x2F; 若使用 ILP64 数据模型则可能为 true
 
    print_separator();
 
    &#x2F;&#x2F; &#39;float&#39; 决非整数类型
    std::cout &lt;&lt; std::is_same&lt;float, std::int32_t&gt;::value &lt;&lt; &#39;\n&#39;; &#x2F;&#x2F; false
 
    print_separator();
 
    &#x2F;&#x2F; &#39;int&#39; 为隐式的 &#39;signed&#39;
    std::cout &lt;&lt; std::is_same&lt;int, int&gt;::value &lt;&lt; &quot;\n&quot;;          &#x2F;&#x2F; true
    std::cout &lt;&lt; std::is_same&lt;int, unsigned int&gt;::value &lt;&lt; &quot;\n&quot;; &#x2F;&#x2F; false
    std::cout &lt;&lt; std::is_same&lt;int, signed int&gt;::value &lt;&lt; &quot;\n&quot;;   &#x2F;&#x2F; true
 
    print_separator();
 
    &#x2F;&#x2F; 不同于其他类型， &#39;char&#39; 既非 &#39;unsigned&#39; 亦非 &#39;signed&#39;
    std::cout &lt;&lt; std::is_same&lt;char, char&gt;::value &lt;&lt; &quot;\n&quot;;          &#x2F;&#x2F; true
    std::cout &lt;&lt; std::is_same&lt;char, unsigned char&gt;::value &lt;&lt; &quot;\n&quot;; &#x2F;&#x2F; false
    std::cout &lt;&lt; std::is_same&lt;char, signed char&gt;::value &lt;&lt; &quot;\n&quot;;   &#x2F;&#x2F; false
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>输出：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token boolean">true</span>
<span class="token boolean">false</span>
-----
<span class="token boolean">false</span>
-----
<span class="token boolean">true</span>
<span class="token boolean">false</span>
<span class="token boolean">true</span>
-----
<span class="token boolean">true</span>
<span class="token boolean">false</span>
<span class="token boolean">false</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="std-tie"><a href="#std-tie" class="headerlink" title="std::tie"></a><code>std::tie</code></h2><p>API 地址: <a href="https://zh.cppreference.com/w/cpp/utility/tuple/tie">https://zh.cppreference.com/w/cpp/utility/tuple/tie</a> .</p>
<blockquote>
<p>在标头 <code>&lt;tuple&gt;</code> 定义</p>
</blockquote>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template&lt; class... Types &gt;
std::tuple&lt;Types&amp;...&gt; tie( Types&amp;... args ) noexcept;
(C++11 起)
(C++14 前)
template&lt; class... Types &gt;
constexpr std::tuple&lt;Types&amp;...&gt; tie( Types&amp;... args ) noexcept;
(C++14 起)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>创建到其参数或 <code>std::ignore</code> 实例的左值引用的 tuple 。</p>
<p><strong>参数</strong></p>
<ul>
<li><strong>args</strong>:	构造 tuple 所用的零或更多左值参数</li>
</ul>
<p><strong>返回值</strong></p>
<p>含左值引用的 <code>std::tuple</code> 对象。</p>
<p><strong>可能的实现</strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;typename... Args&gt;
constexpr &#x2F;&#x2F; C++14 起
std::tuple&lt;Args&amp;...&gt; tie(Args&amp;... args) noexcept &#123;
    return &#123;args...&#125;;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>注解</strong></p>
<p><code>std::tie</code> 可用于解包 <code>std::pair</code> ，因为 <code>std::tuple</code> 拥有从 <code>pair</code> 的转换赋值：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">bool result;
std::tie(std::ignore, result) &#x3D; set.insert(value);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p><strong>示例</strong></p>
<p><code>std::tie</code> 能用于引入字典序比较到结构体，或解包 <code>tuple</code> ：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;set&gt;
#include &lt;tuple&gt;
 
struct S &#123;
    int n;
    std::string s;
    float d;
    bool operator&lt;(const S&amp; rhs) const
    &#123;
        &#x2F;&#x2F; 比较 n 与 rhs.n,
        &#x2F;&#x2F; 然后为 s 与 rhs.s,
        &#x2F;&#x2F; 然后为 d 与 rhs.d
        return std::tie(n, s, d) &lt; std::tie(rhs.n, rhs.s, rhs.d);
    &#125;
&#125;;
 
int main()
&#123;
    std::set&lt;S&gt; set_of_s; &#x2F;&#x2F; S 为可比较小于 (LessThanComparable)
 
    S value&#123;42, &quot;Test&quot;, 3.14&#125;;
    std::set&lt;S&gt;::iterator iter;
    bool inserted;
 
    &#x2F;&#x2F; 解包 insert 的返回值为 iter 与 inserted
    std::tie(iter, inserted) &#x3D; set_of_s.insert(value);
 
    if (inserted)
        std::cout &lt;&lt; &quot;Value was inserted successfully\n&quot;;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>输出：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Value was inserted successfully<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="std-ignore"><a href="#std-ignore" class="headerlink" title="std::ignore"></a><code>std::ignore</code></h2><p>API 地址: <a href="https://zh.cppreference.com/w/cpp/utility/tuple/ignore">https://zh.cppreference.com/w/cpp/utility/tuple/ignore</a> .</p>
<blockquote>
<p>在标头 <code>&lt;tuple&gt;</code> 定义</p>
</blockquote>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">const &#x2F;*unspecified*&#x2F; ignore;
(C++11 起)
(C++17 前)
inline constexpr &#x2F;*unspecified*&#x2F; ignore;
(C++17 起)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>任何值均可赋给而无效果的未指定类型的对象。目的是令 <code>std::tie</code> 在解包 <code>std::tuple</code> 时作为不使用的参数的占位符使用。</p>
<p><strong>可能的实现</strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">namespace detail &#123;
struct ignore_t &#123;
    template &lt;typename T&gt;
    constexpr &#x2F;&#x2F; C++14 起要求
    void operator&#x3D;(T&amp;&amp;) const noexcept &#123;&#125;
&#125;;
&#125;
inline constexpr detail::ignore_t ignore; &#x2F;&#x2F; C++17 前仅 &#39;const&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>示例</strong></p>
<p>解包 <code>set.insert()</code> 所返回的 <code>pair</code> ，但只保存布尔值。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;set&gt;
#include &lt;tuple&gt;
 
int main()
&#123;
    std::set&lt;std::string&gt; set_of_str;
    bool inserted &#x3D; false;
    std::tie(std::ignore, inserted) &#x3D; set_of_str.insert(&quot;Test&quot;);
    if (inserted) &#123;
        std::cout &lt;&lt; &quot;Value was inserted successfully\n&quot;;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>输出：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Value was inserted successfully<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="std-remove-reference"><a href="#std-remove-reference" class="headerlink" title="std::remove_reference"></a><code>std::remove_reference</code></h2><p>API 地址: <a href="https://zh.cppreference.com/w/cpp/types/remove_reference">https://zh.cppreference.com/w/cpp/types/remove_reference</a> .</p>
<blockquote>
<p>在标头 <code>&lt;type_traits&gt;</code> 定义</p>
</blockquote>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template&lt; class T &gt;
struct remove_reference;
(C++11 起)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>若类型 <code>T</code> 为引用类型，则提供成员 <code>typedef type</code> ，其为 <code>T</code> 所引用的类型。否则 <code>type</code> 为 <code>T</code> 。</p>
<p>添加 <code>remove_reference</code> 的特化的程序行为未定义。</p>
<p><strong>成员类型</strong></p>
<table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">定义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">type</td>
<td align="center">T 所引用的类型，或若 T 不是引用则为 T</td>
</tr>
</tbody></table>
<p><strong>辅助类型</strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template&lt; class T &gt;
using remove_reference_t &#x3D; typename remove_reference&lt;T&gt;::type;
(C++14 起)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p><strong>可能的实现</strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template&lt; class T &gt; struct remove_reference      &#123;typedef T type;&#125;;
template&lt; class T &gt; struct remove_reference&lt;T&amp;&gt;  &#123;typedef T type;&#125;;
template&lt; class T &gt; struct remove_reference&lt;T&amp;&amp;&gt; &#123;typedef T type;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p><strong>示例</strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt; &#x2F;&#x2F; std::cout
#include &lt;type_traits&gt; &#x2F;&#x2F; std::is_same
 
template&lt;class T1, class T2&gt;
void print_is_same() &#123;
  std::cout &lt;&lt; std::is_same&lt;T1, T2&gt;() &lt;&lt; &#39;\n&#39;;
&#125;
 
int main() &#123;
  std::cout &lt;&lt; std::boolalpha;
 
  print_is_same&lt;int, int&gt;();
  print_is_same&lt;int, int &amp;&gt;();
  print_is_same&lt;int, int &amp;&amp;&gt;();
 
  print_is_same&lt;int, std::remove_reference&lt;int&gt;::type&gt;();
  print_is_same&lt;int, std::remove_reference&lt;int &amp;&gt;::type&gt;();
  print_is_same&lt;int, std::remove_reference&lt;int &amp;&amp;&gt;::type&gt;();
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>输出：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token boolean">true</span>
<span class="token boolean">false</span>
<span class="token boolean">false</span>
<span class="token boolean">true</span>
<span class="token boolean">true</span>
<span class="token boolean">true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="std-boolalpha-std-noboolalpha"><a href="#std-boolalpha-std-noboolalpha" class="headerlink" title="std::boolalpha, std::noboolalpha"></a><code>std::boolalpha</code>, <code>std::noboolalpha</code></h2><p>API 地址: <a href="https://zh.cppreference.com/w/cpp/io/manip/boolalpha">https://zh.cppreference.com/w/cpp/io/manip/boolalpha</a></p>
<blockquote>
<p>在标头 <code>&lt;ios&gt;</code> 定义</p>
</blockquote>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">std::ios_base&amp; boolalpha( std::ios_base&amp; str );
(1)	
std::ios_base&amp; noboolalpha( std::ios_base&amp; str );
(2)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<ol>
<li><p>启用流 <code>str</code> 中的 <code>boolalpha</code> 标志，如同通过调用 <code>str.setf(std::ios_base::boolalpha)</code> 。</p>
</li>
<li><p>禁用流 <code>str</code> 中的 <code>boolalpha</code> 标志，如同通过调用 <code>str.unsetf(std::ios_base::boolalpha)</code> 。</p>
</li>
</ol>
<p><code>std::boolalpha</code> 是 <code>I/O</code> 操纵符，故可用如 <code>out &lt;&lt; std::boolalpha</code> 的表达式对任何 <code>std::basic_ostream</code> 类型的 <code>out</code> ，或用如 <code>in &gt;&gt; std::boolalpha</code> 的表达式对任何 <code>std::basic_istream</code> 类型的 <code>in</code> 调用。</p>
<p><strong>参数</strong></p>
<p>str	-	到 I&#x2F;O 流的引用</p>
<p><strong>返回值</strong></p>
<p>str （到操纵后的流的引用）</p>
<p><strong>示例</strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;sstream&gt;
#include &lt;locale&gt;
#include &lt;iostream&gt;
int main()
&#123;
    &#x2F;&#x2F; boolalpha 输出
    std::cout &lt;&lt; std::boolalpha 
              &lt;&lt; &quot;boolalpha true: &quot; &lt;&lt; true &lt;&lt; &#39;\n&#39;
              &lt;&lt; &quot;boolalpha false: &quot; &lt;&lt; false &lt;&lt; &#39;\n&#39;;
    std::cout &lt;&lt; std::noboolalpha 
              &lt;&lt; &quot;noboolalpha true: &quot; &lt;&lt; true &lt;&lt; &#39;\n&#39;
              &lt;&lt; &quot;noboolalpha false: &quot; &lt;&lt; false &lt;&lt; &#39;\n&#39;;
    &#x2F;&#x2F; boolalpha 分析
    bool b1, b2;
    std::istringstream is(&quot;true false&quot;);
    is &gt;&gt; std::boolalpha &gt;&gt; b1 &gt;&gt; b2;
    std::cout &lt;&lt; &#39;\&quot;&#39; &lt;&lt; is.str() &lt;&lt; &quot;\&quot; parsed as &quot; &lt;&lt; b1 &lt;&lt; &#39; &#39; &lt;&lt; b2 &lt;&lt; &#39;\n&#39;;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>输出：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">boolalpha true: <span class="token boolean">true</span>
boolalpha false: <span class="token boolean">false</span>
noboolalpha true: <span class="token number">1</span>
noboolalpha false: <span class="token number">0</span>
<span class="token string">"true false"</span> parsed as <span class="token number">1</span> <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="std-make-tuple"><a href="#std-make-tuple" class="headerlink" title="std::make_tuple"></a><code>std::make_tuple</code></h2><p>API 地址: <a href="https://zh.cppreference.com/w/cpp/utility/tuple/make_tuple">https://zh.cppreference.com/w/cpp/utility/tuple/make_tuple</a></p>
<blockquote>
<p>在标头 <code>&lt;tuple&gt;</code> 定义</p>
</blockquote>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template&lt; class... Types &gt;
std::tuple&lt;VTypes...&gt; make_tuple( Types&amp;&amp;... args );
(C++11 起)
(C++14 起为 constexpr)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>创建 <code>tuple</code> 对象，从参数类型推导目标类型。</p>
<p>对于每个 <code>Types...</code> 中的 <code>Ti</code> ， <code>Vtypes...</code> 中的对应类型 <code>Vi</code> 为 <code>std::decay&lt;Ti&gt;::type</code> ，除非应用 <code>std::decay</code> 对某些类型 <code>X</code> 导致 <code>std::reference_wrapper&lt;X&gt;</code> ，该情况下推导的类型为 <code>X&amp;</code> 。</p>
<p><strong>参数</strong></p>
<p>args	-	构造 <code>tuple</code> 所用的零或更多参数</p>
<p><strong>返回值</strong></p>
<p>含给定值的 <code>std::tuple</code> 对象，如同用 <code>std::tuple&lt;VTypes...&gt;(std::forward&lt;Types&gt;(t)...).</code> 创建</p>
<p><strong>可能的实现</strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;class T&gt;
struct unwrap_refwrapper
&#123;
    using type &#x3D; T;
&#125;;
 
template &lt;class T&gt;
struct unwrap_refwrapper&lt;std::reference_wrapper&lt;T&gt;&gt;
&#123;
    using type &#x3D; T&amp;;
&#125;;
 
template &lt;class T&gt;
using unwrap_decay_t &#x3D; typename unwrap_refwrapper&lt;typename std::decay&lt;T&gt;::type&gt;::type;
&#x2F;&#x2F; 或使用 std::unwrap_ref_decay_t （ C++20 起）
 
template &lt;class... Types&gt;
constexpr &#x2F;&#x2F; since C++14
std::tuple&lt;unwrap_decay_t&lt;Types&gt;...&gt; make_tuple(Types&amp;&amp;... args)
&#123;
    return std::tuple&lt;unwrap_decay_t&lt;Types&gt;...&gt;(std::forward&lt;Types&gt;(args)...);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>示例</strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
#include &lt;tuple&gt;
#include &lt;functional&gt;
 
std::tuple&lt;int, int&gt; f() &#x2F;&#x2F; 此函数返回多值
&#123;
    int x &#x3D; 5;
    return std::make_tuple(x, 7); &#x2F;&#x2F; return &#123;x,7&#125;; 于 C++17
&#125;
 
int main()
&#123;
    &#x2F;&#x2F; 异类 tuple 构造
    int n &#x3D; 1;
    auto t &#x3D; std::make_tuple(10, &quot;Test&quot;, 3.14, std::ref(n), n);
    n &#x3D; 7;
    std::cout &lt;&lt; &quot;The value of t is &quot;  &lt;&lt; &quot;(&quot;
              &lt;&lt; std::get&lt;0&gt;(t) &lt;&lt; &quot;, &quot; &lt;&lt; std::get&lt;1&gt;(t) &lt;&lt; &quot;, &quot;
              &lt;&lt; std::get&lt;2&gt;(t) &lt;&lt; &quot;, &quot; &lt;&lt; std::get&lt;3&gt;(t) &lt;&lt; &quot;, &quot;
              &lt;&lt; std::get&lt;4&gt;(t) &lt;&lt; &quot;)\n&quot;;
 
    &#x2F;&#x2F; 返回多值的函数
    int a, b;
    std::tie(a, b) &#x3D; f();
    std::cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; &quot;\n&quot;;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>输出：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">The value of t is <span class="token punctuation">(</span><span class="token number">10</span>, Test, <span class="token number">3.14</span>, <span class="token number">7</span>, <span class="token number">1</span><span class="token punctuation">)</span>
<span class="token number">5</span> <span class="token number">7</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h2 id="std-tuple-size"><a href="#std-tuple-size" class="headerlink" title="std::tuple_size&lt;std::tuple&gt;"></a><code>std::tuple_size&lt;std::tuple&gt;</code></h2><p>API 地址: <a href="https://zh.cppreference.com/w/cpp/utility/tuple/tuple_size">https://zh.cppreference.com/w/cpp/utility/tuple/tuple_size</a></p>
<blockquote>
<p>在标头 <code>&lt;tuple&gt;</code> 定义</p>
</blockquote>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template&lt; class... Types &gt;
struct tuple_size&lt; std::tuple&lt;Types...&gt; &gt;
    : std::integral_constant&lt;std::size_t, sizeof...(Types)&gt; &#123; &#125;;
(C++11 起)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>提供对 <code>tuple</code> 中元素数量的访问，作为编译时常量表达式。</p>
<blockquote>
<p>继承自 <code>std::integral_constant</code></p>
</blockquote>
<p><strong>成员常量</strong></p>
<ul>
<li><code>value</code>[静态]: sizeof…(Types) (公开静态成员常量)</li>
</ul>
<p><strong>成员函数</strong></p>
<ul>
<li><p><code>operator std::size_t</code>: 转换对象为 <code>std::size_t</code> ，返回 <code>value</code> (公开成员函数)</p>
</li>
<li><p><code>operator()</code>: (C++14), 返回 value (公开成员函数)</p>
</li>
</ul>
<p><strong>成员类型</strong></p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">定义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">value_type</td>
<td align="center"><code>std::size_t</code></td>
</tr>
<tr>
<td align="center">type</td>
<td align="center"><code>std::integral_constant&lt;std::size_t, value&gt;</code></td>
</tr>
</tbody></table>
<p><strong>示例</strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
#include &lt;tuple&gt;
 
template &lt;class T&gt;
void test(T value)
&#123;
    int a[std::tuple_size_v&lt;T&gt;]; &#x2F;&#x2F; 能用于编译时
 
    std::cout &lt;&lt; std::tuple_size&lt;T&gt;&#123;&#125; &lt;&lt; &#39; &#39; &#x2F;&#x2F; 或运行时
              &lt;&lt; sizeof a &lt;&lt; &#39; &#39; 
              &lt;&lt; sizeof value &lt;&lt; &#39;\n&#39;;
&#125;
 
int main()
&#123;
    test(std::make_tuple(1, 2, 3.14));
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>可能的输出：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">3</span> <span class="token number">12</span> <span class="token number">16</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="std-accumulate"><a href="#std-accumulate" class="headerlink" title="std::accumulate"></a><code>std::accumulate</code></h2><p>API 地址: <a href="https://zh.cppreference.com/w/cpp/algorithm/accumulate">https://zh.cppreference.com/w/cpp/algorithm/accumulate</a> .</p>
<blockquote>
<p>在标头 <code>&lt;numeric&gt;</code> 定义</p>
</blockquote>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">(1)
template&lt; class InputIt, class T &gt;
T accumulate( InputIt first, InputIt last, T init );
(C++20 前)
template&lt; class InputIt, class T &gt;
constexpr T accumulate( InputIt first, InputIt last, T init );
(C++20 起)
(2)	
template&lt; class InputIt, class T, class BinaryOperation &gt;
T accumulate( InputIt first, InputIt last, T init,
              BinaryOperation op );
(C++20 前)
template&lt; class InputIt, class T, class BinaryOperation &gt;
constexpr T accumulate( InputIt first, InputIt last, T init,
                        BinaryOperation op );
(C++20 起)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>计算给定值 <code>init</code> 与给定范围 <code>[first, last)</code> 中元素的和。</p>
<ol>
<li>以初始值 <code>init</code> 初始化（具有 T 类型的）累加器 <code>acc</code>，然后按顺序对范围 <code>[first, last)</code> 的每个迭代器 <code>i</code> 通过 <code>acc = acc + *i</code> (C++11 前)<code>acc = std::move(acc) + *i</code> (C++11 起) 进行累加。</li>
<li>以初始值 <code>init</code> 初始化（具有 T 类型的）累加器 <code>acc</code>，然后按顺序对范围 <code>[first, last)</code> 的每个迭代器 <code>i</code> 通过 <code>acc = op(acc, *i)</code> (C++11 前)<code>acc = op(std::move(acc), *i)</code> (C++11 起) 进行累加。<br>如果 <code>op</code> 使涉及范围的任何迭代器（包含尾迭代器）失效，或修改了该范围内的任何元素，那么行为未定义。</li>
</ol>
</blockquote>
<p><strong>参数</strong></p>
<ul>
<li><p><code>first, last</code>	-	要求和的元素范围</p>
</li>
<li><p><code>init</code>	-	和的初值</p>
</li>
<li><p><code>op</code>	-	被使用的二元函数对象。该函数的签名应当等价于：<code>Ret fun(const Type1 &amp;a, const Type2 &amp;b);</code> 签名中并不需要有 <code>const &amp;</code>。类型 <code>Type1</code> 必须使得 <code>T</code> 类型的对象能隐式转换到 <code>Type1</code>。类型 <code>Type2</code> 必须使得 <code>InputIt</code> 类型的对象能在解引用后隐式转换到 <code>Type2</code>。 类型 <code>Ret</code> 必须使得 <code>T</code> 类型对象能被赋 <code>Ret</code> 类型值。</p>
</li>
</ul>
<blockquote>
<p><strong>类型要求</strong></p>
<ul>
<li><p>InputIt 必须符合老式输入迭代器 (LegacyInputIterator) 的要求。</p>
</li>
<li><p>T 必须符合可复制赋值 (CopyAssignable) 和 可复制构造 (CopyConstructible) 的要求。</p>
</li>
</ul>
</blockquote>
<p><strong>返回值</strong></p>
<p>累加后的 <code>acc</code>。</p>
<p><strong>注解</strong></p>
<p><code>std::accumulate</code> 进行左折叠。为进行右折叠，必须逆转二元运算符的参数顺序，并使用逆序迭代器。</p>
<p><strong>最常见的错误</strong></p>
<p>在 <code>init</code> 的类型上进行 <code>op</code>，这能引入不期望的元素转换，例如 <code>std::accumulate(v.begin(), v.end(), 0)</code> 在 <code>v</code> 是 <code>std::vector&lt;double&gt;</code> 时会给出错误的结果。</p>
<p><strong>可能的实现</strong></p>
<p>版本一</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template&lt;class InputIt, class T&gt;
constexpr &#x2F;&#x2F; C++20 起
T accumulate(InputIt first, InputIt last, T init)
&#123;
    for (; first !&#x3D; last; ++first)
        init &#x3D; std::move(init) + *first; &#x2F;&#x2F; C++11 起有 std::move
 
    return init;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>版本二</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template&lt;class InputIt, class T, class BinaryOperation&gt;
constexpr &#x2F;&#x2F; C++20 起
T accumulate(InputIt first, InputIt last, T init, BinaryOperation op)
&#123;
    for (; first !&#x3D; last; ++first)
        init &#x3D; op(std::move(init), *first); &#x2F;&#x2F; C++11 起有 std::move
 
    return init;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>示例</strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;numeric&gt;
#include &lt;string&gt;
#include &lt;functional&gt;
 
int main()
&#123;
    std::vector&lt;int&gt; v&#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10&#125;;
 
    int sum &#x3D; std::accumulate(v.begin(), v.end(), 0);
    int product &#x3D; std::accumulate(v.begin(), v.end(), 1, std::multiplies&lt;int&gt;());
 
    auto dash_fold &#x3D; [](std::string a, int b)
    &#123;
        return std::move(a) + &#39;-&#39; + std::to_string(b);
    &#125;;
 
    std::string s &#x3D; std::accumulate(std::next(v.begin()), v.end(),
                                    std::to_string(v[0]), &#x2F;&#x2F; 用首元素开始
                                    dash_fold);
 
    &#x2F;&#x2F; 使用逆向迭代器右折叠
    std::string rs &#x3D; std::accumulate(std::next(v.rbegin()), v.rend(),
                                     std::to_string(v.back()), &#x2F;&#x2F; 用末元素开始
                                     dash_fold);
 
    std::cout &lt;&lt; &quot;和：&quot; &lt;&lt; sum &lt;&lt; &#39;\n&#39;
              &lt;&lt; &quot;积：&quot; &lt;&lt; product &lt;&lt; &#39;\n&#39;
              &lt;&lt; &quot;以短横线分隔的字符串：&quot; &lt;&lt; s &lt;&lt; &#39;\n&#39;
              &lt;&lt; &quot;以短横线分隔的字符串（右折叠）：&quot; &lt;&lt; rs &lt;&lt; &#39;\n&#39;;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>输出：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">和：55
积：3628800
以短横线分隔的字符串：1-2-3-4-5-6-7-8-9-10
以短横线分隔的字符串（右折叠）：10-9-8-7-6-5-4-3-2-1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="std-distance"><a href="#std-distance" class="headerlink" title="std::distance"></a><code>std::distance</code></h2><p>API 地址: <a href="https://zh.cppreference.com/w/cpp/iterator/distance">https://zh.cppreference.com/w/cpp/iterator/distance</a> .</p>
<blockquote>
<p>在标头 <code>&lt;iterator&gt;</code> 定义</p>
</blockquote>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template&lt; class InputIt &gt;
typename std::iterator_traits&lt;InputIt&gt;::difference_type
    distance( InputIt first, InputIt last );
(C++17 起为 constexpr)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>返回从 first 到 last 的路程。</p>
<p>若 last 不可从 first 通过（可以重复）自增 first 抵达，则行为未定义。</p>
<p>(C++11 前)</p>
<p>若 InputIt 不是老式随机访问迭代器 (LegacyRandomAccessIterator) ，则若 last 不可从 first 通过（可以重复）自增 first 抵达，则行为未定义。 若 InputIt 是老式随机访问迭代器 (LegacyRandomAccessIterator) ，则若 last 不可从 first 抵达且 first 不可从 last 抵达，则行为未定义。</p>
<p>(C++11 起)</p>
</blockquote>
<p><strong>参数</strong></p>
<ul>
<li><p>first	-	指向首元素的迭代器</p>
</li>
<li><p>last	-	指向范围尾的迭代器</p>
</li>
</ul>
<blockquote>
<p><strong>类型要求</strong></p>
<ul>
<li>InputIt 必须符合老式输入迭代器 (LegacyInputIterator) 的要求。若 InputIt 额外满足老式随机访问迭代器 (LegacyRandomAccessIterator) 的要求则操作更高效</li>
</ul>
</blockquote>
<p><strong>返回值</strong></p>
<p>从 first 走到 last 所需的自增数。若使用随机访问迭代器且 first 可从 last 抵达，则值可能为负。 (C++11 起)</p>
<p><strong>复杂度</strong></p>
<p>线性。</p>
<p>然而，若 InputIt 额外满足老式随机访问迭代器 (LegacyRandomAccessIterator) 的要求，则复杂度是常数。</p>
<p><strong>可能的实现</strong></p>
<blockquote>
<p>参阅 libstdc++ 与 libc++ 中的实现。</p>
</blockquote>
<p>版本一</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; 经由标签派发的实现，移除 constexpr 后可用于 C++98
namespace detail &#123;
 
template&lt;class It&gt;
constexpr &#x2F;&#x2F; C++17 起要求
typename std::iterator_traits&lt;It&gt;::difference_type 
    do_distance(It first, It last, std::input_iterator_tag)
&#123;
    typename std::iterator_traits&lt;It&gt;::difference_type result &#x3D; 0;
    while (first !&#x3D; last) &#123;
        ++first;
        ++result;
    &#125;
    return result;
&#125;
 
template&lt;class It&gt;
constexpr &#x2F;&#x2F; C++17 起要求
typename std::iterator_traits&lt;It&gt;::difference_type 
    do_distance(It first, It last, std::random_access_iterator_tag)
&#123;
    return last - first;
&#125;
 
&#125; &#x2F;&#x2F; namespace detail
 
template&lt;class It&gt;
constexpr &#x2F;&#x2F; C++17 起
typename std::iterator_traits&lt;It&gt;::difference_type 
    distance(It first, It last)
&#123;
    return detail::do_distance(first, last,
                               typename std::iterator_traits&lt;It&gt;::iterator_category());
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>版本二</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; 经由 constexpr if 的实现，可用于 C++17
template&lt;class It&gt;
constexpr typename std::iterator_traits&lt;It&gt;::difference_type
    distance(It first, It last)
&#123;
    using category &#x3D; typename std::iterator_traits&lt;It&gt;::iterator_category;
    static_assert(std::is_base_of_v&lt;std::input_iterator_tag, category&gt;);
 
    if constexpr (std::is_base_of_v&lt;std::random_access_iterator_tag, category&gt;)
        return last - first;
    else &#123;
        typename std::iterator_traits&lt;It&gt;::difference_type result &#x3D; 0;
        while (first !&#x3D; last) &#123;
            ++first;
            ++result;
        &#125;
        return result;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>示例</strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;vector&gt;
 
int main() 
&#123;
    std::vector&lt;int&gt; v&#123; 3, 1, 4 &#125;;
    std::cout &lt;&lt; &quot;distance(first, last) &#x3D; &quot;
              &lt;&lt; std::distance(v.begin(), v.end()) &lt;&lt; &#39;\n&#39;
              &lt;&lt; &quot;distance(last, first) &#x3D; &quot;
              &lt;&lt; std::distance(v.end(), v.begin()) &lt;&lt; &#39;\n&#39;;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>输出：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">distance<span class="token punctuation">(</span>first, last<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">3</span>
distance<span class="token punctuation">(</span>last, first<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token parameter variable">-3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h2 id="std-exception-what"><a href="#std-exception-what" class="headerlink" title="std::exception::what"></a><code>std::exception::what</code></h2><p>API 地址: <a href="https://zh.cppreference.com/w/cpp/error/exception/what">https://zh.cppreference.com/w/cpp/error/exception/what</a> .</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">virtual const char* what() const throw();
(C++11 前)
virtual const char* what() const noexcept;
(C++11 起)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>返回解释性字符串。</p>
</blockquote>
<p><strong>参数</strong></p>
<p>（无）</p>
<p><strong>返回值</strong></p>
<p>指向拥有解释信息的空终止字符串的指针。该指针保证在获取它的异常对象被销毁前，或在调用该异常对象的非静态成员函数前合法。</p>
<h2 id="std-advance"><a href="#std-advance" class="headerlink" title="std::advance"></a><code>std::advance</code></h2><p>API 地址: <a href="https://zh.cppreference.com/w/cpp/iterator/advance">https://zh.cppreference.com/w/cpp/iterator/advance</a> .</p>
<blockquote>
<p>在标头 <code>&lt;iterator&gt;</code> 定义</p>
</blockquote>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template&lt; class InputIt, class Distance &gt;
void advance( InputIt&amp; it, Distance n );
(C++17 前)
template&lt; class InputIt, class Distance &gt;
constexpr void advance( InputIt&amp; it, Distance n );
(C++17 起)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>增加给定的迭代器 it 以 n 个元素的步长。</p>
<p>如果 n 为负，那么迭代器会自减。此时 InputIt 必须满足老式双向迭代器 (LegacyBidirectionalIterator) 的要求，否则行为未定义。</p>
</blockquote>
<p><strong>参数</strong></p>
<p>it	-	要前进的迭代器</p>
<p>n	-	it 要前进的元素数</p>
<blockquote>
<p><strong>类型要求</strong></p>
<ul>
<li>InputIt 必须符合老式输入迭代器 (LegacyInputIterator) 的要求。</li>
</ul>
</blockquote>
<p><strong>返回值</strong></p>
<p>（无）</p>
<p><strong>复杂度</strong></p>
<p>线性。</p>
<p>然而，如果 InputIt 额外满足老式随机访问迭代器 (LegacyRandomAccessIterator) 的要求，那么复杂度是常数。</p>
<p><strong>注解</strong></p>
<p>如果指定的自增或自减序列要求一个不可自增迭代器（例如尾后迭代器）自增，或不可自减迭代器（例如首迭代器或持有奇异值的迭代器）自减，那么行为未定义。</p>
<p><strong>可能的实现</strong></p>
<blockquote>
<p>参阅 libstdc++ 与 libc++ 中的实现。</p>
</blockquote>
<p>非 constexpr 版本</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">namespace detail
&#123;
    template&lt;class It&gt;
    void do_advance(It&amp; it, typename std::iterator_traits&lt;It&gt;::difference_type n,
                    std::input_iterator_tag)
    &#123;
        while (n &gt; 0)
        &#123;
            --n;
            ++it;
        &#125;
    &#125;
 
    template&lt;class It&gt;
    void do_advance(It&amp; it, typename std::iterator_traits&lt;It&gt;::difference_type n,
                    std::bidirectional_iterator_tag)
    &#123;
        while (n &gt; 0)
        &#123;
            --n;
            ++it;
        &#125;
        while (n &lt; 0)
        &#123;
            ++n;
            --it;
        &#125;
    &#125;
 
    template&lt;class It&gt;
    void do_advance(It&amp; it, typename std::iterator_traits&lt;It&gt;::difference_type n,
                    std::random_access_iterator_tag)
    &#123;
        it +&#x3D; n;
    &#125;
&#125; &#x2F;&#x2F; namespace detail
 
template&lt;class It, class Distance&gt;
void advance(It&amp; it, Distance n)
&#123;
    detail::do_advance(it, typename std::iterator_traits&lt;It&gt;::difference_type(n),
                       typename std::iterator_traits&lt;It&gt;::iterator_category());
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>constexpr 版本</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template&lt;class It, class Distance&gt;
constexpr void advance(It&amp; it, Distance n)
&#123;
    using category &#x3D; typename std::iterator_traits&lt;It&gt;::iterator_category;
    static_assert(std::is_base_of_v&lt;std::input_iterator_tag, category&gt;);
 
    auto dist &#x3D; typename std::iterator_traits&lt;It&gt;::difference_type(n);
    if constexpr (std::is_base_of_v&lt;std::random_access_iterator_tag, category&gt;)
        it +&#x3D; dist;
    else
    &#123;
        while (dist &gt; 0)
        &#123;
            --dist;
            ++it;
        &#125;
        if constexpr (std::is_base_of_v&lt;std::bidirectional_iterator_tag, category&gt;)
        &#123;
            while (dist &lt; 0)
            &#123;
                ++dist;
                --it;
            &#125;
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>示例</strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;vector&gt;
 
int main() 
&#123;
    std::vector&lt;int&gt; v&#123;3, 1, 4&#125;;
 
    auto vi &#x3D; v.begin();
    std::advance(vi, 2);
    std::cout &lt;&lt; *vi &lt;&lt; &#39; &#39;;
 
    vi &#x3D; v.end();
    std::advance(vi, -2);
    std::cout &lt;&lt; *vi &lt;&lt; &#39;\n&#39;;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>输出：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">4</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="std-next"><a href="#std-next" class="headerlink" title="std::next"></a><code>std::next</code></h2><p>API 地址: <a href="https://zh.cppreference.com/w/cpp/iterator/next">https://zh.cppreference.com/w/cpp/iterator/next</a> .</p>
<blockquote>
<p>在标头 <code>&lt;iterator&gt;</code> 定义</p>
</blockquote>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template&lt; class InputIt &gt;
InputIt next(
  InputIt it,
  typename std::iterator_traits&lt;InputIt&gt;::difference_type n &#x3D; 1 );
(C++11 起)
(C++17 前)
template&lt; class InputIt &gt;
constexpr InputIt next(
  InputIt it,
  typename std::iterator_traits&lt;InputIt&gt;::difference_type n &#x3D; 1 );
(C++17 起)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>返回迭代器 it 的第 n 个后继。</p>
</blockquote>
<p><strong>参数</strong></p>
<p>it	-	迭代器</p>
<p>n	-	要前进的元素数</p>
<p><strong>类型要求</strong></p>
<ul>
<li>InputIt 必须符合老式输入迭代器 (LegacyInputIterator) 的要求。</li>
</ul>
<p><strong>返回值</strong></p>
<p>迭代器 it 的第 n 个后继。</p>
<p><strong>复杂度</strong></p>
<p>线性。</p>
<p>然而，若 InputIt 还满足老式随机访问迭代器 (LegacyRandomAccessIterator) 的要求，则复杂度为常数。</p>
<p><strong>可能的实现</strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template&lt;class InputIt&gt;
constexpr &#x2F;&#x2F; C++17 起
InputIt next(InputIt it,
             typename std::iterator_traits&lt;Input&gt;::difference_type n &#x3D; 1)
&#123;
    std::advance(it, n);
    return it;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>注解</strong></p>
<p>尽管表达式 ++c.begin() 通常能编译，然而不保证会这么做： c.begin() 是右值表达式，而无老式输入迭代器 (LegacyInputIterator) 要求指定右值的自增保证进行。尤其是迭代器以指针实现或其 operator++ 为左值引用限定时， ++c.begin() 不能编译，而 std::next(c.begin()) 可以。</p>
<p><strong>示例</strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;vector&gt;
 
int main() 
&#123;
    std::vector&lt;int&gt; v&#123; 3, 1, 4 &#125;;
 
    auto it &#x3D; v.begin();
 
    auto nx &#x3D; std::next(it, 2);
 
    std::cout &lt;&lt; *it &lt;&lt; &#39; &#39; &lt;&lt; *nx &lt;&lt; &#39;\n&#39;;
 
    &#x2F;&#x2F; 注意 std::next 在循环中的表现
    size_t loop &#x3D; 0;
 
    while ((std::next(it)) !&#x3D; v.end())
    &#123;
        if(++loop &gt; 5)
            break;
    &#125;
 
    std::cout &lt;&lt; &quot;loop &#x3D; &quot; &lt;&lt; loop &lt;&lt; &#39;\n&#39;;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>输出：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">3</span> <span class="token number">4</span>
loop <span class="token operator">=</span> <span class="token number">6</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h2 id="std-multiplies"><a href="#std-multiplies" class="headerlink" title="std::multiplies"></a><code>std::multiplies</code></h2><p>API 地址: <a href="https://zh.cppreference.com/w/cpp/utility/functional/multiplies">https://zh.cppreference.com/w/cpp/utility/functional/multiplies</a> .</p>
<blockquote>
<p>在标头 <code>&lt;functional&gt;</code> 定义</p>
</blockquote>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template&lt; class T &gt;
struct multiplies;
(C++14 前)
template&lt; class T &#x3D; void &gt;
struct multiplies;
(C++14 起)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>进行乘法的函数对象。等效地在二个 T 类型实例上调用 operator* 。</p>
</blockquote>
<p><strong>特化</strong></p>
<p>标准库提供 std::multiplies 在不指定 T 时的特化，这使得参数类型和返回类型留待推导。</p>
<p><code>multiplies&lt;void&gt;</code> (C++14)</p>
<p>实现 x * y 并推导参数和返回类型的函数对象(类模板特化)(C++14 起)</p>
<p><strong>成员类型</strong></p>
<table class="t-dsc-begin">

<tr class="t-dsc-hitem">
<td>  类型
</td>
<td>  定义
</td></tr>


<tr class="t-dsc">
<td>  <code>result_type</code> <span class="t-mark-rev t-deprecated-cxx17">(C++17 中弃用)</span><span class="t-mark-rev t-until-cxx20">(C++20 中移除)</span>
</td>
<td>  <code>T</code>
</td></tr>


<tr class="t-dsc">
<td>  <code>first_argument_type</code> <span class="t-mark-rev t-deprecated-cxx17">(C++17 中弃用)</span><span class="t-mark-rev t-until-cxx20">(C++20 中移除)</span>
</td>
<td>  <code>T</code>
</td></tr>


<tr class="t-dsc">
<td>  <code>second_argument_type</code> <span class="t-mark-rev t-deprecated-cxx17">(C++17 中弃用)</span><span class="t-mark-rev t-until-cxx20">(C++20 中移除)</span>
</td>
<td>  <code>T</code>
</td></tr>
</table>

<p>这些成员类型由公开继承 std::binary_function&lt;T, T, T&gt; 获得。(C++11 前)</p>
<p><strong>成员函数</strong></p>
<p>operator() 返回二个参数的积(公开成员函数)</p>
<p><code>std::multiplies::operator()</code></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">T operator()( const T&amp; lhs, const T&amp; rhs ) const;
(C++14 前)
constexpr T operator()( const T&amp; lhs, const T&amp; rhs ) const;
(C++14 起)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>返回 lhs 与 rhs 的积。</p>
<p><strong>参数</strong></p>
<p>lhs, rhs	-	要相乘的值</p>
<p><strong>返回值</strong></p>
<p>lhs * rhs 的结果。</p>
<p><strong>异常</strong></p>
<p>可能抛出实现定义的异常。</p>
<p><strong>可能的实现</strong></p>
</blockquote>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">constexpr T operator()(const T &amp;lhs, const T &amp;rhs) const 
&#123;
    return lhs * rhs;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="std-find-std-find-if-std-find-if-not"><a href="#std-find-std-find-if-std-find-if-not" class="headerlink" title="std::find, std::find_if, std::find_if_not"></a><code>std::find, std::find_if, std::find_if_not</code></h2><p>API 地址: <a href="https://zh.cppreference.com/w/cpp/algorithm/find">https://zh.cppreference.com/w/cpp/algorithm/find</a> .</p>
<table class="t-dcl-begin"><tbody>
<tr class="t-dsc-header">
<td> <div>在标头 <code><a href="/w/cpp/header/algorithm" title="cpp/header/algorithm">&lt;algorithm&gt;</a></code> 定义
 </div></td>
<td></td>
<td></td>
</tr>
</tbody>
<tbody class="t-dcl-rev t-dcl-rev-num"><tr class="t-dcl-rev-aux">
<td></td>
<td rowspan="142">(1)</td>
<td></td>
</tr>
<tr class="t-dcl t-until-cxx20">
<td> <div><span class="mw-geshi cpp source-cpp"><span class="kw1">template</span><span class="sy1">&lt;</span> <span class="kw1">class</span> InputIt, <span class="kw1">class</span> T <span class="sy1">&gt;</span><br />
InputIt find<span class="br0">&#40;</span> InputIt first, InputIt last, <span class="kw4">const</span> T<span class="sy3">&amp;</span> value <span class="br0">&#41;</span><span class="sy4">;</span></span></div></td>
<td class="t-dcl-nopad">  </td>
<td> <span class="t-mark-rev t-until-cxx20">(C++20 前)</span> </td>
</tr>
<tr class="t-dcl t-since-cxx20">
<td> <div><span class="mw-geshi cpp source-cpp"><span class="kw1">template</span><span class="sy1">&lt;</span> <span class="kw1">class</span> InputIt, <span class="kw1">class</span> T <span class="sy1">&gt;</span><br />
<span class="kw4">constexpr</span> InputIt find<span class="br0">&#40;</span> InputIt first, InputIt last, <span class="kw4">const</span> T<span class="sy3">&amp;</span> value <span class="br0">&#41;</span><span class="sy4">;</span></span></div></td>
<td class="t-dcl-nopad">  </td>
<td> <span class="t-mark-rev t-since-cxx20">(C++20 起)</span> </td>
</tr>
</tbody><tbody>
<tr class="t-dcl t-since-cxx17">
<td> <div><span class="mw-geshi cpp source-cpp"><span class="kw1">template</span><span class="sy1">&lt;</span> <span class="kw1">class</span> ExecutionPolicy, <span class="kw1">class</span> ForwardIt, <span class="kw1">class</span> T <span class="sy1">&gt;</span><br />
<p>ForwardIt find<span class="br0">&#40;</span> ExecutionPolicy<span class="sy3">&amp;&amp;</span> policy,<br />
</p>
&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; ForwardIt first, ForwardIt last, <span class="kw4">const</span> T<span class="sy3">&amp;</span> value <span class="br0">&#41;</span><span class="sy4">;</span></span></div></td>
<td> (2) </td>
<td> <span class="t-mark-rev t-since-cxx17">(C++17 起)</span> </td>
</tr>
</tbody>
<tbody class="t-dcl-rev t-dcl-rev-num"><tr class="t-dcl-rev-aux">
<td></td>
<td rowspan="142">(3)</td>
<td></td>
</tr>
<tr class="t-dcl t-until-cxx20">
<td> <div><span class="mw-geshi cpp source-cpp"><span class="kw1">template</span><span class="sy1">&lt;</span> <span class="kw1">class</span> InputIt, <span class="kw1">class</span> UnaryPredicate <span class="sy1">&gt;</span><br />
InputIt find_if<span class="br0">&#40;</span> InputIt first, InputIt last, UnaryPredicate p <span class="br0">&#41;</span><span class="sy4">;</span></span></div></td>
<td class="t-dcl-nopad">  </td>
<td> <span class="t-mark-rev t-until-cxx20">(C++20 前)</span> </td>
</tr>
<tr class="t-dcl t-since-cxx20">
<td> <div><span class="mw-geshi cpp source-cpp"><span class="kw1">template</span><span class="sy1">&lt;</span> <span class="kw1">class</span> InputIt, <span class="kw1">class</span> UnaryPredicate <span class="sy1">&gt;</span><br />
<span class="kw4">constexpr</span> InputIt find_if<span class="br0">&#40;</span> InputIt first, InputIt last, UnaryPredicate p <span class="br0">&#41;</span><span class="sy4">;</span></span></div></td>
<td class="t-dcl-nopad">  </td>
<td> <span class="t-mark-rev t-since-cxx20">(C++20 起)</span> </td>
</tr>
</tbody><tbody>
<tr class="t-dcl t-since-cxx17">
<td> <div><span class="mw-geshi cpp source-cpp"><span class="kw1">template</span><span class="sy1">&lt;</span> <span class="kw1">class</span> ExecutionPolicy, <span class="kw1">class</span> ForwardIt, <span class="kw1">class</span> UnaryPredicate <span class="sy1">&gt;</span><br />
<p>ForwardIt find_if<span class="br0">&#40;</span> ExecutionPolicy<span class="sy3">&amp;&amp;</span> policy,<br />
</p>
&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;ForwardIt first, ForwardIt last, UnaryPredicate p <span class="br0">&#41;</span><span class="sy4">;</span></span></div></td>
<td> (4) </td>
<td> <span class="t-mark-rev t-since-cxx17">(C++17 起)</span> </td>
</tr>
</tbody>
<tbody class="t-dcl-rev t-dcl-rev-num"><tr class="t-dcl-rev-aux">
<td></td>
<td rowspan="142">(5)</td>
<td></td>
</tr>
<tr class="t-dcl t-since-cxx11 t-until-cxx20">
<td> <div><span class="mw-geshi cpp source-cpp"><span class="kw1">template</span><span class="sy1">&lt;</span> <span class="kw1">class</span> InputIt, <span class="kw1">class</span> UnaryPredicate <span class="sy1">&gt;</span><br />
InputIt find_if_not<span class="br0">&#40;</span> InputIt first, InputIt last, UnaryPredicate q <span class="br0">&#41;</span><span class="sy4">;</span></span></div></td>
<td class="t-dcl-nopad">  </td>
<td> <span class="t-mark-rev t-since-cxx11">(C++11 起)</span> <br /><span class="t-mark-rev t-until-cxx20">(C++20 前)</span> </td>
</tr>
<tr class="t-dcl t-since-cxx20">
<td> <div><span class="mw-geshi cpp source-cpp"><span class="kw1">template</span><span class="sy1">&lt;</span> <span class="kw1">class</span> InputIt, <span class="kw1">class</span> UnaryPredicate <span class="sy1">&gt;</span><br />
<span class="kw4">constexpr</span> InputIt find_if_not<span class="br0">&#40;</span> InputIt first, InputIt last, UnaryPredicate q <span class="br0">&#41;</span><span class="sy4">;</span></span></div></td>
<td class="t-dcl-nopad">  </td>
<td> <span class="t-mark-rev t-since-cxx20">(C++20 起)</span> </td>
</tr>
</tbody><tbody>
<tr class="t-dcl t-since-cxx17">
<td> <div><span class="mw-geshi cpp source-cpp"><span class="kw1">template</span><span class="sy1">&lt;</span> <span class="kw1">class</span> ExecutionPolicy, <span class="kw1">class</span> ForwardIt, <span class="kw1">class</span> UnaryPredicate <span class="sy1">&gt;</span><br />
<p>ForwardIt find_if_not<span class="br0">&#40;</span> ExecutionPolicy<span class="sy3">&amp;&amp;</span> policy,<br />
</p>
&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;ForwardIt first, ForwardIt last, UnaryPredicate q <span class="br0">&#41;</span><span class="sy4">;</span></span></div></td>
<td> (6) </td>
<td> <span class="t-mark-rev t-since-cxx17">(C++17 起)</span> </td>
</tr>
<tr class="t-dcl-sep"><td></td><td></td><td></td></tr>
</tbody></table>

<p>返回指向范围 [first, last) 中满足特定判别标准的首个元素的迭代器（没有这种元素时返回 last）：</p>
<ul>
<li><p><code>1)</code> find 搜索等于（用 operator&#x3D;&#x3D; 比较）value 的元素。</p>
</li>
<li><p><code>3)</code> find_if 搜索谓词 p 对其返回 true 的元素。</p>
</li>
<li><p><code>5)</code> find_if_not 搜索谓词 q 对其返回 false 的元素。</p>
</li>
<li><p>2,4,6) 同 (1,3,5)，但按照 policy 执行。这些重载只有在 <code>std::is_execution_policy_v&lt;std::decay_t&lt;ExecutionPolicy&gt;&gt;</code> (C++20 前)<code>std::is_execution_policy_v&lt;std::remove_cvref_t&lt;ExecutionPolicy&gt;&gt;</code> (C++20 起) 是 true 时才会参与重载决议。</p>
</li>
</ul>
<p><strong>参数</strong></p>
<p>first, last	-	要检验的元素范围</p>
<p>value	-	要与元素比较的值</p>
<p>policy	-	所用的执行策略。细节见执行策略。</p>
<p>p	-	如果是要求的元素则返回 ​true 的一元谓词。对每个（可为 const 的） VT 类型参数 v ，其中 VT 是 InputIt 的值类型，表达式 p(v) 必须可转换为 bool ，无关乎值类别，而且必须不修改 v 。从而不允许 VT&amp; 类型参数，亦不允许 VT ，除非对 VT 而言移动等价于复制 (C++11 起)。​</p>
<p>q	-	如果是要求的元素则返回 ​false 的一元谓词。对每个（可为 const 的） VT 类型参数 v ，其中 VT 是 InputIt 的值类型，表达式 q(v) 必须可转换为 bool ，无关乎值类别，而且必须不修改 v 。从而不允许 VT&amp; 类型参数，亦不允许 VT ，除非对 VT 而言移动等价于复制 (C++11 起)。​</p>
<p><strong>类型要求</strong></p>
<p>-InputIt 必须符合老式输入迭代器 (LegacyInputIterator) 的要求。</p>
<p>-ForwardIt 必须符合老式向前迭代器 (LegacyForwardIterator) 的要求。</p>
<p>-UnaryPredicate 必须符合谓词 (Predicate) 的要求。</p>
<p><strong>返回值</strong></p>
<p>范围 [first, last) 中首个满足以下条件的迭代器 it，或者在没有满足条件的迭代器时返回 last：</p>
<ul>
<li><p>1,2) *it &#x3D;&#x3D; value 是 true</p>
</li>
<li><p>3,4) p(*it) !&#x3D; false 是 true</p>
</li>
<li><p>5,6) q(*it) &#x3D;&#x3D; false 是 true</p>
</li>
</ul>
<p><strong>复杂度</strong></p>
<p>给定 N 为 std::distance(first, last)：</p>
<ul>
<li><p>1,2) 最多应用 N 次 operator&#x3D;&#x3D; 与 value 进行比较</p>
</li>
<li><p>3,4) 最多应用 N 次谓词 p</p>
</li>
<li><p>5,6) 最多应用 N 次谓词 q</p>
</li>
</ul>
<p><strong>异常</strong></p>
<p>拥有名为 ExecutionPolicy 的模板形参的重载按下列方式报告错误：</p>
<ul>
<li><p>如果作为算法一部分调用的函数的执行抛出异常，且 ExecutionPolicy 是标准策略之一，那么调用 <code>std::terminate</code>。对于任何其他 ExecutionPolicy，行为由实现定义。</p>
</li>
<li><p>如果算法无法分配内存，那么抛出 <code>std::bad_alloc</code>。</p>
</li>
</ul>
<p><strong>可能的实现</strong></p>
<p>find</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template&lt;class InputIt, class T&gt;
InputIt find(InputIt first, InputIt last, const T&amp; value)
&#123;
    for (; first !&#x3D; last; ++first)
        if (*first &#x3D;&#x3D; value)
            return first
 
    return last;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>find_if</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template&lt;class InputIt, class UnaryPredicate&gt;
InputIt find_if(InputIt first, InputIt last, UnaryPredicate p)
&#123;
    for (; first !&#x3D; last; ++first)
        if (p(*first))
            return first;
 
    return last;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>find_if_not</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template&lt;class InputIt, class UnaryPredicate&gt;
InputIt find_if_not(InputIt first, InputIt last, UnaryPredicate q)
&#123;
    for (; first !&#x3D; last; ++first)
        if (!q(*first))
            return first;
 
    return last;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>注解</p>
<p>如果没有 C++11 ，那么 <code>std::find_if_not</code> 的等价版本是以取反的谓词使用 <code>std::find_if</code>。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template&lt;class InputIt, class UnaryPredicate&gt;
InputIt find_if_not(InputIt first, InputIt last, UnaryPredicate q)
&#123;
    return std::find_if(first, last, std::not1(q));
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>示例</strong></p>
<p>以下示例在给定的 <code>std::vector</code> 中查找整数。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;iterator&gt;
 
int main()
&#123;
    std::vector&lt;int&gt; v&#123;1, 2, 3, 4&#125;;
    int n1 &#x3D; 3;
    int n2 &#x3D; 5;
    auto is_even &#x3D; [](int i)&#123; return i%2 &#x3D;&#x3D; 0; &#125;;
 
    auto result1 &#x3D; std::find(begin(v), end(v), n1);
    auto result2 &#x3D; std::find(begin(v), end(v), n2);
    auto result3 &#x3D; std::find_if(begin(v), end(v), is_even);
 
    (result1 !&#x3D; std::end(v))
        ? std::cout &lt;&lt; &quot;v 包含 &quot; &lt;&lt; n1 &lt;&lt; &#39;\n&#39;
        : std::cout &lt;&lt; &quot;v 不包含 &quot; &lt;&lt; n1 &lt;&lt; &#39;\n&#39;;
 
    (result2 !&#x3D; std::end(v))
        ? std::cout &lt;&lt; &quot;v 包含 &quot; &lt;&lt; n2 &lt;&lt; &#39;\n&#39;
        : std::cout &lt;&lt; &quot;v 不包含 &quot; &lt;&lt; n2 &lt;&lt; &#39;\n&#39;;
 
    (result3 !&#x3D; std::end(v))
        ? std::cout &lt;&lt; &quot;v 包含偶数：&quot; &lt;&lt; *result3 &lt;&lt; &#39;\n&#39;
        : std::cout &lt;&lt; &quot;v 不包含偶数\n&quot;;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>输出：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">v</span> 包含 <span class="token number">3</span>
<span class="token function">v</span> 不包含 <span class="token number">5</span>
<span class="token function">v</span> 包含偶数：2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h2 id="std-list-splice"><a href="#std-list-splice" class="headerlink" title="std::list&lt;T,Allocator&gt;::splice"></a><code>std::list&lt;T,Allocator&gt;::splice</code></h2><p>API 地址: <a href="https://zh.cppreference.com/w/cpp/container/list/splice">https://zh.cppreference.com/w/cpp/container/list/splice</a> .</p>
<p><code>std::list&lt;T,Allocator&gt;::splice</code></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void splice( const_iterator pos, list&amp; other );
(1)	
void splice( const_iterator pos, list&amp;&amp; other );
(1)	(C++11 起)
void splice( const_iterator pos, list&amp; other, const_iterator it );
(2)	
void splice( const_iterator pos, list&amp;&amp; other, const_iterator it );
(2)	(C++11 起)
void splice( const_iterator pos, list&amp; other,
             const_iterator first, const_iterator last);
(3)	
void splice( const_iterator pos, list&amp;&amp; other,
             const_iterator first, const_iterator last );
(3)	(C++11 起)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>从一个 list 转移元素给另一个。</p>
<p>不复制或移动元素，仅重指向链表结点的内部指针。<code>get_allocator() != other.get_allocator()</code> 时行为未定义。没有迭代器或引用会失效，指向被移动元素的迭代器保持有效，但现在指代到 <code>*this</code> 中，而非到 <code>other</code> 中。</p>
<p><code>1)</code> 从 other 转移所有元素到 <code>*this</code> 中。元素被插入到 pos 指向的元素之前。操作后容器 other 变为空。other 与 <code>*this</code> 指代同一对象时行为未定义。</p>
<p><code>2)</code> 从 other 转移 it 指向的元素到 <code>*this</code>。元素被插入到 pos 指向的元素之前。</p>
<p><code>3)</code> 从 other 转移范围 [first, last) 中的元素到 <code>*this</code>。元素被插入到 pos 指向的元素之前。pos 是范围 [first,last) 中的迭代器时行为未定义。</p>
</blockquote>
<p><strong>参数</strong></p>
<p>pos	-	将插入内容到它之前的元素</p>
<p>other	-	要从它转移内容的另一容器</p>
<p>it	-	要从 other 转移到 *this 的元素</p>
<p>first, last	-	要从 other 转移到 *this 的元素范围</p>
<p><strong>返回值</strong></p>
<p>（无）</p>
<p><strong>异常</strong></p>
<p>不抛出。</p>
<p><strong>复杂度</strong></p>
<p><code>1-2)</code> 常数。</p>
<p><code>3)</code> 如果 other 与 *this 指代同一对象时是常数，否则与 std::distance(first, last) 成线性。</p>
<p><strong>示例</strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
#include &lt;list&gt;
 
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; ostr, const std::list&lt;int&gt;&amp; list)
&#123;
    for (auto &amp;i : list)
        ostr &lt;&lt; &quot; &quot; &lt;&lt; i;
 
    return ostr;
&#125;
 
int main ()
&#123;
    std::list&lt;int&gt; list1 &#x3D; &#123;1, 2, 3, 4, 5&#125;;
    std::list&lt;int&gt; list2 &#x3D; &#123;10, 20, 30, 40, 50&#125;;
 
    auto it &#x3D; list1.begin();
    std::advance(it, 2);
 
    list1.splice(it, list2);
 
    std::cout &lt;&lt; &quot;list1：&quot; &lt;&lt; list1 &lt;&lt; &quot;\n&quot;;
    std::cout &lt;&lt; &quot;list2：&quot; &lt;&lt; list2 &lt;&lt; &quot;\n&quot;;
 
    list2.splice(list2.begin(), list1, it, list1.end());
 
    std::cout &lt;&lt; &quot;list1：&quot; &lt;&lt; list1 &lt;&lt; &quot;\n&quot;;
    std::cout &lt;&lt; &quot;list2：&quot; &lt;&lt; list2 &lt;&lt; &quot;\n&quot;;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>输出：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">list1： <span class="token number">1</span> <span class="token number">2</span> <span class="token number">10</span> <span class="token number">20</span> <span class="token number">30</span> <span class="token number">40</span> <span class="token number">50</span> <span class="token number">3</span> <span class="token number">4</span> <span class="token number">5</span>
list2：
list1： <span class="token number">1</span> <span class="token number">2</span> <span class="token number">10</span> <span class="token number">20</span> <span class="token number">30</span> <span class="token number">40</span> <span class="token number">50</span>
list2： <span class="token number">3</span> <span class="token number">4</span> <span class="token number">5</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="std-partition"><a href="#std-partition" class="headerlink" title="std::partition"></a><code>std::partition</code></h2><p>API 地址: <a href="https://zh.cppreference.com/w/cpp/algorithm/partition">https://zh.cppreference.com/w/cpp/algorithm/partition</a> .</p>
<blockquote>
<p>在标头 <code>&lt;algorithm&gt;</code> 定义</p>
</blockquote>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template&lt; class ForwardIt, class UnaryPredicate &gt;
ForwardIt partition( ForwardIt first, ForwardIt last, UnaryPredicate p );
(C++20 前)
template&lt; class ForwardIt, class UnaryPredicate &gt;
constexpr ForwardIt partition( ForwardIt first, ForwardIt last,
                               UnaryPredicate p );
(1) (C++20 起)
template&lt; class ExecutionPolicy, class ForwardIt, class UnaryPredicate &gt;
ForwardIt partition( ExecutionPolicy&amp;&amp; policy,
                     ForwardIt first, ForwardIt last, UnaryPredicate p );
(2)	(C++17 起)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p><code>1)</code> 重排序范围 [first, last) 中的元素，使得谓词 p 对其返回 true 的元素位于谓词 p 对其返回 false 的元素之前。不保持相对顺序。</p>
<p><code>2)</code> 同 (1)，但按照 <code>policy</code> 执行。此重载只有在 <code>std::is_execution_policy_v&lt;std::decay_t&lt;ExecutionPolicy&gt;&gt;</code> (C++20 前)<code>std::is_execution_policy_v&lt;std::remove_cvref_t&lt;ExecutionPolicy&gt;&gt;</code> (C++20 起) 是 true 时才会参与重载决议。</p>
</blockquote>
<p><strong>参数</strong></p>
<p>first, last	-	要重排序的元素范围</p>
<p>policy	-	所用的执行策略。细节见执行策略。</p>
<p>p	-	如果元素在顺序中应该在其他元素之前则返回 ​true 的一元谓词。</p>
<p>对每个（可为 const 的） VT 类型参数 v ，其中 VT 是 ForwardIt 的值类型，表达式 p(v) 必须可转换为 bool ，无关乎值类别，而且必须不修改 v 。从而不允许 VT&amp; 类型参数，亦不允许 VT ，除非对 VT 而言移动等价于复制 (C++11 起)。​</p>
<p><strong>类型要求</strong></p>
<ul>
<li><p>ForwardIt 必须符合值可交换 (ValueSwappable) 和 老式向前迭代器 (LegacyForwardIterator) 的要求。然而，ForwardIt 在满足老式双向迭代器 (LegacyBidirectionalIterator) 的要求时操作会更高效。</p>
</li>
<li><p>UnaryPredicate 必须符合谓词 (Predicate) 的要求。</p>
</li>
</ul>
<p><strong>返回值</strong></p>
<p>指向第二组元素中首元素的迭代器。</p>
<p><strong>复杂度</strong></p>
<p>给定 <code>N = std::distance(first, last)</code>，</p>
<p><code>1)</code> 准确应用 N 次 p。在 ForwardIt 满足老式双向迭代器 (LegacyBidirectionalIterator) 的要求时最多交换 N&#x2F;2 次，否则最多交换 N 次。</p>
<p><code>2)</code> O(N·log N) 次交换，及应用 O(N) 次 p。</p>
<p><strong>异常</strong></p>
<p>拥有名为 ExecutionPolicy 的模板形参的重载按下列方式报告错误：</p>
<ul>
<li><p>如果作为算法一部分调用的函数的执行抛出异常，且 ExecutionPolicy 是标准策略之一，那么调用 std::terminate。对于任何其他 ExecutionPolicy，行为由实现定义。</p>
</li>
<li><p>如果算法无法分配内存，那么抛出 std::bad_alloc。</p>
</li>
</ul>
<p><strong>可能的实现</strong></p>
<p>实现重载 (1) 并兼容 C++11。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template&lt;class ForwardIt, class UnaryPredicate&gt;
ForwardIt partition(ForwardIt first, ForwardIt last, UnaryPredicate p)
&#123;
    first &#x3D; std::find_if_not(first, last, p);
    if (first &#x3D;&#x3D; last)
        return first;
 
    for (auto i &#x3D; std::next(first); i !&#x3D; last; ++i)
    &#123;
        if (p(*i))
        &#123;
            std::iter_swap(i, first);
            ++first;
        &#125;
    &#125;
 
    return first;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>示例</strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;vector&gt;
#include &lt;forward_list&gt;
 
template &lt;class ForwardIt&gt;
void quicksort(ForwardIt first, ForwardIt last)
&#123;
    if (first &#x3D;&#x3D; last)
        return;
 
    auto pivot &#x3D; *std::next(first, std::distance(first, last) &#x2F; 2);
    ForwardIt middle1 &#x3D; std::partition(first, last, [pivot](const auto&amp; em)
    &#123;
        return em &lt; pivot;
    &#125;);
    ForwardIt middle2 &#x3D; std::partition(middle1, last, [pivot](const auto&amp; em)
    &#123;
        return !(pivot &lt; em);
    &#125;);
 
    quicksort(first, middle1);
    quicksort(middle2, last);
&#125;
 
int main()
&#123;
    std::vector&lt;int&gt; v &#x3D; &#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9&#125;;
    std::cout &lt;&lt; &quot;原来的 vector：\n    &quot;;
    for (int elem : v)
        std::cout &lt;&lt; elem &lt;&lt; &#39; &#39;;
 
    auto it &#x3D; std::partition(v.begin(), v.end(), [](int i)&#123;return i % 2 &#x3D;&#x3D; 0;&#125;);
 
    std::cout &lt;&lt; &quot;\n划分后的 vector：\n    &quot;;
    std::copy(std::begin(v), it, std::ostream_iterator&lt;int&gt;(std::cout, &quot; &quot;));
    std::cout &lt;&lt; &quot; * &quot;;
    std::copy(it, std::end(v), std::ostream_iterator&lt;int&gt;(std::cout, &quot; &quot;));
 
    std::forward_list&lt;int&gt; fl &#x3D; &#123;1, 30, -4, 3, 5, -4, 1, 6, -8, 2, -5, 64, 1, 92&#125;;
    std::cout &lt;&lt; &quot;\n未排序的列表：\n    &quot;;
    for (int n : fl)
        std::cout &lt;&lt; n &lt;&lt; &#39; &#39;;
    std::cout &lt;&lt; &#39;\n&#39;;  
 
    quicksort(std::begin(fl), std::end(fl));
    std::cout &lt;&lt; &quot;快速排序后：\n    &quot;;
    for (int fi : fl)
        std::cout &lt;&lt; fi &lt;&lt; &#39; &#39;;
    std::cout &lt;&lt; &#39;\n&#39;;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>输出：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">原来的 vector：
    <span class="token number">0</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span> <span class="token number">5</span> <span class="token number">6</span> <span class="token number">7</span> <span class="token number">8</span> <span class="token number">9</span> 
划分后的 vector：
    <span class="token number">0</span> <span class="token number">8</span> <span class="token number">2</span> <span class="token number">6</span> <span class="token number">4</span>  *  <span class="token number">5</span> <span class="token number">3</span> <span class="token number">7</span> <span class="token number">1</span> <span class="token number">9</span> 
未排序的列表：
    <span class="token number">1</span> <span class="token number">30</span> <span class="token parameter variable">-4</span> <span class="token number">3</span> <span class="token number">5</span> <span class="token parameter variable">-4</span> <span class="token number">1</span> <span class="token number">6</span> <span class="token parameter variable">-8</span> <span class="token number">2</span> <span class="token parameter variable">-5</span> <span class="token number">64</span> <span class="token number">1</span> <span class="token number">92</span> 
快速排序后：
    <span class="token parameter variable">-8</span> <span class="token parameter variable">-5</span> <span class="token parameter variable">-4</span> <span class="token parameter variable">-4</span> <span class="token number">1</span> <span class="token number">1</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">5</span> <span class="token number">6</span> <span class="token number">30</span> <span class="token number">64</span> <span class="token number">92</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>第二十九篇博文写完，开心！！！！</p>
<p>今天，也是充满希望的一天。</p>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">LuYF-Lemon-love</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://luyf-lemon-love.space/2022/09/28/00029-c-c-za-xiang/">https://luyf-lemon-love.space/2022/09/28/00029-c-c-za-xiang/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">LuYF-Lemon-love</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/C/">
                                    <span class="chip bg-color">C++</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">谢谢小主！</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="https://cos.luyf-lemon-love.space/images/20220511162303.png" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="https://cos.luyf-lemon-love.space/images/20220511162220.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2022/09/29/00030-python-za-xiang/">
                    <div class="card-image">
                        
                        <img src="https://cos.luyf-lemon-love.space/images/比尔吉沃特湾.png" class="responsive-img" alt="00030-Python 杂项">
                        
                        <span class="card-title">00030-Python 杂项</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2022-09-29
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E6%9D%82%E9%A1%B9/" class="post-category">
                                    杂项
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Python/">
                        <span class="chip bg-color">Python</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2022/09/28/00028-linux-za-xiang/">
                    <div class="card-image">
                        
                        <img src="https://cos.luyf-lemon-love.space/images/不朽堡垒.png" class="responsive-img" alt="00028-Linux 杂项">
                        
                        <span class="card-title">00028-Linux 杂项</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2022-09-28
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E6%9D%82%E9%A1%B9/" class="post-category">
                                    杂项
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Linux/">
                        <span class="chip bg-color">Linux</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>


  <!-- 是否加载使用自带的 prismjs. -->
  <script type="text/javascript" src="/libs/prism/prism.min.js"></script>


<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>



    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>


<script src="https://cdn.bootcss.com/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
    MathJax.Hub.Config({
        tex2jax: {inlineMath: [['$', '$'], ['\\(', '\\)']]}
    });
</script>



    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="503838841"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="/libs/aplayer/Meting.min.js"></script>

    

    <div class="container row center-align"
         style="margin-bottom: 15px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2022-2024</span>
            
            <a href="/about" target="_blank">LuYF-Lemon-love</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            
            <br>
            
                &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                        class="white-color">990.6k</span>
            
            
            
                
            
            
                <span id="busuanzi_container_site_pv">
                &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;
                    <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
                <span id="busuanzi_container_site_uv">
                &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;
                    <span id="busuanzi_value_site_uv" class="white-color"></span>
            </span>
            
            <br>

            <!-- 运行天数提醒. -->
            
                <span id="sitetime"> Loading ...</span>
                <script>
                    var calcSiteTime = function () {
                        var seconds = 1000;
                        var minutes = seconds * 60;
                        var hours = minutes * 60;
                        var days = hours * 24;
                        var years = days * 365;
                        var today = new Date();
                        var startYear = "2022";
                        var startMonth = "5";
                        var startDate = "7";
                        var startHour = "4";
                        var startMinute = "53";
                        var startSecond = "32";
                        var todayYear = today.getFullYear();
                        var todayMonth = today.getMonth() + 1;
                        var todayDate = today.getDate();
                        var todayHour = today.getHours();
                        var todayMinute = today.getMinutes();
                        var todaySecond = today.getSeconds();
                        var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                        var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                        var diff = t2 - t1;
                        var diffYears = Math.floor(diff / years);
                        var diffDays = Math.floor((diff / days) - diffYears * 365);

                        // 区分是否有年份.
                        var language = 'zh-CN';
                        if (startYear === String(todayYear)) {
                            document.getElementById("year").innerHTML = todayYear;
                            var daysTip = 'This site has been running for ' + diffDays + ' days';
                            if (language === 'zh-CN') {
                                daysTip = '本站已运行 ' + diffDays + ' 天';
                            } else if (language === 'zh-HK') {
                                daysTip = '本站已運行 ' + diffDays + ' 天';
                            }
                            document.getElementById("sitetime").innerHTML = daysTip;
                        } else {
                            document.getElementById("year").innerHTML = startYear + " - " + todayYear;
                            var yearsAndDaysTip = 'This site has been running for ' + diffYears + ' years and '
                                + diffDays + ' days';
                            if (language === 'zh-CN') {
                                yearsAndDaysTip = '本站已运行 ' + diffYears + ' 年 ' + diffDays + ' 天';
                            } else if (language === 'zh-HK') {
                                yearsAndDaysTip = '本站已運行 ' + diffYears + ' 年 ' + diffDays + ' 天';
                            }
                            document.getElementById("sitetime").innerHTML = yearsAndDaysTip;
                        }
                    }

                    calcSiteTime();
                </script>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/LuYF-Lemon-love" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:luyanfeng_nlp@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>













    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 白天和黑夜主题 -->
<div class="stars-con">
    <div id="stars"></div>
    <div id="stars2"></div>
    <div id="stars3"></div>  
</div>

<script>
    function switchNightMode() {
        $('<div class="Cuteen_DarkSky"><div class="Cuteen_DarkPlanet"></div></div>').appendTo($('body')),
        setTimeout(function () {
            $('body').hasClass('DarkMode') 
            ? ($('body').removeClass('DarkMode'), localStorage.setItem('isDark', '0'), $('#sum-moon-icon').removeClass("fa-sun").addClass('fa-moon')) 
            : ($('body').addClass('DarkMode'), localStorage.setItem('isDark', '1'), $('#sum-moon-icon').addClass("fa-sun").removeClass('fa-moon')),
            
            setTimeout(function () {
            $('.Cuteen_DarkSky').fadeOut(1e3, function () {
                $(this).remove()
            })
            }, 2e3)
        })
    }
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    

    
    
    

    <!-- 雪花特效 -->
    

    <!-- 鼠标星星特效 -->
     
        <script type="text/javascript">
            // 只在桌面版网页启用特效
            var windowWidth = $(window).width();
            if (windowWidth > 768) {
                document.write('<script type="text/javascript" src="/libs/others/star.js"><\/script>');
            }
        </script>
    

     
        <script src="https://ssl.captcha.qq.com/TCaptcha.js"></script>
        <script src="/libs/others/TencentCaptcha.js"></script>
        <button id="TencentCaptcha" data-appid="xxxxxxxxxx" data-cbfn="callback" type="button" hidden></button>
    

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    
    <script type="text/javascript" color="0,0,255"
        pointColor="0,0,255" opacity='0.7'
        zIndex="-1" count="99"
        src="/libs/background/canvas-nest.js"></script>
    

    

    
    <script type="text/javascript" src="/libs/background/ribbon-dynamic.js" async="async"></script>
    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
